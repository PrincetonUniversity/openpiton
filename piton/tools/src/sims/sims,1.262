# Modified by Princeton University on June 9th, 2015
# ========== Copyright Header Begin ==========================================
#
# OpenSPARC T1 Processor File: sims,1.262
# Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
#
# The above named program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License version 2 as published by the Free Software Foundation.
#
# The above named program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this work; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ========== Copyright Header End ============================================

################################################################################
# Verilog run/build/regression script
# sims -help for help
#
#           +-------------->sims
#           |                 |
#           |     +-------+--------+--------+------------+--------+
#           |     |       |        |        |            |        |
#           |  use_iver   |      injobq  interactive     help   version
#           |     |       |        |        |
#           +-----+       |<-------+--------+
#                         |
#                       normal
#                         |
#     +-------+-------+--------+--------+--------+
#     |       |       |        |        |        |
#    vcs   vcs+sas   sas     build    rerun     regr
#                                                |
#                                               build
#                                                |
#                                               injobq
#
#
################################################################################

use warnings;
use strict;

use Cwd;
use Cwd 'chdir';
use File::Basename ;
use File::Find ;
use File::Spec ;
use Getopt::Long ;
use TRELoad 'DiagList', 'Sims' => [':all'] ;
use Fcntl ':flock' ;
use Socket;

################################################################################
# patch PWD just in case
################################################################################

$ENV{PWD} = Cwd::cwd () ;
$| = 1 ;

################################################################################
# install signal handlers
################################################################################

# $SIG{INT} = \&sighandler ;
# $SIG{TERM} = \&sighandler ;
# $SIG{QUIT} = \&sighandler ;
$SIG{__DIE__} = \&sighandler ;

################################################################################
# declare all global variables
################################################################################

my $prg = $0 ;
$prg =~ s/.*\/// ;
my $version = $prg ;
$prg =~ s/,.*// ;          # name of this program
$version =~ s/.*,// ;      # tre version of script
my $pid = $$ ;             # process id of this job
my $sas_pid = 0 ;          # process id of simics run
my $tcl_pid = 0 ;	   # process id of tcl_tap expect process
my $opt_debug = 0 ;        # debug flag
my @argv_copy = @ARGV ;    # copy of original command line arguments
my $user = $ENV{USER} ;    # user name
my $work_dir = undef ;       # work directory
my $launch_dir = $ENV{PWD};  # work directory
my $home_dir = (exists $ENV{HOME}) ? $ENV{HOME} : "~";
my %opt = () ;             # all command line arguments
                           # + config file arguments are concatenated
                           # and stored here
my $sim_start ;            # date when sim started
my $sim_top ;              # date when sim stops
my $orig_tre_search = $ENV{TRE_SEARCH} ;
my $vcs_license_id = 0 ;   # oolm license ids
my $vera_license_id = 0 ;

## for ClearCase usage
my $CLEARCASE_ROOT;
my $CC_VIEW_NAME;
my $CLEARTOOL		= "/usr/atria/bin/cleartool";
my $PROJ_CSHRC		= File::Spec->catfile(
					$home_dir,
					".cshrc." . uc( $proj_vars{proj} )
					     );
if ( exists $ENV{CLEARCASE_ROOT} ) {
    $CLEARCASE_ROOT	= $ENV{CLEARCASE_ROOT};
    my @fields		= split(/\//, $CLEARCASE_ROOT);
    $CC_VIEW_NAME	= $fields[2];
}

################################################################################
# configure Getopt::Long
################################################################################

# Getopt::Long::Configure ('debug') ;
Getopt::Long::Configure ('prefix=-') ;
Getopt::Long::Configure ('no_ignore_case') ;
Getopt::Long::Configure ('permute') ;
Getopt::Long::Configure ('pass_through') ;
Getopt::Long::Configure ('no_auto_abbrev') ;

################################################################################
# declare hash to hold command line arguments + config arguments
################################################################################

%opt = (
        'alias' => "",
        'asm_diag_name' => "",
        'asm_diag_path' => "",
        'asm_diag_root' => [],
        'auditr_args' => [],
        'build' => 1,
        'cc_dv_root' => "",
	'clearcase' => 0,
        'config_rtl' => [],
        'config_cpp_args' => [],
        'copyall' => 0,
        'copydump' => 0,
        'debug' => \$opt_debug,
        'debussy' => 0,
        'dftvert' => 0,
        'diag_pl_args' => [],
        'diaglist' => "",
        'diaglist_cpp_args' => [],
        'drmlog' => 1,
        'jobcommand_name' => "sim_command",
        'dryrun' => 0,
        'dv_root' => "",
        'efc' => 0,
        'efc_args' => [],
        'efuse_image_name' => "",
        'efuse_image_path' => "",
        'efuse_image_root' => [],
        'env_base' => "",
        'fast_boot' => 0,
        'finish_mask' => "",
        'flist' => [],
        'fsdb2vcd' => 0,
        'fsdbfile' => "",
        'fsdbDumplimit' => "",
        'fsdb_glitch' => 0,
        'graft_flist' => "",
        'group' => [],
        'group_name' => "",
        'gzip' => 1,
        'h' => 0,
        'help' => 0,
        'icv_build' => 0,
        'icv_build_args' => [],
        'icv_run' => 0,
        'image_diag_name' => "",
        'image_diag_path' => "",
        'image_diag_root' => [],
        'injobq' => -1,
        'max_cycle' => 0,
        'midas_args' => [],
        'midas_only' => 0,
        'midas_use_tgseed' => 0,
        'model' => "",
        'model_dir' => "",
        'ncv_build' => 0,
        'ncv_build_args' => [],
        'ncv_run' => 0,
        'ntb_lib' => 0,
        'overwrite' => 0,
        'pal_use_tgseed' => 0,
        'parallel' => 0,
        'pci' => 0,
        'pci_args' => [],
        'pci_diag_name' => "",
        'pci_diag_path' => "",
        'pci_diag_root' => [],
        'pico' => 0,
        'pico_het' => 0,
        'post_process_cmd' => [],
        'pre_process_cmd' => [],
        'reg_count' => 0,
        'regress' => 0,
        'regress_date' => "",
        'regress_id' => "",
        'regress_time' => "",
        'report' => 0,
        'rerun' => 0,
        'result_dir' => "",
        'rtl_timeout' => 5000,
	'run_diag_pl' => 1,
        'sas' => 0,
        'saslog' => 1,
        'sas_run_args' => [],
        'other_sim_build' => 0,
        'sim_build_args' => [],
        'other_sim_build_cmd' => "",
        'other_sim_run' => 0,
        'sim_run_args' => [],
        'other_sim_run_cmd' => "",
	'sim_type' => "vcs",
	'sim_q_command' => "/bin/sh",
        'sims_config' => "",
        'simslog' => 1,
        'simslog_name' => "sims.log",
        'sjm' => 0,
        'sjm_args' => [],
        'sjm_diag_name' => "",
        'sjm_diag_path' => "",
        'sjm_diag_root' => [],
        'spis_diag_name' => "",
        'spis_diag_path' => "",
        'spis_diag_root' => [],
        'start_dump' => 0,
        'stop_dump' => 0,
        'stub_mask' => "",
        'sys' => "",
        'tap_diag_name' => "",
        'tap_diag_path' => "",
        'tap_diag_root' => [],
	'tcl_tap' => 0,
	'tcl_tap_diag' => "",
        'tg_seed' => -1,
        'tmp_dir' => ".",
        'tarcopy' => 0,
        'tpt_diag_name' => "",
        'tpt_diag_path' => "",
        'tpt_diag_root' => [],
        'use_auditr' => 0,
        'use_config' => 1,
        'use_denalirc' => "",
        'use_iver' => "",
        'use_oolm' => 0,
        'use_sims_iver' => 0,
        'vcd' => 0,
        'vcdfile' => "",
        'vcs_build' => 0,
        'vcs_build_args' => [],
        'clean' => 0,
        'vcs_cm_args' => "",
        'vcs_cm_cond' => "",
        'vcs_cm_config' => "",
        'vcs_cm_fsmcfg' => "",
        'vcs_cm_merge' => 0,
        'vcs_cm_name' => "cm_data",
        'vcs_finish' => 0,
        'vcs_prof' => 0,
        'build_id' => "",
        'vcs_run' => 0,
        'vcs_use_2state' => 0,
        'vcs_use_cm' => 0,
        'vcs_use_cli' => 0,
        'vcs_use_fsdb' => 1,
        'vcs_use_initreg' => 0,
        'vcs_use_ntb' => 0,
        'vcs_use_rad' => 0,
        'vcs_use_radincr' => 0,
        'vcs_use_sdf' => 0,
        'vcs_use_vcsd' => 1,
        'vcs_use_vera' => 0,
        'vera_build' => -1,
        'vera_build_args' => [],
        'vera_clean' => 0,
        'vera_config_name' => "",
        'vera_config_path' => "",
        'vera_config_root' => [],
        'vera_cov_obj' => [],
        'vera_diag_args' => [],
        'vera_dummy_diag' => "",
        'vera_pal_diag_args' => [],
        'vera_diag_name' => "",
        'vera_diag_path' => "",
        'vera_diag_root' => [],
        'vera_proj_args' => [],
        'vera_run' => 1,
        'vera_vcon_file' => "",
        'version' => 0,
        'vfile' => [],
        'vlint_args' => [],
        'vlint_run' => 0,
        'vlint_top' => "",
        'illust_run' => 0,
        'illust_args' => [],
        'verix_args' => [],
        'verix_libs' => [],
        'verix_run' => 0,
        'verix_top' => "",
        'wait_cycle_to_kill' => 0,
        'zeroIn_build' => 0,
        'zeroIn_dbg_args' => [],
        'zeroIn_checklist' => 0,
        'zeroInSearch_build' => 0,
        'zeroIn_build_args' => [],
        'mem_init_py' => ""
       );

################################################################################
# parse initial command line options
################################################################################

GetOptions (\%opt,
            'h!',
            'help!',
            'version!',
            'use_iver=s',
           ) ;

################################################################################
# relaunch sims with a new iver
################################################################################

if ($opt{use_iver} ne "") {

  die ("DIE. Could not read specified iver \"file\" $opt{use_iver}") if (! -r $opt{use_iver}) ;

  $ENV{TRE_SEARCH} = "$opt{use_iver} $ENV{TRE_SEARCH}" ;

  my $cmd ;
  $cmd .= "$prg " ;
  $cmd .= "-h " if ($opt{h}) ;
  $cmd .= "-help " if ($opt{help}) ;
  $cmd .= "-version " if ($opt{version}) ;

  foreach my $x (@ARGV)
  {
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    ($x =~ s/"/\\"/go) if ($opt{use_auditr}); # Escape quote if using auditr
    $cmd .= "$x " ;
  }

  system ($cmd) ;
  exit (0) ;
}

################################################################################
# print out version
################################################################################

if ($opt{version}) {
  print "$prg version: $version\n";
  exit (0);
}

################################################################################
# print out help
################################################################################

if ($opt{help} or $opt{h}) {
  &usage;
  exit (0);
}

################################################################################
# rerun a diag
################################################################################

GetOptions (\%opt,
            'overwrite!',
            'rerun!',
            'dryrun!',
            'dv_root=s',
            'use_sims_iver',
           ) ;

if ($opt{rerun}) {
  &rerun () ;
  exit (0) ;
}


################################################################################
# define $dv_root
################################################################################

my $dv_root ;

if ($opt{dv_root} ne "") { $dv_root = $opt{dv_root} ; }
elsif (defined $ENV{DV_ROOT}) { $dv_root = $ENV{DV_ROOT} ; }
else { die ("DIE. could not initialize dv_root") ; }

$ENV{DV_ROOT} = $dv_root;

################################################################################
# if this diag must be run in Job Q Manager send ourselves back out
################################################################################

GetOptions (\%opt,
            'injobq!',
            'interactive!',
           ) ;

if (($opt{injobq} == 1) or $opt{interactive})
{
  run_injobq (\@argv_copy, []) ;
  exit (0) ;
}

################################################################################
# parse second set of command line options
################################################################################

GetOptions (\%opt,
            'alias=s',
            'cc_dv_root=s',
            'clearcase!',
            'config_cpp_args=s@',
            'debug' => \$opt_debug,
            'diaglist=s',
            'diaglist_cpp_args=s@',
            'group=s@',
            'model_dir=s',
            'parallel!',
            'regress!',
            'regress_id=s',
            'report!',
            'result_dir=s',
            'sim_type=s',
            'sim_q_command=s',
            'sims_config=s',
            'simslog!',
            'simslog_name=s',
            'build_id=s',
            'vera_build!',
           ) ;

# Set check for Vera license before issuing job
# do not do this as it breaks the environment at Sun
# $ENV{VERA_WAIT_LICENSE} = 1;

################################################################################
# define $cc_dv_root
################################################################################

my $cc_dv_root ;

if ( $opt{clearcase} ) {
    if ($opt{cc_dv_root} ne "") { $cc_dv_root = $opt{cc_dv_root} ; }
    elsif (defined $ENV{CC_DV_ROOT}) { $cc_dv_root = $ENV{CC_DV_ROOT} ; }
    elsif (defined $proj_vars{cc_dv_root}) {
	$cc_dv_root = $proj_vars{cc_dv_root}; }
    else { die ("DIE. could not initialize cc_dv_root") ; }
}

################################################################################
# define $result_dir
################################################################################

my $result_dir ;

if ($opt{result_dir} ne "") { $result_dir = $opt{result_dir} ; }
else { $result_dir = $ENV{PWD} ; }

################################################################################
# define $sims_config
################################################################################

my $sims_config ;

if ($opt{sims_config} ne "") { $sims_config = $opt{sims_config} ; }
else { $sims_config = "$dv_root/$proj_vars{sims_config}/sims.config" ; }

################################################################################
# define $model_dir
################################################################################

my $model_dir ;

if ($opt{model_dir} ne "") { $model_dir = $opt{model_dir} ; }
elsif (defined $ENV{MODEL_DIR}) { $model_dir = $ENV{MODEL_DIR}; }
else { die ("DIE. could not initialize model_dir") ; }

$ENV{MODEL_DIR} = $model_dir ;

################################################################################
# define $diaglist
################################################################################

my $diaglist ;

if ($opt{diaglist} ne "")
{
  $diaglist = $opt{diaglist} ;

  if (!($diaglist =~ /^\//))
  {
    $diaglist = "$ENV{PWD}/$diaglist" ;
  }
}
else
{
  $diaglist = "$dv_root/$proj_vars{diaglist}/master_diaglist" ;
}

################################################################################
# Check the env vars
################################################################################

if (defined $ENV{DRMJOBSCRATCHSPACE}) { $opt{tmp_dir} = $ENV{DRMJOBSCRATCHSPACE} ; }
elsif (-d "/var/tmp") { $opt{tmp_dir} = "/var/tmp"; }

################################################################################
# run a regression instead of a single diag
################################################################################

if (($#{$opt{group}} != -1) and ($opt{alias} eq ""))
{
  &regress();
  exit (0) ;
}

################################################################################
# get diag options from diaglist
################################################################################

if (($#{$opt{group}} != -1) and ($opt{alias} ne ""))
{
  &get_opt_from_diaglist () ;
}

################################################################################
# create the run area for the diag when in regression mode and cd there
################################################################################

if ($opt{regress})
{
  my $job_id = undef ;
  if (defined $ENV{SLURM_JOB_ID}) {
      $job_id = $ENV{SLURM_JOB_ID} ;
  }
  else {
      $job_id = int(rand(100000000)) ;
  }

  if (defined $ENV{DRMJOBSCRATCHSPACE}) { $work_dir = "$ENV{DRMJOBSCRATCHSPACE}/$opt{alias}:job${job_id}" ; }
  else { $work_dir = "$opt{tmp_dir}/${user}:$opt{alias}:$$:job${job_id}" ; }

  `mkdir -p $work_dir` ;
  die ("DIE. could not create directory $work_dir to run regression") if ($?) ;
  chdir "$work_dir" ;
}

################################################################################
# this is a regular vcs/sas build run
################################################################################

GetOptions (\%opt,
            'sys=s',
           ) ;

################################################################################
#
################################################################################

&redirect () ;
&print_header () ;

################################################################################
# if this is not a regression a sys must be defined
################################################################################

die ("DIE. -sys argument not defined") if ($opt{sys} eq "") ;
&parse_args ($opt{sys}, 1) ;
print "$prg: group_name = $opt{group_name}\n" if ($opt{regress}) ;
print "$prg: regress_date = $opt{regress_date}\n" if ($opt{regress}) ;
print "$prg: regress_time = $opt{regress_time}\n" if ($opt{regress}) ;

################################################################################
# first check that the model and build_id are defined
################################################################################

die ("DIE. -model is not defined") if ($opt{model} eq "") ;

my $model_path ;

if ($opt{build_id} eq "") { $model_path = "$model_dir/$opt{model}/rel-0.1" ; }
else { $model_path = "$model_dir/$opt{model}/$opt{build_id}" ; }

################################################################################
# create the model area if necessary
################################################################################

&create_model_path () if (($opt{zeroIn_build}) or
                          ($opt{zeroInSearch_build}) or
                          ($opt{zeroIn_checklist}) or
                          ($opt{vera_build} == 1) or
                          ($opt{vcs_build}) or
                          ($opt{other_sim_build}) or
                          ($opt{icv_build}) or
                          ($opt{ncv_build})
                          ) ;

################################################################################
# build the vera/ntb testbench
################################################################################

&vera_build () if ((((($opt{vcs_build}) or ($opt{other_sim_build}) or ($opt{icv_build}) or ($opt{ncv_build})) and
			($opt{vera_build} == -1)) or
                    ($opt{vera_build} == 1)) and
                   (! $opt{dftvert})) ;

################################################################################
# do some pre building stuff - generate flist and graft model
################################################################################

&pre_build () if (($opt{vlint_run}) or ($opt{vcs_build})
                  or ($opt{verix_run}) or ($opt{other_sim_build}) or
                  ($opt{icv_build}) or
		  ($opt{ncv_build})) ;

################################################################################
# compile zeroIn
################################################################################

&zeroIn_build () if (($opt {zeroIn_build}) or ($opt {zeroInSearch_build}) or ($opt {zeroIn_checklist})) ;

################################################################################
# run vlint on the model
################################################################################

&vlint_run () if ($opt{vlint_run}) ;

################################################################################
# run verix on the model
################################################################################

&verix_run () if ($opt{verix_run}) ;

################################################################################
# build the vcs model
################################################################################

&vcs_build () if ($opt{vcs_build}) ;
################################################################################
# build the ncv model
################################################################################

&ncv_build () if (($opt{ncv_build})) ;

################################################################################
# build the icarus model
################################################################################

&icv_build () if (($opt{icv_build})) ;

################################################################################
# build the other simulator  model
################################################################################

&other_sim_build () if (($opt{other_sim_build})) ;

################################################################################
# assemble .s diag
################################################################################

&assemble_diag () if ($opt{asm_diag_name} ne "") ;

################################################################################
# assemble .tap diag
################################################################################

&assemble_tap_diag () if ($opt{tap_diag_name} ne "") ;

################################################################################
# copy .image diag
################################################################################

&copy_image () if ($opt{image_diag_name} ne "") ;

################################################################################
# copy efuse image
################################################################################

&copy_efuse_image () if ($opt{efuse_image_name} ne "" and
                        ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run})) ;

################################################################################
# generate an efuse image
################################################################################

&generate_efuse_image () if ($opt{efc}) ;

################################################################################
# copy .tpt diag
################################################################################

&copy_tpt () if ($opt{tpt_diag_name} ne "") ;

################################################################################
# compile .vr config
################################################################################

&compile_vera_config () if ($opt{vera_config_name} ne "") ;

################################################################################
# compile .vr diag when -dftvert is also present
################################################################################

&compile_dftvert_diag () if (($opt{vera_diag_name} ne "") and
                             ($opt{dftvert})) ;

################################################################################
# compile .vr diag
################################################################################

&compile_vera_diag () if (($opt{vera_diag_name} ne "") and
                          (!$opt{dftvert})) ;

################################################################################
# generate an sjm diag
################################################################################

&generate_sjm_diag () if ($opt{sjm} or ($opt{sjm_diag_name} ne "")) ;

################################################################################
# generate a pci diag
################################################################################

&generate_pci_diag () if ($opt{pci} or ($opt{pci_diag_name} ne "")) ;

################################################################################
# launch sas/simics
################################################################################

&sas_run () if ($opt{sas}) ;

################################################################################
# launch tcl_tap
################################################################################

if ( $opt{tcl_tap} and
     (  $opt{vcs_run} or
	$opt{dry_run}
     )
    )
{
    &tcl_tap_run ();
}

################################################################################
# mss specific stuff
################################################################################

if (($opt{sys} eq "mss") and ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run}))
{
  my @files = ("mem.data", "tag.data", "index.data") ;

  foreach my $file (@files)
  {
    die ("DIE. $opt{env_base}/$file not found") if (!(-f "$opt{env_base}/$file")) ;
    `cp $opt{env_base}/$file .` ;
    die ("DIE. could not copy $file to $ENV{PWD}\n") if ($?) ;
    `chmod +w $file` ;
    die ("DIE. could not change permission of $file\n") if ($?) ;
  }
}

################################################################################
# dram specific stuff
################################################################################

if ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run})
{
  my $file;
  if ($opt{use_denalirc} eq "") {
    $file = "$opt{env_base}/.denalirc" ;
  } else {
    $file = "$opt{use_denalirc}" ;
     die ("DIE. could not find \"$file\" for -use_denalirc") if (! -f $file);
  }

  if (-f $file) {
    `cp $file .denalirc` ;
        die ("DIE. could not copy $file to run area\n") if ($?) ;
    `chmod +w .denalirc` ;
        die ("DIE. could not change permission of .denalirc\n") if ($?) ;
  }
}

if (($opt{sys} eq "dram") and ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run}))
{
  my @files = ("dram_config.doc", "mem.data", "mem1.data", "mem2.data") ;

  foreach my $file (@files)
  {
    die ("DIE. $opt{env_base}/$file not found") if (!(-f "$opt{env_base}/$file")) ;
    `cp $opt{env_base}/$file .` ;
    die ("DIE. could not copy $file to $ENV{PWD}\n") if ($?) ;
    `chmod +w $file` ;
    die ("DIE. could not change permission of $file\n") if ($?) ;
  }
}

################################################################################
# launch simulator
################################################################################

&vcs_run () if ($opt{vcs_run}) ;
&ncv_run () if ($opt{ncv_run}) ;
&icv_run () if ($opt{icv_run}) ;
&other_sim_run () if ($opt{other_sim_run}) ;

################################################################################
# run diag.pl if present
################################################################################

if (    -e "diag.pl" and
	( $opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run} or $opt{sas}) and
	$opt{run_diag_pl}
   )
{
  my $diag_pl_args = join (" ", @{$opt{diag_pl_args}}) ;

  print "$prg: executing diag.pl $diag_pl_args\n";

  if (!$opt{dryrun})
  {
    my $waitstatus = call_program("$ENV{PERL_CMD} diag.pl $diag_pl_args",
                                  "diag_pl.log");
    print ("$prg: Warning diag.pl run exited with error\n") if ($waitstatus) ;
  }
}

################################################################################
# post process the output
################################################################################

&post_process if ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run} or $opt{sas}) ;

&print_footer () ;

exit (0);

################################################################################
# run simulation in Job Q Manager
################################################################################

sub run_injobq
{
  my $argv_ref = shift ;
  my $drm_opt_ref = shift ;
  my @argv_copy = @ARGV ;
  # Save global options because they get modified by drm_opt ..
  my %opt_copy = %opt ;

  unshift (@ARGV, @{$drm_opt_ref}) ;

  GetOptions (\%opt,
              'auditr_args=s@',
	      'clearcase!',
              'drmlog!',
              'jobcommand_name=s',
              'group=s',
              'use_auditr!',
              'vcs_use_ntb!',
              'slurm!',
             ) ;

  @ARGV = @argv_copy ;

  if ( $opt{clearcase} ) {
    printf("sims set to work with ClearCase view: $CC_VIEW_NAME\n");
  }

  # create the Job Q Manager command

  `rm -rf $opt{jobcommand_name}` ;

  open (JOBCMD, "> $opt{jobcommand_name}") or die ("DIE. Could not open simulation command file") ;

  if ($opt{slurm}) {
    print JOBCMD "#!/bin/sh\n" ;
    print JOBCMD "#SBATCH -N 1                   # nodes=1\n" ;
    if (defined $ENV{PTON_HANOI}) {
        print JOBCMD "#SBATCH -t 3:00:00               # walltime=1hr6mins\n" ;
    } else {
        print JOBCMD "#SBATCH --ntasks-per-node=1    # ppn=1\n" ;
        print JOBCMD "#SBATCH --mem=2048              # mem=2GB\n" ;
        print JOBCMD "#SBATCH -t 3:20:00               # walltime=1hr6mins\n" ;
    }
    print JOBCMD "#SBATCH -J  $opt{jobcommand_name} # jobname\n\n" ;
  }

  if ( $opt{clearcase} ) {
    #print JOBCMD "TRE_SEARCH='$ENV{TRE_SEARCH}';export TRE_SEARCH; ";
  }
  print JOBCMD "auditr \\\n" if ($opt{use_auditr}) ;
  print JOBCMD (join (" \\\n", @{$opt{auditr_args}})) if ($opt{use_auditr}) ;
  print JOBCMD " \\\n" if ($opt{use_auditr}) ;

  my $os = `uname -s`;
  $os =~ s/\n//g;

  if ( $opt{clearcase} ) {
    print JOBCMD "$prg " ;
  }
  else {
    # Add plimit to solve file descriptor problem for NCverilog
    if ((($opt{sim_type}) eq "ncv") and ($os eq "SunOS")) {
	print JOBCMD "plimit -n 1024,1024 \$\$\n";
    }
    print JOBCMD "$prg \\\n" ;
  }

  foreach my $x (@{$argv_ref})
  {
    next if (($x =~ /-injobq/) or ($x =~ /-interactive/));
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/));
    ($x =~ s/"/\\"/go) if ($opt{use_auditr}); # Escape quote if using auditr

    if ( $opt{clearcase} ) {
      print JOBCMD "$x " ;
    }
    else {
      print JOBCMD "$x \\\n" ;
    }
  }
  if ($os eq "Linux") {
    print JOBCMD "-nosas \\\n";
  }
  print JOBCMD "-nouse_oolm\n" ;
  close (JOBCMD) ;

  `chmod 0777 $opt{jobcommand_name}` ;

  # submit to job Q manager

  my $job_submit = $opt{sim_q_command};

  my $cmd = $job_submit;
  $cmd .= " ";

  # $cmd .= "-m -i " if ($opt{interactive}) ;


  if ( $opt{clearcase} ) {
    $cmd .= " $CLEARTOOL setview -exec \'source  ${PROJ_CSHRC};";
    $cmd .= " setenv DV_ROOT $cc_dv_root; cd $ENV{PWD}; ";
    # Don't know how to use constraints file
    $cmd .= " $ENV{PWD}/$opt{jobcommand_name} " ;
    $cmd .= "\' $CC_VIEW_NAME";
    print "$cmd \n";
  }
  else {
    $cmd .= "$ENV{PWD}/$opt{jobcommand_name} " ;
  } # else !clearcase

  #system ($cmd) if (!($opt{dryrun})) ;
  #($output = `until $cmd; do echo "Submit failed"; sleep 30; done`) if (!($opt{dryrun})) ;
  
  if (!($opt{dryrun})) {
    my $returncode = system ($cmd) ;
    while ($returncode) {
        sleep 30;
        print "Submit failed" ;
        $returncode = system ($cmd) ;
    }
  }

  # Restore global options ..
  %opt = %opt_copy ;
}

################################################################################
# update sims cycle database
################################################################################

sub update_db
{
  my $cycles = shift ;
  my $start = shift ;
  my $stop = shift ;
  my $freq = shift ;
  my $status = shift ;
  chomp ($cycles) ;
  chomp ($start) ;
  chomp ($stop) ;
  chomp ($freq) ;
  my $regress_date = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;

  my $db_dir = undef ;

  foreach my $x (@{$proj_vars{sims_db}})
  {
    $db_dir = $x if (-d $x) ;
  }

  return if (!defined $db_dir) ;

  my $dbfile = "$db_dir/$regress_date";

  open (DB, ">> $dbfile") or return ;
  flock (DB, LOCK_EX) ;
  seek (DB, 0, 2) ;
  print DB "$opt{sys}|$cycles|$freq|$start|$stop|$status\n" ;
  flock (DB, LOCK_UN) ;
  close (DB) ;
  system("chmod -f go+rw $dbfile") if (-o $dbfile);
}

################################################################################
# redirect all output to tee
################################################################################

sub redirect
{
  my $logfile = $opt{simslog_name} ;

  if ($opt{regress})
  {
    $logfile = "$launch_dir/$opt{simslog_name}" ;
  }

  if ($opt{simslog})
  {
    tee_stdout ($logfile) ;
    open(STDERR, ">&=STDOUT") or die "DIE. Could not make stderr an alias to stdout: $!";
  }
}

################################################################################
# tee stdout to log file
################################################################################

sub tee_stdout {
  my $file = shift;
  die "DIE. tee_stdout() called without a filename" unless defined $file;
  return if my $pid = open(STDOUT, '|-');
  die "DIE. Cannot fork when trying to tee stdout: $!" unless defined $pid;

  open(SIMSLOG, ">$file") or die "DIE.  Could not open $file for writing: $!";
  my $old_fh = select SIMSLOG;
  $| = 1;
  select $old_fh;
  $| = 1;
  while(<STDIN>) {
    print;
    print SIMSLOG;
  }
  exit(0);
}

################################################################################
# print out a header when sims starts
################################################################################

sub print_header
{
  # print "$prg @argv_copy\n";
  open (SIMS_HISTORY, ">> history.sims") ;
  my $date = `date` ;
  chomp ($date) ;

  print "$prg ";
  print SIMS_HISTORY "$date $prg ";

  foreach my $x (@argv_copy)
  {
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    print "$x " ;
    print SIMS_HISTORY "$x " ;
  }

  print "\n" ;
  print SIMS_HISTORY "\n" ;

  print "$prg: ====================================================\n";
  print "$prg:   Simulation Script for OpenPiton\n";
  print "$prg:   Modified by Princeton University on June 9th, 2015\n";
  print "$prg: ====================================================\n";

  print "$prg: ====================================================\n";
  print "$prg:   Simulation Script for OpenSPARC T1\n";
  print "$prg:   Copyright (c) 2001-2006 Sun Microsystems, Inc.\n";
  print "$prg:   All rights reserved.\n";
  print "$prg: ====================================================\n";

  print "$prg: start_time $date\n";
  print "$prg: running on ";
  system ("hostname") ;
  print "$prg: uname is ";
  system ("uname -a") ;
  print "$prg: version $version\n";
  print "$prg: dv_root $dv_root\n";
  print "$prg: cc_dv_root $cc_dv_root\n" if $opt{clearcase};
  print "$prg: model_dir $model_dir\n";
  print "$prg: tre_search $ENV{TRE_SEARCH}\n" ;
  print "$prg: Frozen tre_search $orig_tre_search\n" if (($#{$opt{group}} != -1) and ($opt{alias} eq "")) ;
  print "$prg: drmjobid $ENV{DRMRJSJOBOID}\n" if (defined $ENV{DRMRJSJOBOID}) ;
  print "\$RESULT_DIR=$result_dir\n" if $opt_debug ;
  print "\$DV_ROOT=$dv_root\n" if $opt_debug ;
  print "\$SIMS_CONFIG=$sims_config\n" if $opt_debug ;
  print "\$MODEL_DIR=$model_dir\n" if $opt_debug ;
  print "\$DIAGLIST=$diaglist\n" if $opt_debug ;
  print "\$TMP_DIR=$opt{tmp_dir}\n" if $opt_debug ;
  print "\$PWD=$ENV{PWD}\n" if $opt_debug ;
}

################################################################################
# print out a footer when sims ends
################################################################################

sub print_footer
{
  print "$prg: stop_time ";
  system ("date") ;
}

################################################################################
# regress subroutine
################################################################################

sub regress
{
  # figure out the name of the regression

  my $regress_date = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;
  my $regress_time = sprintf "%2.2d_%2.2d_%2.2d", (localtime) [2], (localtime) [1], (localtime) [0] ;

  my $regress_id ;
  if ($opt{regress_id} eq "")
  {
    $regress_id = $regress_date ;
    my $count = 0 ;
    while (-d "$result_dir/${regress_date}_${count}") {$count++;}
    $regress_id .= "_$count" ;
  }
  else
  {
    $regress_id = $opt{regress_id} ;
  }

  # create the directory where regression will be run

  system ("mkdir -p $result_dir/$regress_id") ;
  die  ("DIE. Could not create result area for regression") if ($?) ;

  chdir ("$result_dir/$regress_id") or die ("DIE. Could not change directory into $result_dir/$regress_id") ;

  # recreate a copy of all the tre files in this directory
  my $tre_search = &freeze_tre( "$result_dir/$regress_id" );
  $ENV{TRE_SEARCH} = $tre_search if $tre_search ne "";

  if ($opt{parallel})
  {
    my @new_args = () ;

    foreach my $x (@argv_copy)
    {
      if ($x =~ /-group/)
      {
      }
      elsif ($x =~ /-parallel/)
      {
      }
      else
      {
        ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
        push (@new_args, $x) ;
      }
    }

    foreach my $gname (@{$opt{group}})
    {
      my @cmd ;
      push (@cmd, "-result_dir=$result_dir") ;
      push (@cmd, "-regress_id=$regress_id") ;
      push (@cmd, "-group=$gname") ;
      push (@cmd, "-simslog_name=sims.$gname.log") ;
      push (@cmd, @new_args) ;

      my @drm_opt ;
      push (@drm_opt, "-jobcommand_name=drm_command_$gname") ;

      run_injobq (\@cmd, \@drm_opt) ;
      die  ("DIE. Could not launch group") if ($?) ;
    }

    exit (0) ;
  }

  &redirect () ;
  &print_header () ;

  @argv_copy = @ARGV ;

  # Pass the config_cpp_args through ..
  foreach my $x ( @{$opt{config_cpp_args}} ) {
    push(@argv_copy, "-config_cpp_args $x");
  }


  my $nobuild = 0 ;

  foreach my $x (@argv_copy)
  {
    $nobuild = 1 if ($x =~ /-nobuild/) ;
    if ($x =~ /-fast_boot/) {
      push (@{$opt{diaglist_cpp_args}}, "-DFAST_BOOT") ;
      push (@{$opt{config_cpp_args}}, "-DFAST_BOOT") ;
      push(@argv_copy, "-config_cpp_args -DFAST_BOOT");
    }
  }

  foreach my $gname (@{$opt{group}})
  {
    # put the pre-processed diaglist in here

    die ("DIE. Diag list $diaglist not found") if (! -f $diaglist) ;

    my $diagcppargs = join(' ', @{$opt{diaglist_cpp_args}});
    print "$prg: processing diaglist $diaglist ($diagcppargs) ..\n" ;
    system ("bw_cpp -B $diagcppargs -undef -I$dv_root/verif/diag $diaglist > $result_dir/$regress_id/master_diaglist.$gname") ;
    die  ("DIE. Could not pre-process the master_diaglist") if ($?) ;

    # open the diaglist and look for the group in it

    my $diagList = DiagList->new ("$result_dir/$regress_id/master_diaglist.$gname") ;

    my $group = $diagList->find_group ($gname) ;

    die ("DIE. Group name $gname not found in diag list $diaglist") if (! defined $group) ;

    print "$prg: processing group $gname\n";
    foreach my $tag ($group->build_tags ())
    {
      my $buildargs = $diagList->build_args ($tag) ;
      my ($sys) = ($buildargs =~ /sys\s*=\s*([a-z0-9_]+)\s*/i) ;

      # read the config file for this sys
      my @argv_config ;
      &get_config ($sys, \@argv_config) ;

      # extract the options from the config file
      my @dream_options  = () ;

      foreach my $x (@argv_config)
      {
        push (@dream_options, $x) if ($x =~ /\-drm\_/) ;
        push (@dream_options, $x) if ($x =~ /\-vcs_use_ntb/) ;
      }

      # figure out the name of the model build id
      my $build_id ;

      if (($opt{build_id} eq "") and ($nobuild == 0))
      {
        $build_id = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;
        my $count = 0 ;
        open (MODEL_LOCK, "> lock") or die "DIE. Could not lock model" ;
        flock (MODEL_LOCK, LOCK_EX) ;
        while (-d "$model_dir/$sys/${tag}_${build_id}_${count}") {$count++;}
        $build_id = "${tag}_${build_id}_${count}" ;
        system ("mkdir -p $model_dir/$sys/$build_id") ;
        die "DIE. Could not create build_id for regression" if ($?) ;
        flock (MODEL_LOCK, LOCK_UN) ;
        close (MODEL_LOCK) ;
      }
      elsif ($opt{build_id} eq "")
      {
        $build_id = "rel-0.1" ;
      }
      else
      {
        $build_id = $opt{build_id} ;
      }

      # call sims to build this model
      my $cmd ;
      $cmd .= "$prg " ;
      $cmd .= "-nosimslog " ;
      if (($opt{sim_type}) eq "vcs") {
          $cmd .= "-vcs_build " ;
      } elsif (($opt{sim_type}) eq "ncv") {
          $cmd .= "-ncv_build " ;
      } elsif (($opt{sim_type}) eq "icv") {
          $cmd .= "-icv_build " ;
      } else {
          $cmd .= "-other_sim_build " ;
      }
      if (($opt{vera_build} == -1) or ($opt{vera_build} == 1)) {
          $cmd .= "-vera_build " ;
      } else {
          $cmd .= "-novera_build " ;
      }
      $cmd .= "$buildargs " ;
      $cmd .= "-build_id=$build_id " ;

      foreach my $x (@argv_copy)
      {
        ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
        $cmd .= " $x " ;
      }

      $cmd .= " -nosas " ;
      $cmd .= " -novcs_run " ;

      my $rc = 0 ;
      print "$cmd\n" if $opt_debug ;
      if (! $opt{dryrun})
      {
        system ($cmd) ; my $build_stat = $?;

        `cp -f $model_dir/$sys/$build_id/diff_rel.log $result_dir/$regress_id/diff_rel_$tag.log` if (-f "$model_dir/$sys/$build_id/diff_rel.log") ;

        die  ("DIE. Could not build model for regression") if ($build_stat) ;
      }

      chdir "$result_dir/$regress_id" or die  ("DIE. Could not cd to result area for regression") ;


      foreach my $diagname ($group->list_diags($tag))
      {
        my $diag    = $group->find_diag($tag, $diagname) ;
        my @runargs = $diag->get_cmd_argv() ;
        my @run_dream_options = @dream_options ;

        my @argv = @argv_copy ;
        unshift (@argv, @runargs) ;
        # unshift (@argv, @dream_options) ;

        foreach my $x (@runargs)
        {
          push (@run_dream_options, $x) if ($x =~ /\-drm\_/) ;
        }

        my $reg_count = 0 ;

        foreach my $x (@argv)
        {
          if ($x =~ /\-reg\_count/)
          {
            $reg_count = $x ;
            $reg_count =~ s/\-reg\_count=(.*)/$1/ ;
            $reg_count-- ;
          }
        }

        my $alias = $diag->get_full_name () ;

        while ($reg_count >= 0)
        {
          my $dirname = "$alias:$reg_count" ;

          `rm -rf $dirname` ;
          die  ("DIE. Could not remove diag area $dirname for regression") if ($?) ;
          `mkdir $dirname` ;
          die  ("DIE. Could not create diag area $dirname for regression") if ($?) ;

          chdir $dirname or die  ("DIE. Could not cd to diag area $dirname") ;

          my @cmd ;
          # push (@cmd, "$prg") ;
      	  if (($opt{sim_type}) eq "vcs") {
              push (@cmd, "-vcs_run") ;
      	  } elsif (($opt{sim_type}) eq "ncv") {
              push (@cmd, "-ncv_run") ;
      	  } elsif (($opt{sim_type}) eq "icv") {
              push (@cmd, "-icv_run") ;
	  } else {
              push (@cmd, "-other_sim_run") ;
	  }
          push (@cmd, "-sys=${sys}") ;
          push (@cmd, "-build_id=${build_id}") ;
          push (@cmd, "-regress_id=${regress_id}") ;
          push (@cmd, "-alias=${dirname}") ;
          push (@cmd, "-dv_root=${dv_root}") ;
          push (@cmd, "-model_dir=${model_dir}") ;
          push (@cmd, "-result_dir=${result_dir}") ;
          push (@cmd, "-sims_config=${sims_config}") ;
          push (@cmd, "-group_name=$gname") ;
          push (@cmd, "-regress_date=$regress_date") ;
          push (@cmd, "-regress_time=$regress_time") ;
          my $real_asm_diag_name = $dirname;
          $real_asm_diag_name =~ s/\:.*//;
          push (@cmd, "-vcs_cm_name=$real_asm_diag_name") ;
          # push (@cmd, "-vcs_cm_name=${dirname}") ;
          if ($opt{clearcase}) {
            push (@cmd, "-use_iver=$result_dir/$regress_id/tre/sims.iver") ;
          }
          push (@cmd, @argv) ;
          push (@cmd, "-nobuild") ;
          # push (@cmd, "-novcs_build") ;
          # push (@cmd, "-novera_build") ;
          # push (@cmd, "-nozeroIn_build") ;
          # push (@cmd, "-nozeroInSearch_build") ;
          push (@cmd, "-regress") ;

          # submit command Job Q manager

          print "$prg: ${dirname}\n" ;
          print ("$cmd\n") if ($opt_debug) ;
          # print (@cmd) ;

          if (! $opt{dryrun})
          {
            # system ($cmd) ;
            if ($opt{injobq} != 0)
            {
              run_injobq (\@cmd, \@run_dream_options) ;
            }
            else
            {
              my $cmd = join (" ", @cmd) ;
              system ("$prg $cmd") ;
            }
          }

          $reg_count-- ;
          chdir ".." or die  ("DIE. Could not cd up to result directory") ;
        }
      }
    }
  }

  chdir "$result_dir" or die  ("DIE. Could not cd to result directory for regression report") ;
  if ($opt{report})
  {
    print "$prg: launching regreport !!!\n" ;
    `regreport wait_sec=300 -regress $result_dir/$regress_id/regress.log $result_dir/$regress_id` ;
  }

  &print_footer () ;
}

################################################################################
# this will wait until regreport reports all diags finished
################################################################################

sub throttle
{
  my $result_dir = shift ;
  my $regress_id = shift ;

  THROTTLE: while (1)
  {
    open (IN, "regreport $result_dir/$regress_id |") or die ("DIE. could not invoke regreport") ;
    my @report = <IN> ;
    close (IN) ;

    foreach my $line (@report)
    {
      if ($line =~ /UnFinished/)
      {
        my @count = split (/\|/, $line) ;
        my $all_count = $count[$#count-1] ;

        last THROTTLE if ($all_count == 0)
      }
    }

    sleep (3600) ;
  }
}

################################################################################
# rerun a diag from the sims.log
################################################################################

sub rerun
{
  my $args = "" ;

  foreach my $x (@argv_copy)
  {
    next if ($x =~ /-rerun/) ;
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    $args .= " $x ";
  }

  if (! -f "sims.log") {die ("DIE. Could not find original run command");}

  open (CMD, "< sims.log") or die ("DIE. Could not open sims.log") ;
  my $cmd = <CMD> ;
  close (CMD) ;

  chomp $cmd ;
  $cmd =~ s/\s+-regress_id=\S+//g ;
  $cmd =~ s/\s+-regress_date=\S+//g ;
  $cmd =~ s/\s+-regress_time=\S+//g ;
  $cmd =~ s/\s+-regress//g ;
  $cmd =~ s/\s+-result_dir=\S+//g ;
  $cmd =~ s/\s+-nouse_oolm//g ;

  my @sims_tg_seed = `grep 'using random' sims.log` ;
  my $sims_tg_seed = $sims_tg_seed[0] ;
  $sims_tg_seed =~ s/.*?(\d+)/$1/ ;
  chomp $sims_tg_seed ;

  if ($opt{use_sims_iver})
  {
    my @sims_iver = `grep tre_search sims.log` ;

    my $sims_iver = $sims_iver[0] ;
    $sims_iver =~ s/^.*?:\stre_search\s// ;
    chomp $sims_iver ;
    $ENV{TRE_SEARCH} = $sims_iver ;
  }

  if (!$opt{overwrite})
  {
    my $count = 0 ;
    while (-d "rerun_${count}") {$count++;}
    my $rerun_dir = "rerun_${count}" ;

    system ("mkdir -p $rerun_dir") ;
    die ("DIE. could not create rerun directory $rerun_dir") if ($?) ;

    chdir $rerun_dir or die ("DIE. could not change to rerun directory $rerun_dir") ;
  }

  if ( $sims_tg_seed ne "" ) {
      system ("$cmd -tg_seed=$sims_tg_seed $args") ;
  } else {
      system ("$cmd $args") ;
  }
}

################################################################################
# replace the source files in the flist with new ones from the graft file
################################################################################

sub graft_flist
{
  print "$prg: grafting flist\n" ;

  open (IFLIST, "< flist") or die ("DIE. can't open flist") ;
  my @iflist = <IFLIST> ;
  close (IFLIST) ;

  my $graft_file	= $opt{graft_flist};
  $graft_file =~ s/\$(\w+)/$ENV{$1}/g ;
  open (GFLIST, "< $graft_file")
	    or die ("DIE. can't open graft file: $graft_file") ;
  my @gflist = <GFLIST> ;
  close (GFLIST) ;
  @gflist = map { s/\$(\w+)/$ENV{$1}/g } @gflist;

  my $ifile = join ('', @iflist) ;

  foreach my $gfile_path (@gflist)
  {
    my $gfile = $gfile_path ;
    $gfile =~ s/^.*\/(\S+)\s*/$1/ ;
    chomp $gfile ;
    chomp $gfile_path ;
    print "gfile: $gfile $gfile_path\n" if $opt_debug ;
    $ifile =~ s/^.*\/$gfile/$gfile_path/m ;
  }

  open (OFLIST, "> flist") or die ("DIE. can't open graft flist") ;
  print OFLIST $ifile ;
  close (OFLIST) ;
}

################################################################################
# Generate the verilog config file
################################################################################

sub gen_config
{
  open (OCONF, ">config.v") or die ("DIE. can't open file config.v") ;

  print OCONF "`timescale 1ps/1ps\n" ;

  foreach my $unit (@{$opt{config_rtl}})
  {
    print OCONF "`define $unit\n";
  }

  close (OCONF);
}

################################################################################
# Generate the flist file
################################################################################

sub gen_flist
{

  open (OFLIST, ">flist") or die ("DIE. can't open flist file") ;

  print OFLIST "$ENV{PWD}/config.v\n";


  foreach my $flist (@{$opt{flist}})
  {
    $flist =~ s/\$(\w+)/$ENV{$1}/g ;

    # look for IBM flists
    if ($opt{ibm}){
       my $ibmflist = $flist . ".ibm";
       if (-e $ibmflist){
          $flist = $ibmflist;
          # print("debug: IBM flist found: $flist\n");
       }
    }

    # look for Xilinx flists
    if ($opt{xilinx}){
       my $xlxflist = $flist . ".xlx";
       if (-e $xlxflist){
          $flist = $xlxflist;
          # print("debug: Xilinx flist found: $flist\n");
       }

       if ($opt{ml605}) {
           my $ml605flist = $flist . ".ml605";
           if (-e $ml605flist) {
              $flist = $ml605flist;
              # print("\n\ndebug: Virtex flist found: $flist\n");
           }
       }

       if ($opt{artix7}) {
           my $artix7flist = $flist . ".artix7";
           if (-e $artix7flist) {
              $flist = $artix7flist;
              # print("\n\ndebug: Virtex flist found: $flist\n");
           }
       }

        if ($opt{vc707}) {
           my $vc707flist = $flist . ".vc707";
           if (-e $vc707flist) {
              $flist = $vc707flist;
              # print("\n\ndebug: Virtex flist found: $flist\n");
           }
       }      
    }
    
    open (IFLIST, "< $flist") or die ("DIE. can't open flist file $flist") ;

    print "$flist\n\n\n\n";

    while (<IFLIST>)
    {
      my $line = $_ ;
      my $base = dirname ($flist) ;

      $line =~ s/^\s*(.*?)\s*$/$1/ ;
      $line .= "\n" ;

      if (($line =~ /^\s*\/\//) or
          ($line =~ /^\s*$/))
      {
        next ;
      }

      $line =~ s/\$(\w+)/$ENV{$1}/g ;

      if ($line =~ /^\+incdir\+\//)
      {
      }
      elsif ($line =~ /^\+incdir\+/)
      {
        $line =~ s/^\+incdir\+(.*)/\+incdir\+$base\/$1/ ;
      }
      elsif ($line =~ /^\-v\s\//)
      {
      }
      elsif ($line =~ /^\-v/)
      {
        $line =~ s/-v\s*(.*)/-v $base\/$1/ ;
      }
      elsif ($line =~ /^-y\s\//)
      {
      }
      elsif ($line =~ /^-y/)
      {
        $line =~ s/-y\s*(.*)/-y $base\/$1/ ;
      }
      elsif (($line =~ /^\+define/) or
             ($line =~ /^\+libext/) or
             ($line =~ /^\+librescan/))
      {
      }
      elsif ($line !~ /^\//)
      {
        $line = "$base/$line" ;
      }

      # Tri
      # Now we run pyphp
      # Alexey: for ISE change .v(h).tmp on .tmp.v(h)
      # print("\$preline is $line\n");
      # my $dotvfile = 

      if ($opt{ibm} || $opt{xilinx}){
         my $ibmfile = (split(' ',substr($line, 0, -1)))[-1] . ".ibm.v";
         my $xlxfile = (split(' ',substr($line, 0, -1)))[-1] . ".xlx.v";

         if (!(($opt{ibm} && -e $ibmfile) || ($opt{xilinx} && -e $xlxfile))){
           my $linepyv = (split(' ',substr($line, 0, -1)))[-1] . ".pyv";
           # print("\$linepyv is $linepyv\n");
           my $linetmp = substr($line, 0, -3) . ".tmp.". substr($line, -2, 1);
           my $linetmpout = (split(' ',substr($line, 0, -3)))[-1] . ".tmp." . substr($line, -2, 1);
           if (-e $linepyv)
           {
             # print("original is $line\n");
             system("pyhp.py $linepyv > $linetmpout");
             $line = $linetmp . "\n";
             # print("\$Running pyhp.py for $line\n");
             # die ("randomly");
           }
         }
      } else {
        my $linepyv = (split(' ',substr($line, 0, -1)))[-1] . ".pyv";
        # print("\$linepyv is $linepyv\n");
        my $linetmp = substr($line, 0, -3) . ".tmp.". substr($line, -2, 1);
        my $linetmpout = (split(' ',substr($line, 0, -3)))[-1] . ".tmp." . substr($line, -2, 1);
        if (-e $linepyv)
        {
          # print("original is $line\n");
          system("pyhp.py $linepyv > $linetmpout");
          $line = $linetmp . "\n";
          # print("\$Running pyhp.py for $line\n");
          # die ("randomly");
        }
      }

      # look for IBM srams
      if ($opt{ibm}){
         my $ibmfile = (split(' ',substr($line, 0, -1)))[-1] . ".ibm.v";
         if (-e $ibmfile){
            $line = $ibmfile . "\n";
            # print("debug: IBM sram found: $line\n");
         }
      }

      # look for Xilinx brams
      if ($opt{xilinx}){
         my $xlxfile = (split(' ',substr($line, 0, -1)))[-1] . ".xlx.v";
         if (-e $xlxfile){
            $line = $xlxfile . "\n";
            # print("debug: Xilinx bram found: $line\n");
         }
      }

      # print("\$line is $line\n");

      print OFLIST $line ;
    }

    close (IFLIST) ;
  }

  foreach my $file (@{$opt{vfile}})
  {
    chomp $file ;
    $file =~ s/\$(\w+)/$ENV{$1}/g ;
    print OFLIST "$file\n" ;
  }

  if ( ($opt{vera_build} and !$opt{vcs_use_ntb}) or # pure Vera or
       ($opt{vera_build} and $opt{ntb_lib}) )       # NTB as a lib compile
  {
    print OFLIST "$model_path/$opt{model}_top_shell.v\n" if (!$opt{dftvert}) ;
  }

  close (OFLIST) ;
}

################################################################################
# if a signal is received do some cleanup - kill sas, delete tmp directories
################################################################################

sub sighandler
{
  my $sig = shift ;

  print "$prg: Caught a SIG${sig}\n" ;

  if ((defined $sas_pid) and ($sas_pid != 0))
  {
    kill -9, $sas_pid ;
  }

  if ((defined $tcl_pid) and ($tcl_pid != 0))
  {
    kill -9, $tcl_pid ;
  }

  `regreport -1 > status.log` ;

  if (defined $opt{tmp_dir})
  {
    if (-f "$opt{tmp_dir}/$opt{fsdbfile}.$$")
    {
      `mv $opt{tmp_dir}/$opt{fsdbfile}.$$ $opt{fsdbfile}`;
      # die ("DIE. unable to move sim.fsdb over\n") if ($?) ;
    }

    if (-f "$opt{tmp_dir}/sim.fsdb.$$")
    {
      `mv $opt{tmp_dir}/sim.fsdb.$$ sim.fsdb`;
      # die ("DIE. unable to move sim.fsdb over\n") if ($?) ;
    }
  }

  if ($opt{regress})
  {
    if ((defined ($work_dir)) and (-d "$work_dir"))
    {
      chdir $launch_dir ;
      `/bin/cp -r $work_dir/* $launch_dir` ;
      `/bin/rm -rf $work_dir` ;
      `/bin/rmdir $work_dir` ;
    }
  }

  exit (1) ;
}


################################################################################
# create model area
################################################################################

sub create_model_path
{
    my $cur_dir = $ENV{PWD};

    print "$prg: creating model directory $model_path\n" ;
    `mkdir -p $model_path` ;
    die ("DIE. could not create directory $model_path") if ($?) ;
    chdir ($model_path) or die ("DIE. Could not cd to $model_path") ;

    # clean up the model area as needed

    if ($opt{clean})
    {
      print "$prg: cleaning up build directory\n" ;
      `rm -rf csrc simv.daidir simv AxisWork` ;
    }

    `mkdir -p vera` ;
    die ("DIE. could not create directory vera under $model_path") if ($?) ;

    `mkdir -p lib` ;
    die ("DIE. could not create directory lib under $model_path") if ($?) ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

################################################################################
# build the vera/ntb testbench
################################################################################

sub vera_build
{
    my $cur_dir = $ENV{PWD};

    if ($opt{vcs_use_ntb} and $opt{ntb_lib}) {
      print "$prg: building NTB bench files into libtb.so\n" ;
    } else {
      print "$prg: building vera model\n" ;
    }

    print "$prg: vera_start ",`date` ;

    # change to the vera build area

    my $vera_dir = "$opt{env_base}/vera" ;
    print "$prg: building vera model in $vera_dir\n" ;
    chdir $vera_dir or die ("DIE. Can't cd to $vera_dir") ;

    # Check VERA variables
    if (defined($ENV{VERA_HOME})) {
        print "$prg: VERA_HOME is $ENV{VERA_HOME}\n";
    }

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    if($proj_vars{has_denali}) {
      if (!defined($ENV{DENALI})) { die ("DIE. DENALI not defined.") }
      print "$prg: DENALI is $ENV{DENALI}\n";
    }

    # create the vera make command

    push (@{$opt{vera_build_args}}, "VERA_LIBDIR=$model_path/vera") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/a-z/A-Z/ ;
      push (@{$opt{vera_build_args}}, "$obj=1") ;
    }

    my $vera_build_cmd = "gmake ";
    $vera_build_cmd .= join (" ", @{$opt{vera_build_args}}) ;

    # clean the vera testbench

    if ($opt{vera_clean})
    {
      print "$prg: $vera_build_cmd clean\n" ;

      if (!$opt{dryrun})
      {
        system ("$vera_build_cmd clean") ;
        die ("DIE. failed cleaning vera testbench in $ENV{PWD}") if ($?) ;

        # system ("rm -rf *") ;
        # die ("DIE. failed removing all files in $ENV{PWD}") if ($?) ;
      }
    }

    # builds the lib
    $vera_build_cmd .= " ntb_lib"   if ($opt{vera_build} and
                                        $opt{vcs_use_ntb} and $opt{ntb_lib}) ;
    # builds a flist file for VCS
    $vera_build_cmd .= " ntb_all"   if ($opt{vera_build} and
                                        $opt{vcs_use_ntb} and !$opt{ntb_lib}) ;

    # build the vera testbench
    print "$prg: $vera_build_cmd\n" ;

    if (! $opt{dryrun})
    {
      system ($vera_build_cmd) ;
      die ("DIE. failed making vera testbench in $ENV{PWD}") if ($?) ;
    }

    if (! $opt{vcs_use_ntb})
    {
      # generate a project file in the model area
      chdir $model_path or die ("DIE. Can't cd to $model_path") ;

      print "$prg: creating vera project file\n" ;
      open (PROJFILE, "> vera/$opt{model}_top.proj") or die ("DIE. could not create project file") ;

      print PROJFILE "main $opt{model}_top\n" ;
      print PROJFILE "$ENV{PWD}/vera/$opt{vera_vcon_file}\n" if ($opt{vera_vcon_file} ne "") ;

      opendir (LIBDIR, "vera") or die ("DIE. can't open vera directory") ;
      my @filenames = readdir LIBDIR ;
      closedir (LIBDIR) ;

      foreach my $filename (@filenames)
      {
        if ($filename =~ /\.vro/)
        {
          print PROJFILE ("$ENV{PWD}/vera/$filename\n") ;
        }
      }

      close (PROJFILE) ;

      # generate the vera shell verilog file

      print "$prg: creating vera shell file\n" ;

      foreach my $obj (@{$opt{vera_cov_obj}})
      {
        $obj =~ tr/a-z/A-Z/ ;
        push (@{$opt{vera_proj_args}}, "-D$obj") ;
      }

      push (@{$opt{vera_proj_args}}, "vera/$opt{model}_top.proj") ;

      my $vera_proj_cmd = "vera -proj " ;
      $vera_proj_cmd .= join (" ", @{$opt{vera_proj_args}}) ;

      print "$prg: $vera_proj_cmd\n" ;

      if (! $opt{dryrun})
      {
        system ($vera_proj_cmd) ;
        die ("DIE. vera shell creation failed") if ($?) ;
      }
    }

    print "$prg: vera_stop ",`date` ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

################################################################################
# pre build vcs code
################################################################################

sub pre_build
{
  my $cur_dir = $ENV{PWD};

  # go to the model area
  chdir $model_path or die ("DIE. Can't cd to $model_path\n") ;

  # generate the rtl config file
  &gen_config ($opt{model});

  # Generate the flist file
  &gen_flist ();

  system("cp -f flist $cur_dir");
  # merge in the graft flist
  if ($opt{graft_flist} ne "")
  {
    &graft_flist () ;
  }

  # go back to where this block was invoked
  chdir $cur_dir ;
}

################################################################################
# build a vcs model
################################################################################

sub vcs_build
{

    &vcs_s10_setup();

    my $cur_dir = $ENV{PWD};

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;

    # copy the sdf file
    my $sdf_file = "$opt{env_base}/cmp_top.sdf" ;
    `cp -f $sdf_file .` if (($opt{vcs_use_sdf}) and (-f $sdf_file)) ;

    chomp(my $vcsd = "vcsd".$proj_vars{vcsprefix});
    $vcsd =~ s/(vcsd)vcs(\d+)\.(\d+).*/$1$2$3/;
    my $vcsd_tab = "vcsd.tab";

    # figure out the location of vcs from variable
    if (!defined($ENV{VCS_HOME})) { die ("DIE. VCS_HOME not defined.") }
    print "$prg: VCS_HOME is $ENV{VCS_HOME}\n";

    # figure out the location of vera from variable
    if (defined($ENV{VERA_HOME})) {
        print "$prg: VERA_HOME is $ENV{VERA_HOME}\n";
    }

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";


    if($proj_vars{has_denali}) {
      if (!defined($ENV{DENALI})) { die ("DIE. DENALI not defined.") }
      print "$prg: DENALI is $ENV{DENALI}\n";
    }

    # figure out the location of 0in from variable
    if (($opt{zeroIn_build}) || ($opt{zeroInSearch_build})) {
        if (!defined($ENV{HOME_0IN})) { die ("DIE. HOME_0IN not defined.") }
        print "$prg: HOME_0IN is $ENV{HOME_0IN}\n";
    }

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    my $os_cpu = `uname -s`;
    $os_cpu =~ s/\n//g;
    if ($os_cpu eq "SunOS") {
      $os_cpu .= "/";
      $os_cpu .= `uname -p`;
    } else {
      $os_cpu .= "/";
      $os_cpu .= `uname -m`;
    }
    $os_cpu =~ s/\n//g;
    my $lib_path = "-L$ENV{DV_ROOT}/tools/";
    $lib_path .= $os_cpu;
    $lib_path .= "/lib ";

    # copy generic sim_build_args to vcs_build_args

    foreach my $x (@{$opt{sim_build_args}})
    {
        push (@{$opt{vcs_build_args}}, $x);
    }

    push (@{$opt{vcs_build_args}}, "+compsdf") if ($opt{vcs_use_sdf}) ;
    push (@{$opt{vcs_build_args}}, "+rad") if ($opt{vcs_use_rad}) ;
    push (@{$opt{vcs_build_args}}, "+vcsd") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
    push (@{$opt{vcs_build_args}}, "-vera") if ($opt{vera_build}) ;
    push (@{$opt{vcs_build_args}}, "-file $model_path/vera/ntb_flist") if ($opt{vcs_use_ntb}) ;
    # push (@{$opt{vcs_build_args}}, "+radincr") if ($opt{vcs_use_radincr}) ;
    push (@{$opt{vcs_build_args}}, "+2state") if ($opt{vcs_use_2state}) ;
    push (@{$opt{vcs_build_args}}, "+initreg") if ($opt{vcs_use_initreg}) ;
#    push (@{$opt{vcs_build_args}}, "+noinitnegedge") if ($opt{vcs_use_2state}) ;
    push (@{$opt{vcs_build_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm}) ;
    push (@{$opt{vcs_build_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne "")) ;
    push (@{$opt{vcs_build_args}}, "-cm_fsmcfg $opt{vcs_cm_fsmcfg}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_fsmcfg} ne "")) ;
    push (@{$opt{vcs_build_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne "")) ;
    push (@{$opt{vcs_build_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm}) ;
    push (@{$opt{vcs_build_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}) ;
    push (@{$opt{vcs_build_args}}, "+cli -line") if ($opt{vcs_use_cli}) ;

    # tri: adds some lint info
    # tri: remove the useless inout port lintings
    # push (@{$opt{vcs_build_args}}, "+lint=TFIPC-L,noPCTIO-L");
    # push (@{$opt{vcs_build_args}}, "+lint=noPCTIO-L");
    # VNGS = variable never get set, happens a lot when variables are wires set by submodules
    #
    push (@{$opt{vcs_build_args}}, "+lint=all,noVCDE,noVNGS,noPCTIO-L,noPCTIO");
    push (@{$opt{vcs_build_args}}, "+warn=all");

    # figure out the location of debussy from variable
    if (!defined($ENV{NOVAS_HOME})) {
	print "$prg: NOVAS_HOME not defined, Debussy will not be used.\n";
        push (@{$opt{vcs_build_args}}, "+define+FSDB_OFF");
    } else {
        my $novas_home = $ENV{NOVAS_HOME};

        push (@{$opt{vcs_build_args}}, "-P $novas_home/share/PLI/vcs/SOLARIS2/debussy.tab") if ($opt{vcs_use_fsdb} and !$opt{vcs_use_vcsd}) ;
        push (@{$opt{vcs_build_args}}, "$novas_home/share/PLI/vcs/SOLARIS2/pli.a") if ($opt{vcs_use_fsdb} and !$opt{vcs_use_vcsd}) ;
        push (@{$opt{vcs_build_args}}, "-P $novas_home/share/PLI/$vcsd/SOLARIS2/$vcsd_tab") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
        push (@{$opt{vcs_build_args}}, "$novas_home/share/PLI/$vcsd/SOLARIS2/pli.a") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
    }
    push (@{$opt{vcs_build_args}}, "+define+FSDB_OFF") if (!$opt{vcs_use_fsdb}) ;
    push (@{$opt{vcs_build_args}}, "+define+NO_VERA") if (!$opt{vera_build}) ;
    push (@{$opt{vcs_build_args}}, "+define+TCL_TAP_TEST") if ($opt{tcl_tap}) ;
    push (@{$opt{vcs_build_args}}, "-l compile.log") ;
    push (@{$opt{vcs_build_args}}, "-f flist") ;

        push (@{$opt{vcs_build_args}}, "+libext+.v") ;
        push (@{$opt{vcs_build_args}}, "-Mupdate") ;
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX_VIVADO}/data/verilog/src/unisims") ;
        push (@{$opt{vcs_build_args}}, "+incdir+$ENV{XILINX_VIVADO}/data/verilog/src") ;
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX}/verilog/src/unisims") ;
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX}/verilog/src/XilinxCoreLib") ;
        push (@{$opt{vcs_build_args}}, "+incdir+$ENV{XILINX}/verilog/src") ;

    if ($opt{xilinx})
    {
        push (@{$opt{config_rtl}}, "PITON_PROTO") ;
        push (@{$opt{vcs_build_args}}, "+libext+.v") ;
        push (@{$opt{vcs_build_args}}, "-Mupdate") ;
    }

    if ($opt{ml605})
    {
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX}/verilog/src/unisims") ;
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX}/verilog/src/XilinxCoreLib") ;
        push (@{$opt{vcs_build_args}}, "+incdir+$ENV{XILINX}/verilog/src") ;
    }

    if ($opt{artix7})
    {
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX_VIVADO}/data/verilog/src/unisims") ;
        push (@{$opt{vcs_build_args}}, "+incdir+$ENV{XILINX_VIVADO}/data/verilog/src") ;
    }

    if ($opt{vc707})
    {
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX_VIVADO}/data/verilog/src/unisims") ;
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX_VIVADO}/data/vhdl/src/unisims/secureip") ;
        push (@{$opt{vcs_build_args}}, "-y $ENV{XILINX_VIVADO}/data/vhdl/src/unisims/primitive") ;
        push (@{$opt{vcs_build_args}}, "+incdir+$ENV{XILINX_VIVADO}/data/verilog/src") ;
    }

    if ($opt{ibm})
    {
        push (@{$opt{config_rtl}}, "IBM_SRAM_RF16X160_MODEL_CHECKER") ;
        push (@{$opt{config_rtl}}, "IBM_SRAM_RF32X80_MODEL_CHECKER") ;
        push (@{$opt{config_rtl}}, "IBM_SRAM_CACHE_TAG_MODEL_CHECKER") ;
        push (@{$opt{config_rtl}}, "IBM_SRAM_LSU_ICACHE_MODEL_CHECKER") ;
    }

    if ($opt{zeroIn_build})
    {
      push (@{$opt{vcs_build_args}}, "$ENV{HOME_0IN}/0InPLI/vcs/lib0InvcsPLI.so") ;
      push (@{$opt{vcs_build_args}}, "-f $model_path/zeroInDir/0in_sim.arg") ;
    }

    if ($opt{zeroInSearch_build})
    {
      push (@{$opt{vcs_build_args}}, "$ENV{HOME_0IN}/0InPLI/vcs/lib0InvcsPLI.so") ;
      push (@{$opt{vcs_build_args}}, "-f $model_path/zeroInDir/0in_seed.arg") ;
    }

    push (@{$opt{vcs_build_args}}, "+define+COPROCESSOR_ON") if ($opt{dmbr}) ;
    push (@{$opt{vcs_build_args}}, "+define+DMBR_CHECKER") if ($opt{dmbr_checker}) ;
    push (@{$opt{vcs_build_args}}, "+define+PITON_PROTO") if ($opt{xilinx}) ;
    push (@{$opt{vcs_build_args}}, "+define+ML605_BOARD") if ($opt{ml605});
    push (@{$opt{vcs_build_args}}, "+define+NEXYS4DDR_BOARD") if ($opt{artix7});
    push (@{$opt{vcs_build_args}}, "+define+VC707_BOARD") if ($opt{vc707});
    push (@{$opt{vcs_build_args}}, "+define+GENESYS2_BOARD") if ($opt{genesys2});

    # build the model
    print "$prg: Building rtl model\n" ;

    my $vcs_build_cmd  = "vcs " ;

    # lib_path needs to be before vcs_build_args

    $vcs_build_cmd .= $lib_path;

    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{vcs_build_args}})
    {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
        $vcs_build_cmd .= "$x " ;
      }
    }


    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    print "$prg: $vcs_build_cmd\n";

    if (! $opt{dryrun})
    {
      system ($vcs_build_cmd) ;
      die ("DIE. failed building model") if ($?) ;
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
}

################################################################################
# build a ncv model
################################################################################

sub ncv_build
{
    my $cur_dir = $ENV{PWD};

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;

    # copy the sdf file
    my $sdf_file = "$opt{env_base}/cmp_top.sdf" ;
    `cp -f $sdf_file .` if (($opt{vcs_use_sdf}) and (-f $sdf_file)) ;

    chomp(my $vcsd = "vcsd".$proj_vars{vcsprefix});
    $vcsd =~ s/(vcsd)vcs(\d+)\.(\d+).*/$1$2$3/;
    my $vcsd_tab = "vcsd.tab";

    # figure out the location of vcs from variable
    if (!defined($ENV{NCV_HOME})) { die ("DIE. NCV_HOME not defined.") }
    print "$prg: NCV_HOME is $ENV{NCV_HOME}\n";

    # figure out the location of vera from variable
    if (defined($ENV{VERA_HOME})) {
        print "$prg: VERA_HOME is $ENV{VERA_HOME}\n";
    }

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";


    if($proj_vars{has_denali}) {
      if (!defined($ENV{DENALI})) { die ("DIE. DENALI not defined.") }
      print "$prg: DENALI is $ENV{DENALI}\n";
    }

    # figure out the location of 0in from variable
    if (($opt{zeroIn_build}) || ($opt{zeroInSearch_build})) {
        if (!defined($ENV{HOME_0IN})) { die ("DIE. HOME_0IN not defined.") }
        print "$prg: HOME_0IN is $ENV{HOME_0IN}\n";
    }

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    my $os_cpu = `uname -s`;
    $os_cpu =~ s/\n//g;
    if ($os_cpu eq "SunOS") {
      $os_cpu .= "/";
      $os_cpu .= `uname -p`;
    } else {
      $os_cpu .= "/";
      $os_cpu .= `uname -m`;
    }
    $os_cpu =~ s/\n//g;

    # build ncelab and ncsim executable files if not present

    my $ncsim = "$ENV{DV_ROOT}/tools/";
    $ncsim .= $os_cpu;
    $ncsim .= "/ncsim";

    my $ncelab = "$ENV{DV_ROOT}/tools/";
    $ncelab .= $os_cpu;
    $ncelab .= "/ncelab";

    if ( -f $ncsim) { print "$prg: file $ncsim found\n"; }
    if ( -f $ncelab) { print "$prg: file $ncelab found\n"; }

    if ((! -f $ncsim ) or (! -f $ncelab )) {
	my $cur_dir = $ENV{PWD};
	chdir $ENV{DV_ROOT} or
	    die ("DIE can't change directory to $ENV{DV_ROOT}");
	chdir "tools/pli" or
	    die ("DIE can't change directory to tools/pli");
	print "$prg: Calling make ncvexe\n";
	system("make ncvexe");
        die ("DIE. failed building ncsim or ncelab executable") if ($?) ;
	chdir $cur_dir ;
    }

    # copy generic sim_build_args to ncv_build_args

    foreach my $x (@{$opt{sim_build_args}})
    {
        push (@{$opt{ncv_build_args}}, $x);
    }

    my $cmd = "+ncsimexe+";
    $cmd .= $ncsim;
    $cmd .= " +ncelabexe+";
    $cmd .= $ncelab;
    $cmd .= " " ;
    push (@{$opt{ncv_build_args}}, $cmd);
    push (@{$opt{ncv_build_args}}, "-arr_access");
    push (@{$opt{ncv_build_args}}, "+access+rw");
    #push (@{$opt{ncv_build_args}}, "+compsdf") if ($opt{vcs_use_sdf}) ;
    #push (@{$opt{ncv_build_args}}, "+rad") if ($opt{vcs_use_rad}) ;
    #push (@{$opt{ncv_build_args}}, "+vcsd") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$ENV{VERA_HOME}/5.x/lib/libvera_loadpli:vera_boot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libiob_ncv:iob_boot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libjbus_mon_ncv:jbus_monboot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libmem_pli_ncv:mem_boot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libmonitor_ncv:monitor_boot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libsjm_ncv:sjm_boot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libsocket_pli_ncv:socketboot");
    #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libutility_ncv:utility_boot");
    #push (@{$opt{ncv_build_args}}, "-file $model_path/vera/ntb_flist") if ($opt{vcs_use_ntb}) ;
    ## push (@{$opt{ncv_build_args}}, "+radincr") if ($opt{vcs_use_radincr}) ;
    #push (@{$opt{ncv_build_args}}, "+2state") if ($opt{vcs_use_2state}) ;
    #push (@{$opt{ncv_build_args}}, "+initreg") if ($opt{vcs_use_initreg}) ;
##    push (@{$opt{ncv_build_args}}, "+noinitnegedge") if ($opt{vcs_use_2state}) ;
    #push (@{$opt{ncv_build_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm}) ;
    #push (@{$opt{ncv_build_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne "")) ;
    #push (@{$opt{ncv_build_args}}, "-cm_fsmcfg $opt{vcs_cm_fsmcfg}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_fsmcfg} ne "")) ;
    #push (@{$opt{ncv_build_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne "")) ;
    #push (@{$opt{ncv_build_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm}) ;
    #push (@{$opt{ncv_build_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}) ;
    #push (@{$opt{ncv_build_args}}, "+cli -line") if ($opt{vcs_use_cli}) ;

    # figure out the location of debussy from variable
    if (!defined($ENV{NOVAS_HOME})) {
	print "$prg: NOVAS_HOME not defined, Debussy will not be used.\n";
        push (@{$opt{ncv_build_args}}, "+define+FSDB_OFF");
    } else {
        my $novas_home = $ENV{NOVAS_HOME};

        push (@{$opt{ncv_build_args}}, "+ncloadpli1=$novas_home/share/PLI/nc_xl/SOLARIS2/nc_loadpli1/debpli:debpli_boot");
    }
	# if ($opt{vcs_use_fsdb} and !$opt{vcs_use_vcsd}) ;
    #push (@{$opt{ncv_build_args}}, "$novas_home/share/PLI/vcs/SOLARIS2/pli.a") if ($opt{vcs_use_fsdb} and !$opt{vcs_use_vcsd}) ;
    #push (@{$opt{ncv_build_args}}, "-P $novas_home/share/PLI/$vcsd/SOLARIS2/$vcsd_tab") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
    #push (@{$opt{ncv_build_args}}, "$novas_home/share/PLI/$vcsd/SOLARIS2/pli.a") if ($opt{vcs_use_fsdb} and $opt{vcs_use_vcsd}) ;
    #push (@{$opt{ncv_build_args}}, "+define+FSDB_OFF") if (!$opt{vcs_use_fsdb}) ;
    push (@{$opt{ncv_build_args}}, "+define+NO_VERA") if (!$opt{vera_build}) ;
    #push (@{$opt{ncv_build_args}}, "+define+TCL_TAP_TEST") if ($opt{tcl_tap}) ;
    push (@{$opt{ncv_build_args}}, "+name+$opt{sys}") ;
    push (@{$opt{ncv_build_args}}, "-l compile.log") ;
    push (@{$opt{ncv_build_args}}, "-f flist") ;

    if ($opt{zeroIn_build})
    {
      push (@{$opt{ncv_build_args}}, "$ENV{HOME_0IN}/0InPLI/vcs/lib0InvcsPLI.so") ;
      push (@{$opt{ncv_build_args}}, "-f $model_path/zeroInDir/0in_sim.arg") ;
    }

    if ($opt{zeroInSearch_build})
    {
      push (@{$opt{ncv_build_args}}, "$ENV{HOME_0IN}/0InPLI/vcs/lib0InvcsPLI.so") ;
      push (@{$opt{ncv_build_args}}, "-f $model_path/zeroInDir/0in_seed.arg") ;
    }

    my $ld_lib_path .= "$ENV{DV_ROOT}/tools/";
    $ld_lib_path .= $os_cpu;
    $ld_lib_path .= "/lib";
    $ld_lib_path .= ":$ENV{NCV_HOME}/tools/lib/64bit:";
    $ld_lib_path .= $ENV{LD_LIBRARY_PATH};
    $ENV{LD_LIBRARY_PATH} = $ld_lib_path;
    print "$prg: LD_LIBRARY_PATH is $ENV{LD_LIBRARY_PATH}\n";

    # build the model
    print "$prg: Building rtl model\n" ;

    my $ncv_build_cmd = "LD_LIBRARY_PATH=";
    $ncv_build_cmd .= $ld_lib_path;
    $ncv_build_cmd  .= " ; export LD_LIBRARY_PATH;  ncverilog -C " ;

    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{ncv_build_args}})
    {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
        $ncv_build_cmd .= "$x " ;
      }
    }

    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    print "$prg: $ncv_build_cmd\n";

    if (! $opt{dryrun})
    {
      system ($ncv_build_cmd) ;
      die ("DIE. failed building model") if ($?) ;
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
}
################################################################################
# Icarus build
################################################################################

sub icv_build
{
    my $cur_dir = $ENV{PWD};

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    if (!defined($ENV{NOVAS_HOME})) {
	print "$prg: NOVAS_HOME not defined, Debussy will not be used.\n";
        push (@{$opt{icv_build_args}}, "+define+FSDB_OFF");
    }
    push (@{$opt{icv_build_args}}, "+define+NO_VERA") if (!$opt{vera_build}) ;
    push (@{$opt{icv_build_args}}, "+define+TCL_TAP_TEST") if ($opt{tcl_tap}) ;
    push (@{$opt{icv_build_args}}, "-f flist") ;
    push (@{$opt{icv_build_args}}, "-s cmp_top") ;
#    push (@{$opt{icv_build_args}}, "-I $ENV{DV_ROOT}/design/include") ;
#    push (@{$opt{icv_build_args}}, "-I $ENV{DV_ROOT}/design/chipset/include") ;
    push (@{$opt{icv_build_args}}, "-g 2001") ;

    # copy generic sim_build_args to ncv_build_args

    foreach my $x (@{$opt{sim_build_args}})
    {
        push (@{$opt{icv_build_args}}, $x);
    }

    # build the model
    print "$prg: Building rtl model\n" ;

    my $build_cmd = "iverilog " ;
    $build_cmd .= " ";

    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{icv_build_args}})
    {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
        $build_cmd .= "$x " ;
      }
    }

    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    print "$prg: $build_cmd\n";

    if (! $opt{dryrun})
    {
      system ($build_cmd) ;
      die ("DIE. failed building model") if ($?) ;
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
}
################################################################################
# Other simulator build
################################################################################

sub other_sim_build
{
    my $cur_dir = $ENV{PWD};

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    if (!defined($ENV{NOVAS_HOME})) {
	print "$prg: NOVAS_HOME not defined, Debussy will not be used.\n";
        push (@{$opt{sim_build_args}}, "+define+FSDB_OFF");
    }
    push (@{$opt{sim_build_args}}, "+define+NO_VERA") if (!$opt{vera_build}) ;
    push (@{$opt{sim_build_args}}, "+define+TCL_TAP_TEST") if ($opt{tcl_tap}) ;
    push (@{$opt{sim_build_args}}, "-f flist") ;

    # build the model
    print "$prg: Building rtl model\n" ;

    if (($opt{other_sim_build_cmd}) eq "") {
	die ("DIE. other_sim_build_cmd not defined");
    }

    my $build_cmd = $opt{other_sim_build_cmd};
    $build_cmd .= " ";

    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{sim_build_args}})
    {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
        $build_cmd .= "$x " ;
      }
    }

    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    print "$prg: $build_cmd\n";

    if (! $opt{dryrun})
    {
      system ($build_cmd) ;
      die ("DIE. failed building model") if ($?) ;
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
}
################################################################################
# compile zeroIn
################################################################################

sub zeroIn_build
{
    my $cur_dir = $ENV{PWD};

    print "$prg: 0in_start ",`date` ;

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path\n") ;

    my $zeroIn_dir = "zeroInDir";
    # go to the zeroIn dir
    system ("mkdir -p $zeroIn_dir");

    chdir $zeroIn_dir or die ("DIE. Can't cd to $zeroIn_dir\n") ;

    # Debug args if any ..
    my $zin_dbg .= join (" ", @{$opt {zeroIn_dbg_args}}) ;

    # compile zeroIn
    print "$prg: compiling zeroIn\n" ;

    # zeroIn compile command
    my $zeroIn_build_cmd ;
    $zeroIn_build_cmd = "0in $zin_dbg -cmd ccl -f $model_path/flist " if ($opt{zeroIn_build}) ;
    $zeroIn_build_cmd = "0in $zin_dbg -cmd csl -f $model_path/flist " if ($opt{zeroInSearch_build}) ;
    $zeroIn_build_cmd = "0in $zin_dbg -cmd ckl -f $model_path/flist " if ($opt{zeroIn_checklist}) ;
    $zeroIn_build_cmd .= join (" ", @{$opt {zeroIn_build_args}}) ;

    print "$prg: $zeroIn_build_cmd\n";
    if (! $opt {dryrun})
    {
      # produce 0in_sim.arg file
      system ($zeroIn_build_cmd) ;
      die ("DIE. failed compiling zeroIn\n") if ($?) ;
    }

    print "$prg: 0in_stop ",`date` ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

################################################################################
# run vlint
################################################################################

sub vlint_run
{
  my $cur_dir = $ENV{PWD};

  # Keeping vlint output in current directory

  system ("mkdir -p vlintDir") ;

  # run vlint
  print "$prg: Running vlint\n" ;
  my $vlint_cmd = "x2e ";

  push (@{$opt {vlint_args}}, "-f $model_path/flist") ;
  push (@{$opt {vlint_args}}, "-od vlintDir ") ;

  # always last
  die "DIE. no top level module specified for vlint" if ($opt{vlint_top} eq "") ;
  push (@{$opt {vlint_args}}, $opt{vlint_top}) ;

  $vlint_cmd .= join (" ", @{$opt {vlint_args}}) ;

  print "$prg: $vlint_cmd\n";

  if (! $opt {dryrun})
  {
    system ($vlint_cmd) ; my $status = $? ;
    if ($opt{illust_run}) {
        my $illust_cmd = "illust ";
        $illust_cmd .= join(" ", @{$opt {illust_args}}) ;
        chdir ("vlintDir");
        if (-e "$opt{vlint_top}.vlint.db") {
            `cp -f $opt{vlint_top}.vlint.db vlint.db` ;
        }
        print "$prg: $illust_cmd\n";
        system ($illust_cmd) ; my $status = $? ;
        chdir ($cur_dir);
        die ("DIE. status=$status: failed running illust \n\t(see vlintDir/{di.log,errors.vlint})\n ")
            if ($status == 1) ;
    }
    die ("DIE. failed running vlint") if ($status == 1) ;
  }
}

################################################################################
# run verix
################################################################################

sub verix_run
{
  my $cur_dir = $ENV{PWD};

  # Keeping Verix output in current directory

  system ("mkdir -p verixDir") ;
  chdir("verixDir");

  # Run verix
  print "$prg: Running verix flow\n" ;

  die "DIE. no top level module specified for verix" if ($opt{verix_top} eq "") ;

  # Copy the template
  system ("cp $dv_root/verif/env/config/$opt{verix_top}.verix.tmplt verix.tmplt");
  system("chmod +w verix.tmplt");
  die "DIE. could not copy verix template $dv_root/verif/env/config/$opt{verix_top}.verix.tmplt, $!" if ($?);

  # Create the vlist using the libs specified
  open (VLIST, ">$opt{verix_top}.vlist");
  die "DIE. could not create $opt{verix_top}.vlist, $!" if ($?);

  print VLIST "$model_path/config.v\n";

  # Pick up libs and defines from vcs_build args too ..

  foreach (@{$opt{verix_libs}},@{$opt{vcs_build_args}}) {
    s/"//go;
    next if (!/(^\+define)|(^-f)|(^-v)|(^-y)/);
    print VLIST "$_\n";
  }
  close VLIST;

  # Run the setup
  my $verix_cmd = "verix_flow -setup $opt{verix_top} ";

  print "$prg: $verix_cmd \n";

  if (! $opt {dryrun})
  {
    system ("$verix_cmd") ;
    die ("DIE. failed running verix") if ($?) ;
  }

  # Run the run script
  $verix_cmd = "verix_flow -run $opt{verix_top} ";

  print "$prg: $verix_cmd \n";

  if (! $opt {dryrun})
  {
    system ("$verix_cmd") ;
    die ("DIE. failed running verix") if ($?) ;
  }
  chdir($cur_dir);
}

################################################################################
# run vcs
################################################################################

sub vcs_run
{
    # first clean up the diag area
    `rm -rf sim.log *.rpt raw_coverage coverage`;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # verify that a model was compiled
    die ("DIE. simv not found in $model_path") if ($opt{vcs_run} and ! -e "$model_path/simv") ;

    # create the raw coverage directory
    `mkdir raw_coverage` ;
    die  ("DIE. Could not create raw_coverage directory") if ($?) ;

    # copy spd files into the run area
    #`cp -f $dv_root/verif/model/verilog/i2c/data/spd_single_dimm.data .` ;
    #die ("DIE. could not copy spd_single_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_single_dimm.data` ;
    #die ("DIE. could not change permission on spd_single_dimm.data") if ($?) ;

    #`cp $dv_root/verif/model/verilog/i2c/data/spd_stack_dimm.data .` ;
    #die ("DIE. could not copy spd_stack_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_stack_dimm.data` ;
    #die ("DIE. could not change permission on spd_stack_dimm.data") if ($?) ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0)
      {
	foreach my $trap (@good_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap_list{$pa} = 1 ;
  	}

        foreach my $x (sort (keys (%good_trap_list)))
        {
          push (@good_trap, $x) ;
        }

        if ($#good_trap == 0) { $good_trap = "+good_trap=" . $good_trap[0] ; }
        else { $good_trap = "+good_trap=" . join (':', @good_trap) ; }
      }

      if ($#bad_trap_list >= 0)
      {
	foreach my $trap (@bad_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
	  $bad_trap_list{$pa} = $pa;
	}

        foreach my $x (sort (keys (%bad_trap_list)))
        {
          push (@bad_trap, $x) ;
        }

        if ($#bad_trap == 0) { $bad_trap = "+bad_trap=" . $bad_trap[0] ; }
        else { $bad_trap = "+bad_trap=" . join (':', @bad_trap) ; }
      }
    }

    # copy the project file over to the run area

    if ((! $opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb})
    {
      `cp $model_path/vera/$opt{model}_top.proj .` ;
      die ("DIE. could not copy .proj file to $ENV{PWD}") if ($?) ;
      `chmod +w $opt{model}_top.proj`;
      die ("DIE. could not change permission of .proj file") if ($?) ;

      # append diag.vro after the fact
      if ($opt{vera_diag_name} ne "")
      {
        push (@{$opt{sim_run_args}}, "+vera_diag_path=$opt{vera_diag_path}") ;
        `ls *.vro >> $opt{model}_top.proj` ;
        die ("DIE. could not append *.vro to vera project file") if ($?) ;
      }
    }

    # add in switches for signal dumping

    if ($opt{vcd})
    {
      my $vcdfile = "";
      if ($opt{vcdfile} eq "")
      {
        $vcdfile = "$opt{tmp_dir}/sim.vcd.$$" ;
      } elsif ( $opt{vcdfile} =~ /^\// )
      {	## full path name specified -- use file name as is
        $vcdfile = $opt{vcdfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
        $vcdfile = "$opt{tmp_dir}/$opt{vcdfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+vcd") ;
      push (@{$opt{sim_run_args}}, "-vcd $vcdfile") ;
      push (@{$opt{sim_run_args}}, "+vcs+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+vcs+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
    }
    else
    {
      push (@{$opt{sim_run_args}}, "+vcs+dumpvarsoff") ;
    }

    if ($opt{debussy})
    {
      my $fsdbfile = "";
      if ($opt{fsdbfile} eq "")
      {
        $fsdbfile = "$opt{tmp_dir}/sim.fsdb.$$" ;
      } elsif ( $opt{fsdbfile} =~ /^\// )
      {	## full path name specified -- use file name as is
	$fsdbfile = $opt{fsdbfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
	$fsdbfile = "$opt{tmp_dir}/$opt{fsdbfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+debussy") ;
      push (@{$opt{sim_run_args}}, "+fsdbfile=$fsdbfile") ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdbDumplimit=$opt{fsdbDumplimit}") if ($opt{fsdbDumplimit} ne "") ;
    }

    # convert -args to +args
    push (@{$opt{sim_run_args}}, "+use_sas_tasks") if ($opt{sas}) ;
    push (@{$opt{sim_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+stub_mask=$opt{stub_mask}") if ($opt{stub_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{sim_run_args}}, "+wait_cycle_to_kill=$opt{wait_cycle_to_kill}") if ($opt{wait_cycle_to_kill} > 0) ;
    push (@{$opt{sim_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;

    push (@{$opt{sim_run_args}}, "+initreg+$opt{tg_seed}") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{sim_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{sim_run_args}}, "+vcs+finish+".bigtime2plus($opt{vcs_finish})) if ($opt{vcs_finish}) ;
    push (@{$opt{sim_run_args}},  $good_trap) if ($good_trap ne "") ;
    push (@{$opt{sim_run_args}},  $bad_trap) if ($bad_trap ne "") ;
    push (@{$opt{sim_run_args}}, "+ntb_load=$model_path/vera/libtb.so") if ($opt{vera_run} and $opt{ntb_lib}) ;
    push (@{$opt{sim_run_args}}, "+vera_pload=$opt{model}_top.proj") if ((!$opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{sim_run_args}}, "+vera_mload=veralist.vrl") if ($opt{dftvert} and !$opt{vcs_use_ntb}) ;
    # push (@{$opt{sim_run_args}}, "-l sim.log") ;
    # push (@{$opt{sim_run_args}}, "+vcs+nostdout") if ($opt{regress});
    push (@{$opt{sim_run_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}); #$ENV{PWD}
    push (@{$opt{sim_run_args}}, "+efuse_data_file=efuse.img") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_diag_name=$opt{vera_diag_name}") if ($opt{vera_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+sjm_diag_name=$opt{sjm_diag_name}") if ($opt{sjm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tap_diag_name=$opt{tap_diag_name}") if ($opt{tap_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tpt_diag_name=$opt{tpt_diag_name}") if ($opt{tpt_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+pci_diag_name=$opt{pci_diag_name}") if ($opt{pci_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+efuse_image_name=$opt{efuse_image_name}") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_config_name=$opt{vera_config_name}") if ($opt{vera_config_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{sim_run_args}}, "+ctu_mon_off") if ($opt{tcl_tap}) ;
    push (@{$opt{sim_run_args}}, "+dv_root=$dv_root") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/A-Z/a-z/ ;
      push (@{$opt{sim_run_args}}, "+$obj") ;
    }

    # run the command

    my $cmd = "" ;
    $cmd .= "collect " if ($opt{vcs_prof}) ;
    $cmd .= "$model_path/simv " ;
    $cmd .= join (" ", @{$opt{sim_run_args}}) ;

    print "$prg: $cmd\n";

    $ENV{FSDB_ENV_DUMP_SEQ_NUM} = 1 if ($opt{fsdb_glitch}) ; # turn on sequence dump
    $ENV{FSDB_ENV_MAX_GLITCH_NUM} = 0 if ($opt{fsdb_glitch}) ; # turn on glitch dump

    # figure out the location of vcs from variable
    if (!defined($ENV{VCS_HOME})) { die ("DIE. VCS_HOME not defined.") }
    print "$prg: VCS_HOME is $ENV{VCS_HOME}\n";

    # figure out the location of vera from variable
    if (defined($ENV{VERA_HOME})) {
        print "$prg: VERA_HOME is $ENV{VERA_HOME}\n";
    }

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    if($proj_vars{has_denali}) {
      if (!defined($ENV{DENALI})) { die ("DIE. DENALI not defined.") }
      print "$prg: DENALI is $ENV{DENALI}\n";
    }

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    if (!$opt{dryrun})
    {
      if ($opt{use_oolm})
      {
        $vcs_license_id = `license_reserve vcs` if ($opt{vcs_run}) ;
        die ("DIE. could not get an OOLM vcs license") if ($?) ;
        $vera_license_id = `license_reserve vera` if ($opt{vera_run}) ;
        die ("DIE. could not get an OOLM vera license") if ($?) ;
      }

      $main::sim_start  = `date` ;
      print "$prg: sim_start $main::sim_start" ;

      if ($opt{regress})
      {
        system ("$cmd > sim.log 2>&1") ;
        die ("DIE. simv exited with an error") if ($?) ;
      }
      elsif ($opt{vcs_use_cli})
      {
        system ($cmd) ;
      }
      else
      {
        my $waitstatus = call_program ($cmd, "sim.log") ;
        die ("DIE. simv exited with an error") if ($waitstatus) ;
      }
      $main::sim_stop = `date` ;
      print "$prg: sim_stop $main::sim_stop" ;

      open (PERFLOG, "> sim.perf.log") ;
      print PERFLOG "$prg: sim_start $main::sim_start" ;
      print PERFLOG "$prg: sim_stop $main::sim_stop" ;
      close (PERFLOG) ;
    }

    # kill sas no matter what

    if ($sas_pid != 0)
    {
      kill -9, $sas_pid ;
    }

    # kill tcl no matter what
    if ($tcl_pid != 0)
    {
      kill -9, $tcl_pid ;
    }

    # copy over debussy dump

    if (-f "$opt{tmp_dir}/$opt{fsdbfile}.$$")
    {
      `mv $opt{tmp_dir}/$opt{fsdbfile}.$$ $opt{fsdbfile}`;
      die ("DIE. unable to move fsdb file over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd $opt{fsdbfile} -o ${opt{fsdbfile}}.vcd`  ;
         die ("DIE. unable to convert fsdb file to vcd\n") if ($?) ;
      }
    }

    if (-f "$opt{tmp_dir}/sim.fsdb.$$")
    {
      `mv $opt{tmp_dir}/sim.fsdb.$$ sim.fsdb`;
      die ("DIE. unable to move sim.fsdb over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd sim.fsdb -o sim.vcd` ;
         die ("DIE. unable to convert sim.fsdb file to vcd\n") if ($?) ;
      }
    }

    # copy over vcd dump

    if (-f "$opt{tmp_dir}/$opt{vcdfile}")
    {
      `mv $opt{tmp_dir}/$opt{vcdfile} sim.vcd`;
      die ("DIE. unable to move sim.vcd over\n") if ($?) ;
    }
}

################################################################################
# run ncverilog
################################################################################

sub ncv_run
{
    # first clean up the diag area
    `rm -rf sim.log *.rpt raw_coverage coverage`;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # verify that a model was compiled
    die ("DIE. INCA_libs not found in $model_path") if ($opt{ncv_run} and ! -e "$model_path/INCA_libs") ;

    # create the raw coverage directory
    `mkdir raw_coverage` ;
    die  ("DIE. Could not create raw_coverage directory") if ($?) ;

    # copy spd files into the run area
    #`cp -f $dv_root/verif/model/verilog/i2c/data/spd_single_dimm.data .` ;
    #die ("DIE. could not copy spd_single_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_single_dimm.data` ;
    #die ("DIE. could not change permission on spd_single_dimm.data") if ($?) ;

    #`cp $dv_root/verif/model/verilog/i2c/data/spd_stack_dimm.data .` ;
    #die ("DIE. could not copy spd_stack_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_stack_dimm.data` ;
    #die ("DIE. could not change permission on spd_stack_dimm.data") if ($?) ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0)
      {
	foreach my $trap (@good_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap_list{$pa} = 1 ;
  	}

        foreach my $x (sort (keys (%good_trap_list)))
        {
          push (@good_trap, $x) ;
        }

        if ($#good_trap == 0) { $good_trap = "+good_trap=" . $good_trap[0] ; }
        else { $good_trap = "+good_trap=" . join (':', @good_trap) ; }
      }

      if ($#bad_trap_list >= 0)
      {
	foreach my $trap (@bad_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
	  $bad_trap_list{$pa} = $pa;
	}

        foreach my $x (sort (keys (%bad_trap_list)))
        {
          push (@bad_trap, $x) ;
        }

        if ($#bad_trap == 0) { $bad_trap = "+bad_trap=" . $bad_trap[0] ; }
        else { $bad_trap = "+bad_trap=" . join (':', @bad_trap) ; }
      }
    }

    # copy the project file over to the run area

    if ((! $opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb})
    {
      `cp $model_path/vera/$opt{model}_top.proj .` ;
      die ("DIE. could not copy .proj file to $ENV{PWD}") if ($?) ;
      `chmod +w $opt{model}_top.proj`;
      die ("DIE. could not change permission of .proj file") if ($?) ;

      # append diag.vro after the fact
      if ($opt{vera_diag_name} ne "")
      {
        push (@{$opt{sim_run_args}}, "+vera_diag_path=$opt{vera_diag_path}") ;
        `ls *.vro >> $opt{model}_top.proj` ;
        die ("DIE. could not append *.vro to vera project file") if ($?) ;
      }
    }

    # add in switches for signal dumping

    my $ncvcommand = "\"run\"";

    if ($opt{vcd})
    {
      my $vcdfile = "";
      if ($opt{vcdfile} eq "")
      {
        $vcdfile = "$opt{tmp_dir}/sim.vcd.$$" ;
      } elsif ( $opt{vcdfile} =~ /^\// )
      {	## full path name specified -- use file name as is
        $vcdfile = $opt{vcdfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
        $vcdfile = "$opt{tmp_dir}/$opt{vcdfile}.$$" ;
      }

      $ncvcommand = "\"database -open \"myvcd\" -vcd -into \"$vcdfile\"; ";
      $ncvcommand .= "probe -create -vcd -database myvcd cmp_top -all -depth all; ";
      $ncvcommand .= "run\""
      #push (@{$opt{sim_run_args}}, "+vcd") ;
      #push (@{$opt{sim_run_args}}, "-vcd $vcdfile") ;
      #push (@{$opt{sim_run_args}}, "+vcs+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      #push (@{$opt{sim_run_args}}, "+vcs+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
    }
    else
    {
      push (@{$opt{sim_run_args}}, "+vcs+dumpvarsoff") ;
    }

    if ($opt{debussy})
    {
      my $fsdbfile = "";
      if ($opt{fsdbfile} eq "")
      {
        $fsdbfile = "$opt{tmp_dir}/sim.fsdb.$$" ;
      } elsif ( $opt{fsdbfile} =~ /^\// )
      {	## full path name specified -- use file name as is
	$fsdbfile = $opt{fsdbfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
	$fsdbfile = "$opt{tmp_dir}/$opt{fsdbfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+debussy") ;
      push (@{$opt{sim_run_args}}, "+fsdbfile=$fsdbfile") ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdbDumplimit=$opt{fsdbDumplimit}") if ($opt{fsdbDumplimit} ne "") ;
    }

    # convert -args to +args
    push (@{$opt{sim_run_args}}, "+use_sas_tasks") if ($opt{sas}) ;
    push (@{$opt{sim_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+stub_mask=$opt{stub_mask}") if ($opt{stub_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{sim_run_args}}, "+wait_cycle_to_kill=$opt{wait_cycle_to_kill}") if ($opt{wait_cycle_to_kill} > 0) ;
    push (@{$opt{sim_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;

    push (@{$opt{sim_run_args}}, "+initreg+$opt{tg_seed}") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{sim_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{sim_run_args}}, "+vcs+finish+".bigtime2plus($opt{vcs_finish})) if ($opt{vcs_finish}) ;
    push (@{$opt{sim_run_args}},  $good_trap) if ($good_trap ne "") ;
    push (@{$opt{sim_run_args}},  $bad_trap) if ($bad_trap ne "") ;
    push (@{$opt{sim_run_args}}, "+ntb_load=$model_path/vera/libtb.so") if ($opt{vera_run} and $opt{ntb_lib}) ;
    push (@{$opt{sim_run_args}}, "+vera_pload=$opt{model}_top.proj") if ((!$opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{sim_run_args}}, "+vera_mload=veralist.vrl") if ($opt{dftvert} and !$opt{vcs_use_ntb}) ;
    # push (@{$opt{sim_run_args}}, "-l ncverilog.log") ;
    push (@{$opt{sim_run_args}}, "+nolog") ;
    # push (@{$opt{sim_run_args}}, "+vcs+nostdout") if ($opt{regress});
    push (@{$opt{sim_run_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}); #$ENV{PWD}
    push (@{$opt{sim_run_args}}, "+efuse_data_file=efuse.img") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_diag_name=$opt{vera_diag_name}") if ($opt{vera_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+sjm_diag_name=$opt{sjm_diag_name}") if ($opt{sjm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tap_diag_name=$opt{tap_diag_name}") if ($opt{tap_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tpt_diag_name=$opt{tpt_diag_name}") if ($opt{tpt_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+pci_diag_name=$opt{pci_diag_name}") if ($opt{pci_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+efuse_image_name=$opt{efuse_image_name}") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_config_name=$opt{vera_config_name}") if ($opt{vera_config_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{sim_run_args}}, "+ctu_mon_off") if ($opt{tcl_tap}) ;
    push (@{$opt{sim_run_args}}, "+dv_root=$dv_root") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/A-Z/a-z/ ;
      push (@{$opt{sim_run_args}}, "+$obj") ;
    }

    # run the command

    my $cmd = "" ;
    my $os_cpu = `uname -s`;
    $os_cpu =~ s/\n//g;
    if ($os_cpu eq "SunOS") {
      $os_cpu .= "/";
      $os_cpu .= `uname -p`;
    } else {
      $os_cpu .= "/";
      $os_cpu .= `uname -m`;
    }
    $os_cpu =~ s/\n//g;
    #$cmd .= "collect " if ($opt{vcs_prof}) ;
    my $ld_lib_path = $ENV{LD_LIBRARY_PATH};
    $ld_lib_path .= ":$ENV{DV_ROOT}/tools/";
    $ld_lib_path .= $os_cpu;
    $ld_lib_path .= "/lib";
    $ld_lib_path .= ":$ENV{NCV_HOME}/tools/lib/64bit";
    $cmd .= "#!/bin/csh -f\nsetenv LD_LIBRARY_PATH ";
    $cmd .= $ld_lib_path;
    $cmd .= "\n" ;
    $cmd .= "echo ";
    $cmd .= $ncvcommand;
    $cmd .= " | ncverilog " ;
    $cmd .= "+nclibdirname+$model_path/INCA_libs " ;
    $cmd .= "-r worklib.$opt{sys}:v " ;
    $cmd .= "+name+$opt{sys} " ;
    $cmd .= "+ncsimexe+$ENV{DV_ROOT}/tools/";
    $cmd .= $os_cpu;
    $cmd .= "/ncsim " ;
    $cmd .= "+ncelabexe+$ENV{DV_ROOT}/tools/";
    $cmd .= $os_cpu;
    $cmd .= "/ncelab -s " ;
    $cmd .= join (" ", @{$opt{sim_run_args}}) ;

    print "$prg: $cmd\n";
    open (NCVCMD, "> ncv_cmd") ;
    print NCVCMD "$cmd\n" ;
    close (NCVCMD) ;
    `chmod +x ncv_cmd`;

    $cmd = "ncv_cmd";

    $ENV{LD_LIBRARY_PATH} = $ld_lib_path;
    print "$prg: LD_LIBRARY_PATH is $ENV{LD_LIBRARY_PATH}\n";

    $ENV{FSDB_ENV_DUMP_SEQ_NUM} = 1 if ($opt{fsdb_glitch}) ; # turn on sequence dump
    $ENV{FSDB_ENV_MAX_GLITCH_NUM} = 0 if ($opt{fsdb_glitch}) ; # turn on glitch dump

    # figure out the location of vcs from variable
    if (!defined($ENV{NCV_HOME})) { die ("DIE. NCV_HOME not defined.") }
    print "$prg: NCV_HOME is $ENV{NCV_HOME}\n";

    # figure out the location of vera from variable
    if (defined($ENV{VERA_HOME})) {
        print "$prg: VERA_HOME is $ENV{VERA_HOME}\n";
    }

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    if($proj_vars{has_denali}) {
      if (!defined($ENV{DENALI})) { die ("DIE. DENALI not defined.") }
      print "$prg: DENALI is $ENV{DENALI}\n";
    }

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    if (!$opt{dryrun})
    {

      $main::sim_start  = `date` ;
      print "$prg: sim_start $main::sim_start" ;

      if ($opt{regress})
      {
        system ("$cmd > sim.log 2>&1") ;
        die ("DIE. ncverilog exited with an error") if ($?) ;
      }
      elsif ($opt{ncv_use_cli})
      {
        system ($cmd) ;
      }
      else
      {
        my $waitstatus = call_program ($cmd, "sim.log") ;
        die ("DIE. ncverilog exited with an error") if ($waitstatus) ;
      }
      $main::sim_stop = `date` ;
      print "$prg: sim_stop $main::sim_stop" ;

      open (PERFLOG, "> sim.perf.log") ;
      print PERFLOG "$prg: sim_start $main::sim_start" ;
      print PERFLOG "$prg: sim_stop $main::sim_stop" ;
      close (PERFLOG) ;
    }

    # kill sas no matter what

    if ($sas_pid != 0)
    {
      kill -9, $sas_pid ;
    }

    # kill tcl no matter what
    if ($tcl_pid != 0)
    {
      kill -9, $tcl_pid ;
    }

    # copy over debussy dump

    if (-f "$opt{tmp_dir}/$opt{fsdbfile}.$$")
    {
      `mv $opt{tmp_dir}/$opt{fsdbfile}.$$ $opt{fsdbfile}`;
      die ("DIE. unable to move fsdb file over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd $opt{fsdbfile} -o ${opt{fsdbfile}}.vcd`  ;
         die ("DIE. unable to convert fsdb file to vcd\n") if ($?) ;
      }
    }

    if (-f "$opt{tmp_dir}/sim.fsdb.$$")
    {
      `mv $opt{tmp_dir}/sim.fsdb.$$ sim.fsdb`;
      die ("DIE. unable to move sim.fsdb over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd sim.fsdb -o sim.vcd` ;
         die ("DIE. unable to convert sim.fsdb file to vcd\n") if ($?) ;
      }
    }

    # copy over vcd dump

    if (-f "$opt{tmp_dir}/$opt{vcdfile}")
    {
      `mv $opt{tmp_dir}/$opt{vcdfile} sim.vcd`;
      die ("DIE. unable to move sim.vcd over\n") if ($?) ;
    }
}

################################################################################
# run icarus simulator
################################################################################

sub icv_run
{
    # first clean up the diag area
    `rm -rf sim.log *.rpt raw_coverage coverage`;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # verify that a model was compiled
    die ("DIE. a.out not found in $model_path") if ($opt{icv_run} and ! -e "$model_path/a.out") ;

    # create the raw coverage directory
    `mkdir raw_coverage` ;
    die  ("DIE. Could not create raw_coverage directory") if ($?) ;

    # copy spd files into the run area
    #`cp -f $dv_root/verif/model/verilog/i2c/data/spd_single_dimm.data .` ;
    #die ("DIE. could not copy spd_single_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_single_dimm.data` ;
    #die ("DIE. could not change permission on spd_single_dimm.data") if ($?) ;

    #`cp $dv_root/verif/model/verilog/i2c/data/spd_stack_dimm.data .` ;
    #die ("DIE. could not copy spd_stack_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_stack_dimm.data` ;
    #die ("DIE. could not change permission on spd_stack_dimm.data") if ($?) ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0)
      {
	foreach my $trap (@good_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap_list{$pa} = 1 ;
  	}

        foreach my $x (sort (keys (%good_trap_list)))
        {
          push (@good_trap, $x) ;
        }

        if ($#good_trap == 0) { $good_trap = "+good_trap=" . $good_trap[0] ; }
        else { $good_trap = "+good_trap=" . join (':', @good_trap) ; }
      }

      if ($#bad_trap_list >= 0)
      {
	foreach my $trap (@bad_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
	  $bad_trap_list{$pa} = $pa;
	}

        foreach my $x (sort (keys (%bad_trap_list)))
        {
          push (@bad_trap, $x) ;
        }

        if ($#bad_trap == 0) { $bad_trap = "+bad_trap=" . $bad_trap[0] ; }
        else { $bad_trap = "+bad_trap=" . join (':', @bad_trap) ; }
      }
    }

    # copy the project file over to the run area

    if ((! $opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb})
    {
      `cp $model_path/vera/$opt{model}_top.proj .` ;
      die ("DIE. could not copy .proj file to $ENV{PWD}") if ($?) ;
      `chmod +w $opt{model}_top.proj`;
      die ("DIE. could not change permission of .proj file") if ($?) ;

      # append diag.vro after the fact
      if ($opt{vera_diag_name} ne "")
      {
        push (@{$opt{sim_run_args}}, "+vera_diag_path=$opt{vera_diag_path}") ;
        `ls *.vro >> $opt{model}_top.proj` ;
        die ("DIE. could not append *.vro to vera project file") if ($?) ;
      }
    }

    # add in switches for signal dumping

    if ($opt{vcd})
    {
      my $vcdfile = "";
      if ($opt{vcdfile} eq "")
      {
        $vcdfile = "$opt{tmp_dir}/sim.vcd.$$" ;
      } elsif ( $opt{vcdfile} =~ /^\// )
      {	## full path name specified -- use file name as is
        $vcdfile = $opt{vcdfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
        $vcdfile = "$opt{tmp_dir}/$opt{vcdfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+vcd") ;
      push (@{$opt{sim_run_args}}, "-vcd $vcdfile") ;
      push (@{$opt{sim_run_args}}, "+vcs+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+vcs+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
    }
    else
    {
      push (@{$opt{sim_run_args}}, "+vcs+dumpvarsoff") ;
    }

    if ($opt{debussy})
    {
      my $fsdbfile = "";
      if ($opt{fsdbfile} eq "")
      {
        $fsdbfile = "$opt{tmp_dir}/sim.fsdb.$$" ;
      } elsif ( $opt{fsdbfile} =~ /^\// )
      {	## full path name specified -- use file name as is
	$fsdbfile = $opt{fsdbfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
	$fsdbfile = "$opt{tmp_dir}/$opt{fsdbfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+debussy") ;
      push (@{$opt{sim_run_args}}, "+fsdbfile=$fsdbfile") ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdbDumplimit=$opt{fsdbDumplimit}") if ($opt{fsdbDumplimit} ne "") ;
    }

    # convert -args to +args
    push (@{$opt{sim_run_args}}, "+use_sas_tasks") if ($opt{sas}) ;
    push (@{$opt{sim_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+stub_mask=$opt{stub_mask}") if ($opt{stub_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{sim_run_args}}, "+wait_cycle_to_kill=$opt{wait_cycle_to_kill}") if ($opt{wait_cycle_to_kill} > 0) ;
    push (@{$opt{sim_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;

    push (@{$opt{sim_run_args}}, "+initreg+$opt{tg_seed}") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{sim_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{sim_run_args}}, "+vcs+finish+".bigtime2plus($opt{vcs_finish})) if ($opt{vcs_finish}) ;
    push (@{$opt{sim_run_args}},  $good_trap) if ($good_trap ne "") ;
    push (@{$opt{sim_run_args}},  $bad_trap) if ($bad_trap ne "") ;
    push (@{$opt{sim_run_args}}, "+ntb_load=$model_path/vera/libtb.so") if ($opt{vera_run} and $opt{ntb_lib}) ;
    push (@{$opt{sim_run_args}}, "+vera_pload=$opt{model}_top.proj") if ((!$opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{sim_run_args}}, "+vera_mload=veralist.vrl") if ($opt{dftvert} and !$opt{vcs_use_ntb}) ;
    # push (@{$opt{sim_run_args}}, "+vcs+nostdout") if ($opt{regress});
    push (@{$opt{sim_run_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}); #$ENV{PWD}
    push (@{$opt{sim_run_args}}, "+efuse_data_file=efuse.img") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_diag_name=$opt{vera_diag_name}") if ($opt{vera_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+sjm_diag_name=$opt{sjm_diag_name}") if ($opt{sjm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tap_diag_name=$opt{tap_diag_name}") if ($opt{tap_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tpt_diag_name=$opt{tpt_diag_name}") if ($opt{tpt_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+pci_diag_name=$opt{pci_diag_name}") if ($opt{pci_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+efuse_image_name=$opt{efuse_image_name}") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_config_name=$opt{vera_config_name}") if ($opt{vera_config_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{sim_run_args}}, "+ctu_mon_off") if ($opt{tcl_tap}) ;
    push (@{$opt{sim_run_args}}, "+dv_root=$dv_root") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/A-Z/a-z/ ;
      push (@{$opt{sim_run_args}}, "+$obj") ;
    }

    my $os_cpu = `uname -s`;
    $os_cpu =~ s/\n//g;
    if ($os_cpu eq "SunOS") {
      $os_cpu .= "/";
      $os_cpu .= `uname -p`;
    } else {
      $os_cpu .= "/";
      $os_cpu .= `uname -m`;
    }
    $os_cpu =~ s/\n//g;
    # run the command

    my $cmd = "" ; # $opt{other_sim_run_cmd};
    $cmd .= "vvp " ;
    $cmd .= "-M$ENV{DV_ROOT}/tools/";
    $cmd .= $os_cpu;
    $cmd .= "/lib ";
    $cmd .= " -mveriuser $model_path/a.out " ;
    $cmd .= " " ;
    $cmd .= join (" ", @{$opt{sim_run_args}}) ;

    print "$prg: $cmd\n";

    print "$prg: LD_LIBRARY_PATH is $ENV{LD_LIBRARY_PATH}\n";

    $ENV{FSDB_ENV_DUMP_SEQ_NUM} = 1 if ($opt{fsdb_glitch}) ; # turn on sequence dump
    $ENV{FSDB_ENV_MAX_GLITCH_NUM} = 0 if ($opt{fsdb_glitch}) ; # turn on glitch dump

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    if (!$opt{dryrun})
    {

      $main::sim_start  = `date` ;
      print "$prg: sim_start $main::sim_start" ;

      if ($opt{regress})
      {
        system ("$cmd > sim.log 2>&1") ;
        die ("DIE. simulator exited with an error") if ($?) ;
      }
      else
      {
        my $waitstatus = call_program ($cmd, "sim.log") ;
        die ("DIE. simulator exited with an error") if ($waitstatus) ;
      }
      $main::sim_stop = `date` ;
      print "$prg: sim_stop $main::sim_stop" ;

      open (PERFLOG, "> sim.perf.log") ;
      print PERFLOG "$prg: sim_start $main::sim_start" ;
      print PERFLOG "$prg: sim_stop $main::sim_stop" ;
      close (PERFLOG) ;
    }

    # kill sas no matter what

    if ($sas_pid != 0)
    {
      kill -9, $sas_pid ;
    }

    # kill tcl no matter what
    if ($tcl_pid != 0)
    {
      kill -9, $tcl_pid ;
    }

    # copy over debussy dump

    if (-f "$opt{tmp_dir}/$opt{fsdbfile}.$$")
    {
      `mv $opt{tmp_dir}/$opt{fsdbfile}.$$ $opt{fsdbfile}`;
      die ("DIE. unable to move fsdb file over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd $opt{fsdbfile} -o ${opt{fsdbfile}}.vcd`  ;
         die ("DIE. unable to convert fsdb file to vcd\n") if ($?) ;
      }
    }

    if (-f "$opt{tmp_dir}/sim.fsdb.$$")
    {
      `mv $opt{tmp_dir}/sim.fsdb.$$ sim.fsdb`;
      die ("DIE. unable to move sim.fsdb over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd sim.fsdb -o sim.vcd` ;
         die ("DIE. unable to convert sim.fsdb file to vcd\n") if ($?) ;
      }
    }

    # copy over vcd dump

    if (-f "$opt{tmp_dir}/$opt{vcdfile}")
    {
      `mv $opt{tmp_dir}/$opt{vcdfile} sim.vcd`;
      die ("DIE. unable to move sim.vcd over\n") if ($?) ;
    }
}


################################################################################
# run other simulator
################################################################################

sub other_sim_run
{
    # first clean up the diag area
    `rm -rf sim.log *.rpt raw_coverage coverage`;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # create the raw coverage directory
    `mkdir raw_coverage` ;
    die  ("DIE. Could not create raw_coverage directory") if ($?) ;

    # copy spd files into the run area
    #`cp -f $dv_root/verif/model/verilog/i2c/data/spd_single_dimm.data .` ;
    #die ("DIE. could not copy spd_single_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_single_dimm.data` ;
    #die ("DIE. could not change permission on spd_single_dimm.data") if ($?) ;

    #`cp $dv_root/verif/model/verilog/i2c/data/spd_stack_dimm.data .` ;
    #die ("DIE. could not copy spd_stack_dimm.data to $ENV{PWD}") if ($?) ;
    #`chmod +w spd_stack_dimm.data` ;
    #die ("DIE. could not change permission on spd_stack_dimm.data") if ($?) ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0)
      {
	foreach my $trap (@good_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap_list{$pa} = 1 ;
  	}

        foreach my $x (sort (keys (%good_trap_list)))
        {
          push (@good_trap, $x) ;
        }

        if ($#good_trap == 0) { $good_trap = "+good_trap=" . $good_trap[0] ; }
        else { $good_trap = "+good_trap=" . join (':', @good_trap) ; }
      }

      if ($#bad_trap_list >= 0)
      {
	foreach my $trap (@bad_trap_list)
        {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
	  $bad_trap_list{$pa} = $pa;
	}

        foreach my $x (sort (keys (%bad_trap_list)))
        {
          push (@bad_trap, $x) ;
        }

        if ($#bad_trap == 0) { $bad_trap = "+bad_trap=" . $bad_trap[0] ; }
        else { $bad_trap = "+bad_trap=" . join (':', @bad_trap) ; }
      }
    }

    # copy the project file over to the run area

    if ((! $opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb})
    {
      `cp $model_path/vera/$opt{model}_top.proj .` ;
      die ("DIE. could not copy .proj file to $ENV{PWD}") if ($?) ;
      `chmod +w $opt{model}_top.proj`;
      die ("DIE. could not change permission of .proj file") if ($?) ;

      # append diag.vro after the fact
      if ($opt{vera_diag_name} ne "")
      {
        push (@{$opt{sim_run_args}}, "+vera_diag_path=$opt{vera_diag_path}") ;
        `ls *.vro >> $opt{model}_top.proj` ;
        die ("DIE. could not append *.vro to vera project file") if ($?) ;
      }
    }

    # add in switches for signal dumping

    if ($opt{vcd})
    {
      my $vcdfile = "";
      if ($opt{vcdfile} eq "")
      {
        $vcdfile = "$opt{tmp_dir}/sim.vcd.$$" ;
      } elsif ( $opt{vcdfile} =~ /^\// )
      {	## full path name specified -- use file name as is
        $vcdfile = $opt{vcdfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
        $vcdfile = "$opt{tmp_dir}/$opt{vcdfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+vcd") ;
      push (@{$opt{sim_run_args}}, "-vcd $vcdfile") ;
      push (@{$opt{sim_run_args}}, "+vcs+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+vcs+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
    }
    else
    {
      push (@{$opt{sim_run_args}}, "+vcs+dumpvarsoff") ;
    }

    if ($opt{debussy})
    {
      my $fsdbfile = "";
      if ($opt{fsdbfile} eq "")
      {
        $fsdbfile = "$opt{tmp_dir}/sim.fsdb.$$" ;
      } elsif ( $opt{fsdbfile} =~ /^\// )
      {	## full path name specified -- use file name as is
	$fsdbfile = $opt{fsdbfile} ;
      } else
      { ## relative path specified -- use name under tmp dir
	$fsdbfile = "$opt{tmp_dir}/$opt{fsdbfile}.$$" ;
      }

      push (@{$opt{sim_run_args}}, "+debussy") ;
      push (@{$opt{sim_run_args}}, "+fsdbfile=$fsdbfile") ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpon+".bigtime2plus($opt{start_dump})) if ($opt{start_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdb+dumpoff+".bigtime2plus($opt{stop_dump})) if ($opt{stop_dump} != 0) ;
      push (@{$opt{sim_run_args}}, "+fsdbDumplimit=$opt{fsdbDumplimit}") if ($opt{fsdbDumplimit} ne "") ;
    }

    # convert -args to +args
    push (@{$opt{sim_run_args}}, "+use_sas_tasks") if ($opt{sas}) ;
    push (@{$opt{sim_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+stub_mask=$opt{stub_mask}") if ($opt{stub_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{sim_run_args}}, "+wait_cycle_to_kill=$opt{wait_cycle_to_kill}") if ($opt{wait_cycle_to_kill} > 0) ;
    push (@{$opt{sim_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;

    push (@{$opt{sim_run_args}}, "+initreg+$opt{tg_seed}") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{sim_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{sim_run_args}}, "+vcs+finish+".bigtime2plus($opt{vcs_finish})) if ($opt{vcs_finish}) ;
    push (@{$opt{sim_run_args}},  $good_trap) if ($good_trap ne "") ;
    push (@{$opt{sim_run_args}},  $bad_trap) if ($bad_trap ne "") ;
    push (@{$opt{sim_run_args}}, "+ntb_load=$model_path/vera/libtb.so") if ($opt{vera_run} and $opt{ntb_lib}) ;
    push (@{$opt{sim_run_args}}, "+vera_pload=$opt{model}_top.proj") if ((!$opt{dftvert}) and $opt{vera_run} and !$opt{vcs_use_ntb}) ;
    push (@{$opt{sim_run_args}}, "+vera_mload=veralist.vrl") if ($opt{dftvert} and !$opt{vcs_use_ntb}) ;
    # push (@{$opt{sim_run_args}}, "+vcs+nostdout") if ($opt{regress});
    push (@{$opt{sim_run_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}); #$ENV{PWD}
    push (@{$opt{sim_run_args}}, "+efuse_data_file=efuse.img") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_diag_name=$opt{vera_diag_name}") if ($opt{vera_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+sjm_diag_name=$opt{sjm_diag_name}") if ($opt{sjm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tap_diag_name=$opt{tap_diag_name}") if ($opt{tap_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+tpt_diag_name=$opt{tpt_diag_name}") if ($opt{tpt_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+pci_diag_name=$opt{pci_diag_name}") if ($opt{pci_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+efuse_image_name=$opt{efuse_image_name}") if ($opt{efuse_image_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+vera_config_name=$opt{vera_config_name}") if ($opt{vera_config_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{sim_run_args}}, "+ctu_mon_off") if ($opt{tcl_tap}) ;
    push (@{$opt{sim_run_args}}, "+dv_root=$dv_root") ;

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/A-Z/a-z/ ;
      push (@{$opt{sim_run_args}}, "+$obj") ;
    }

    # run the command

    if (($opt{other_sim_run_cmd}) eq "") {
	die ("DIE. other_sim_run_cmd not defined");
    }
    my $cmd = $opt{other_sim_run_cmd};
    $cmd .= " " ;
    $cmd .= join (" ", @{$opt{sim_run_args}}) ;

    print "$prg: $cmd\n";

    print "$prg: LD_LIBRARY_PATH is $ENV{LD_LIBRARY_PATH}\n";

    $ENV{FSDB_ENV_DUMP_SEQ_NUM} = 1 if ($opt{fsdb_glitch}) ; # turn on sequence dump
    $ENV{FSDB_ENV_MAX_GLITCH_NUM} = 0 if ($opt{fsdb_glitch}) ; # turn on glitch dump

    $ENV{VERA_LIBDIR} = "$model_path/vera";
    print "$prg: setenv VERA_LIBDIR $ENV{VERA_LIBDIR}\n";

    print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";

    if (!$opt{dryrun})
    {

      $main::sim_start  = `date` ;
      print "$prg: sim_start $main::sim_start" ;

      if ($opt{regress})
      {
        system ("$cmd > sim.log 2>&1") ;
        die ("DIE. simulator exited with an error") if ($?) ;
      }
      else
      {
        my $waitstatus = call_program ($cmd, "sim.log") ;
        die ("DIE. simulator exited with an error") if ($waitstatus) ;
      }
      $main::sim_stop = `date` ;
      print "$prg: sim_stop $main::sim_stop" ;

      open (PERFLOG, "> sim.perf.log") ;
      print PERFLOG "$prg: sim_start $main::sim_start" ;
      print PERFLOG "$prg: sim_stop $main::sim_stop" ;
      close (PERFLOG) ;
    }

    # kill sas no matter what

    if ($sas_pid != 0)
    {
      kill -9, $sas_pid ;
    }

    # kill tcl no matter what
    if ($tcl_pid != 0)
    {
      kill -9, $tcl_pid ;
    }

    # copy over debussy dump

    if (-f "$opt{tmp_dir}/$opt{fsdbfile}.$$")
    {
      `mv $opt{tmp_dir}/$opt{fsdbfile}.$$ $opt{fsdbfile}`;
      die ("DIE. unable to move fsdb file over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd $opt{fsdbfile} -o ${opt{fsdbfile}}.vcd`  ;
         die ("DIE. unable to convert fsdb file to vcd\n") if ($?) ;
      }
    }

    if (-f "$opt{tmp_dir}/sim.fsdb.$$")
    {
      `mv $opt{tmp_dir}/sim.fsdb.$$ sim.fsdb`;
      die ("DIE. unable to move sim.fsdb over\n") if ($?) ;

      if ($opt{fsdb2vcd})
      {
        `fsdb2vcd sim.fsdb -o sim.vcd` ;
         die ("DIE. unable to convert sim.fsdb file to vcd\n") if ($?) ;
      }
    }

    # copy over vcd dump

    if (-f "$opt{tmp_dir}/$opt{vcdfile}")
    {
      `mv $opt{tmp_dir}/$opt{vcdfile} sim.vcd`;
      die ("DIE. unable to move sim.vcd over\n") if ($?) ;
    }
}


################################################################################
# run pre processing scripts
################################################################################

sub pre_process
{
  # Set the launch dir for pre-pocessors to use

  $ENV{SIMS_LAUNCH_DIR} = $launch_dir;

  foreach my $cmd (@{$opt{pre_process_cmd}})
  {
    print "$prg: $cmd\n";

    if (!$opt{dryrun})
    {
      $cmd =~ s/"(.*?)"/$1/ ;
      system ($cmd) ;
      print ("$prg: warning failed execution of $cmd") if ($?) ;
    }
  }
}

################################################################################
# run post processing scripts
################################################################################

sub post_process
{
    my $pass = 0 ;

    # run post processing script if needed

    # Set the launch dir for post-pocessors to use

    $ENV{SIMS_LAUNCH_DIR} = $launch_dir;

    foreach my $cmd (@{$opt{post_process_cmd}})
    {
      print "$prg: $cmd\n";

      if (!$opt{dryrun})
      {
        $cmd =~ s/"(.*?)"/$1/ ;
        system ($cmd) ;
        print ("$prg. warning failed execution of $cmd\n") if ($?) ;
      }
    }

    # determine pass fail status from sim.log

    ##
    ## @vcslog no longer contains the entire contents of sim.log since
    ## that file can be so large that the program runs out of memory.
    ## Instead, we use @simlog_extract to contain just those lines that are
    ## going to be parsed by Perl grep patterns later in this routine.
    ##
    my @simlog_extract ;
    if ( -f "sim.log" )
    {
	my $lines;
	my @lines;
	$lines	= `grep 'Time:' sim.log`;
	@lines	= split /\n/s, $lines;
	push @simlog_extract, @lines;

	$lines = `grep 'Core Clock Frequency' sim.log`;
	@lines = split /\n/s, $lines;
	push @simlog_extract, @lines;

	$lines = `grep 'regreport clock period:[ 	][ 	]*[0-9][0-9]*[ 	][ 	]*[fp]s' sim.log`;
	@lines = split /\n/s, $lines;
	push @simlog_extract, @lines;
    }

    if (-f  "sim.log")
    {
	my $cmd = "grep -c PASS sim.log";	## count lines with PASS
	my $count = `$cmd`;
	chomp $count;				## get rid of newline at end
	$pass = 1 if ($count > 0);
    }

    if (-f "diag_pl.log")
    {
      open (DIAGPLLOG, "diag_pl.log") or die ("DIE. could not open diag_pl.log") ;
      my @diagpllog = <DIAGPLLOG> ;
      close (DIAGPLLOG) ;

      my @pass = grep (/PASS/, @diagpllog) ;
      $pass = 1 if ($#pass >= 0) ;
      my @fail = grep (/FAIL/, @diagpllog) ;
      $pass = 0 if ($#fail >= 0) ;
    }

    if (-f "tsotool.log")
    {
      open (TSOTOOLLOG, "tsotool.log") or die ("DIE. could not open tsotool.log") ;
      my @tsotoollog = <TSOTOOLLOG> ;
      close (TSOTOOLLOG) ;

      my @fail = grep (/fatal\serror/i, @tsotoollog) ;
      $pass = 0 if ($#fail >= 0) ;
    }

    # if this is a regression copy the results back to the result area

    if ($opt{regress})
    {

      `gzip 0in_checksim.db` if (-f "0in_checksim.db") ; # Always compress this

      # find out if diag passed

      if ($pass and (!$opt{copyall}))
      {
        # compress the files

        `gzip sim.log` if ($opt{gzip} and (-f "sim.log")) ;
        `gzip sas.log` if ($opt{gzip} and (-f "sas.log")) ;
        `gzip diag.exe` if ($opt{gzip} and (-f "diag.exe")) ;
        `gzip sim.fsdb` if ($opt{gzip} and (-f "sim.fsdb") and $opt{copydump}) ;
        `gzip sim.vcd` if ($opt{gzip} and (-f "sim.vcd") and $opt{copydump}) ;

        # copy back all relevant data

        `cp 0in_checksim.db.gz $launch_dir` if (-f "0in_checksim.db.gz") ;
        print ("$prg: warning could not copy 0in_checksim.db files back to $launch_dir\n") if ($?) ;
        `cp 0in_covered.rpt $launch_dir` if (-f "0in_covered.rpt") ;
        print ("$prg: warning could not copy 0in_covered.rpt files back to $launch_dir\n") if ($?) ;
        `cp *.log.gz $launch_dir` ;
        print ("$prg: warning could not copy *.log.gz files back to $launch_dir\n") if ($?) ;
        `cp *.log $launch_dir` ;
        print ("$prg: warning could not copy *.log files back to $launch_dir\n") if ($?) ;
        `cp -r raw_coverage $launch_dir` ;
        print ("$prg: warning could not copy vera coverage data back to $launch_dir\n") if ($?) ;
        `cp -r ${opt{vcs_cm_name}}* $launch_dir` if ($opt{vcs_use_cm}) ;
        print ("$prg: warning could not copy vcs coverage data back to $launch_dir\n") if ($?) ;
        `cp -r ${opt{vcs_cm_name}}* ${model_path}/coverage/verilog` if ($opt{vcs_use_cm}) and ($opt{vcs_cm_merge}) ;
        print ("$prg: warning could not copy vcs coverage data back to ${model_path}/coverage/verilog\n") if ($?) ;
	if ( $opt{copydump} ) {
	    my $fsdbfile = "sim.fsdb";
	    my $vcdfile  = "sim.vcd";
	    if ( exists $opt{fsdbfile} and $opt{fsdbfile} ne "" ) {
		$fsdbfile = $opt{fsdbfile};
		$vcdfile  = $fsdbfile . ".vcd";
	    }
	    if ( $opt{fsdb2vcd} ) {	# only interested in vcd files
		`cp $vcdfile.gz $launch_dir` if ( -f "$vcdfile.gz" ) ;
		print "$prg: warning could not copy $vcdfile.gz file back "
			. " to $launch_dir\n" if ($?) ;
		`cp $vcdfile $launch_dir` if ( -f $vcdfile ) ;
		print "$prg: warning could not copy $vcdfile file back to "
			. "$launch_dir\n" if ($?) ;
	    } else {			# else copy fsdb files
		`cp $fsdbfile.gz $launch_dir` if ( -f "$fsdbfile.gz" ) ;
		print "$prg: warning could not copy sim.fsdb.gz file back to "
			. "$launch_dir\n" if ($?) ;
		`cp $fsdbfile $launch_dir` if ( -f $fsdbfile ) ;
		print "$prg: warning could not copy $fsdbfile file back to "
			. "$launch_dir\n" if ($?) ;
	    }
	}

        if ($opt{tap_diag_name} ne "")
        {
          `cp diag.tap tap.cmd $launch_dir` ;
          print ("$prg: warning could not copy tap diag file back to $launch_dir\n") if ($?) ;
        }

        if ($opt{asm_diag_name} ne "")
        {
          `cp *.s *.tbl *.ev *.exe.gz $launch_dir` ;
          print ("$prg: warning could not copy assembly files back to $launch_dir\n") if ($?) ;
        }

        if ($opt{sjm} or ($opt{sjm_diag_name} ne "") or $opt{pci} or ($opt{pci_diag_name} ne ""))
        {
          `cp *.cmd $launch_dir` ;
          print ("$prg: warning could not copy sjm/pci command files back to $launch_dir\n") if ($?) ;
        }

        if ($opt{efc} or ($opt{efuse_image_name} ne ""))
        {
          `cp efuse.img $launch_dir` ;
          print ("$prg: warning could not copy efuse image file back to $launch_dir\n") if ($?) ;
        }

        if ($opt{vera_diag_name} ne "")
        {
          `cp *.vr *.vrpal $launch_dir` ;
          print ("$prg: warning could not copy vera diag back to $launch_dir\n") if ($?) ;
        }

        if ($opt{tpt_diag_name} ne "")
        {
          `cp *.tpt $launch_dir` ;
          print ("$prg: warning could not copy tpt diag back to $launch_dir\n") if ($?) ;
        }
      }
      else	# diag failed or $opt{copyall} is set
      {
        if ($opt{tarcopy}) {
            `tar cfE - . | ( cd $launch_dir; tar vxfEBp - )`;
        } else {
            `cp -r * $launch_dir` ;
        }
        print ("$prg: warning could not copy files back to $launch_dir\n") if ($?) ;
      }

      # clean up the tmp area
      chdir $launch_dir ;
      `rm -rf $work_dir` ;
      print ("$prg: warning could not delete content of $work_dir\n") if ($?) ;
    }

    ##
    ## Warning:
    ## -------
    ## Array @simlog_extract is set at the top of this subroutine with
    ## JUST the patterns that are looked for here.
    ## IF YOU LOOK FOR MORE PATTERNS HERE, you MUST add to the patterns
    ## that @simlog_extract greps for, from the sim.log file.
    ##
    my @cycle = grep (/Time:/, @simlog_extract) ;

    if (defined $cycle [0])
    {
      $cycle [0] =~ s/^Time:\s(\d+)\s[fp]s/$1/ ;
    }
    else
    {
      return ;
    }

    # update simsdb with big brother data
    if ($opt{vcs_run})
    {
      my @freq = grep (/Core\sClock\sFrequency/, @simlog_extract) ;
      if (defined $freq [0])
      {
        $freq [0] =~ s/^.*?Core\s+Clock\s+Frequency\s+(\d+)\s+MHz$/$1/ ;
      }
      else
      {
        $freq [0] = "" ;
      }

      my $status = "f" ;
      $status = "p" if ($pass) ;

      &update_db ($cycle [0], $main::sim_start, $main::sim_stop, $freq [0], $status) ;
    }

}

################################################################################
# launch sas
################################################################################

sub sas_run
{
    # first clean up the diag area
    `rm -rf sas.log` ;
    die ("DIE. could not clean up diag run area") if ($?) ;

    my $csocket = 0 ;

    my $def_sas_str = join(" ", grep (/^-D/, @{$opt{sas_run_args}})) ;
    my $opt_sas_str = join(" ", grep (!/^-D/, @{$opt{sas_run_args}})) ;

    $def_sas_str .= " -DFAST_BOOT " if ($opt{fast_boot}) ;

    # remove socket pli flag
    `rm -rf pli-socket-opened` ;

    # create socket numbers for rtl-sas run
    print "$prg: creating sas sockets\n" ;

    if ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run})
    {
      $def_sas_str .= " -DRTL ";
      $def_sas_str .= " -DVSOCKET=0 ";
      my $tmp = $$ & 0x1fff;
      $csocket = $tmp + 10000 ; # initial socket port to try out
      $tmp = $tmp + 11000 ; # this is an upper bound on trying to find a port

      my $proto = getprotobyname('tcp');
      socket(Server, PF_INET, SOCK_STREAM, $proto) || die "DIE. Could not open socket file handle" ;
      while ((!bind(Server, sockaddr_in($csocket, INADDR_ANY))) and ($csocket < $tmp)) {$csocket++;}
      close (Server) ;

      die "DIE. Could not find a free port for socket" if ($csocket == $tmp) ;

      $def_sas_str .= " -DCSOCKET=$csocket ";
      push (@{$opt{sim_run_args}}, "+csocket=$csocket");
    }
    else
    {
      $def_sas_str .= " -DMEM_DISABLE ";
      $def_sas_str .= " -DMAX_CYCLE=$opt{max_cycle} " if ($opt{max_cycle}) ;

      my $finish_mask = sprintf ("%b", hex ($opt{finish_mask})) ;
      my $finish_count = 0 ;
      foreach my $x (split (//, $finish_mask)) { $finish_count++ if ($x eq '1') } ;
      $def_sas_str .= " -DFINISH_COUNT=$finish_count " ;
    }

    my $cmd = "$proj_vars{sasconfig} $def_sas_str" ;
    print "$prg: $cmd\n" ;
    system ($cmd) ;
    die ("DIE. could not invoke $proj_vars{sasconfig}") if ($?) ;

    print "$prg: starting $proj_vars{sas}\n" ;
    $cmd = "$proj_vars{sas} $opt_sas_str " ;
    $cmd .= " -verbose " if ($opt_debug == 1) ;
    print "$prg: $cmd\n";

    if ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run})
    {
      $sas_pid = fork () ;

      if ((defined $sas_pid) and ($sas_pid == 0))
      {
        setpgrp (0, $$) ;
        system ("$cmd > sas.log 2>&1") ;
        exit (0) ;
      }
      elsif (!defined $sas_pid)
      {
        die ("DIE. could not fork off the sas process") ;
      }

      # wait until sas has started running before proceeding

      my $timeout_counter = 0 ;

      while (! -e "pli-socket-opened")
      {
        print "$prg: waiting for pli socket to be opened\n" ;

        $timeout_counter++ ;

        if ($timeout_counter > 20)
        {
          die ("DIE. sas socket open timeout") ;
        }

        sleep 4;
      }
    }
    else
    {
      if ($opt{regress})
      {
        system ("$cmd > sas.log 2>&1") ;
        die ("DIE. simics exited with an error") if ($?) ;
      }
      else
      {
        if ($opt{saslog})
        {
          system ("$cmd > sas.log 2>&1") ;
          die ("DIE. simics exited with an error") if ($?) ;
        }
        else
        {
          system ($cmd) ;
        }
      }
    }
}

################################################################################
# launch tcl_tap
################################################################################

sub tcl_tap_run
{
    # first clean up the diag area
    `rm -f tcl.log expect_log_file tcl2sim.log sim2tcl.log done` ;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # build JTAG low level commands in sub-directory
    my $jtag_log	= "jtag.log";
    my $tcl_log		= "tcl.log";
    my $pwd		= File::Spec->rel2abs( "." );
    my $cmd_dir		= File::Spec->catdir( $pwd, "jtag_cmds" );
    my $tap_dir		= File::Spec->canonpath( "$dv_root/verif/env/tap" );
    my $tap_src_dir	= File::Spec->catdir( $tap_dir, "src" );
    my $makefile	= File::Spec->catfile( $tap_src_dir, "Makefile" );
    if (! -d $cmd_dir ) {
	`mkdir $cmd_dir`;
	die ( "DIE. Could not create $cmd_dir to run tcl tap code" ) if ($?);
    }
    chdir $cmd_dir;
    print "$prg: making JTAG low level commands in $cmd_dir\n" ;
    my $cmd = "gmake -f $makefile VPATH=$tap_src_dir ";
    call_program( $cmd, $jtag_log );
    chdir $pwd;

    print "$prg: starting expect/tcl\n" ;
    my $tcl_tap_diag;
    if ( $opt{tcl_tap_diag} ) {
	my $diagdir		= $tap_src_dir;
	my @diags;
	@diags	 	= `find $diagdir -name $opt{tcl_tap_diag} -print`;
	if ( (scalar @diags) > 0 ) {
	    $tcl_tap_diag 	= $diags[0];
	} else {
	    die "DIE. could not find $opt{tcl_tap_diag} under $diagdir\n";
	}
	$tcl_tap_diag 	= File::Spec->canonpath( $tcl_tap_diag );
    } # if $opt{tcl_tap_diag}
    else {
	$tcl_tap_diag = File::Spec->catfile( $tap_src_dir, "main_niagara.exp" );
    }
    $cmd = "" ;
    $cmd .= "xterm -sb -sl 1000 -e " ;
    my $expect_cmd = "";
    $expect_cmd .= "expect " ;
    $expect_cmd .= " -d " if ($opt_debug == 1) ;
    $expect_cmd .= " $tcl_tap_diag ";
    $cmd .= $expect_cmd;
    print "$prg: $cmd\n";

    if ($opt{vcs_run} or $opt{ncv_run} or $opt{icv_run} or $opt{other_sim_run})
    {
      $tcl_pid = fork () ;

      if ((defined $tcl_pid) and ($tcl_pid == 0))
      { # child
        setpgrp (0, $$) ;
	# add path to JTAG commands just built
	$ENV{PATH}	= "${cmd_dir}:$ENV{PATH}";
	call_program( $cmd, $tcl_log );
        exit (0) ;
      }
      elsif (!defined $tcl_pid)
      {
        die ("DIE. could not fork off the tcl process") ;
      }
    }
    else
    {
      if ($opt{regress})
      {
	# add path to JTAG commands just built
	$ENV{PATH}	= "${cmd_dir}:$ENV{PATH}";
	call_program( $cmd, $tcl_log );
        die ("DIE. expect/tcl exited with an error") if ($?) ;
      }
      else
      {
	  # add path to JTAG commands just built
	  $ENV{PATH}	= "${cmd_dir}:$ENV{PATH}";
	  call_program( $cmd, $tcl_log );
          die ("DIE. expect/tcl exited with an error") if ($?) ;
      }
    }
} # tcl_tap_run

################################################################################
# open up the config file and get the arguments for this sys
################################################################################

sub get_config
{
  my $sys_name = shift ;
  my $argvref = shift ;

  my $confcppargs = join(' ', @{$opt{config_cpp_args}});
  print "$prg: using config file $sims_config ($confcppargs)\n" ;
  open (SIMS_CONFIG, "bw_cpp -P -B $confcppargs -undef -I$dv_root/$proj_vars{sims_config} $sims_config | ") or die "DIE. Could not open $sims_config" ;
  my @sims_config_file = <SIMS_CONFIG> ;
  close (SIMS_CONFIG) ;

  my $sims_config_file = join ('', @sims_config_file) ;

  my ($body) = ($sims_config_file =~ /<\s*$sys_name\s*>\s+(.*?)<\s*\/$sys_name\s*>/ogis) ;

  die "DIE. could not find $sys_name in $sims_config" if (!defined $body) ;

  # Add OS/CPU specific configuration

  my $os_cpu = `uname -s`;
  $os_cpu =~ s/\n//g;
  if ($os_cpu eq "SunOS") {
    $os_cpu .= ".";
    $os_cpu .= `uname -p`;
  } else {
    $os_cpu .= ".";
    $os_cpu .= `uname -m`;
  }
  $os_cpu =~ s/\n//g;
  my $os_cpu_config = $dv_root;
  $os_cpu_config .= "/";
  $os_cpu_config .= $proj_vars{sims_config};
  $os_cpu_config .= "/";
  $os_cpu_config .= $sys_name;
  $os_cpu_config .= ".";
  $os_cpu_config .= $os_cpu;
  if ( -f $os_cpu_config ) {
    open (SIMS_CONFIG, $os_cpu_config) or die "DIE. Could not open $os_cpu_config" ;
    my @sims_config_file = <SIMS_CONFIG> ;
    close (SIMS_CONFIG) ;

    my $sims_config_file = join ('', @sims_config_file) ;
    $body .= $sims_config_file;
  } else {
    print "$prg: $os_cpu_config Not found.\n";
  }

  my @argv = split (/\n/, $body) ;

  foreach my $x (@argv)
  {
    next if ($x =~ /^\s*$/o);  # Discard empty lines
    $x =~ s/^\s*(-.*)/$1/ ;
    $x =~ s/(.*?)\s*$/$1/ ;
    unshift (@{$argvref}, $x) ;
  }
}

################################################################################
# Freeze tool versions:
#       Given a run_dir, make copy of all tver files.
#       Construct an iver file pointing to these tvers
#       Return string which is new value of env variable: TRE_SEARCH
################################################################################

sub freeze_tre
{
  my $run_dir = shift ;
  my $tre_search = "";

  my $TRE_SEP = '/';

  if ( -d "$run_dir/tre" and -f "$run_dir/tre/sims.iver" ) {
    # recursive call.  tre_search already filled in
    # $tre_search = "$run_dir/tre/sims.iver"    if $opt{use_iver} eq "";
    return $tre_search;
  }

    my $entry = $TRE_SEP;

    ## $! = -1;
    die "$prg: \$TRE_SEARCH not set!\n" unless exists $ENV{TRE_SEARCH};
    die "$prg: \$TRE_SEARCH set to blank!\n" unless $ENV{TRE_SEARCH} =~ /\S/;

    my @ivers = split ' ', $ENV{TRE_SEARCH};
    my @tvers;
    my %seen_tver;
    foreach my $iver (@ivers) {
      print "CHECK IVER: $iver\n" if $opt_debug;
      my @tvers_from_iver = get_tvers_from_iver($iver);
      foreach my $tver (@tvers_from_iver) {
        if(not exists $seen_tver{$tver}) {
          push @tvers, $tver;
          $seen_tver{$tver} = 1;
          ## $! = 2;
          die "$prg: Cannot find tver '$tver'!\n" unless -e $tver;
        }
      }
    }

    ## at this point, all the tvers are now collected and in order
    ## we need to copy them to files in the run_dir directory
    ## and construct an iver that points to them.
    `mkdir -p $run_dir/tre`;
    die "$prg: cannot create $run_dir/tre: $!\n" if ($?);
    my $tnum = 0;
    my $iver = $run_dir . "/tre" . "/sims.iver";
    $tre_search = File::Spec->rel2abs( $iver ); # clean up path
    my $dest = "";
    local (*IVER);
    open IVER, "> $iver" or die "$prg: could not write to $iver: $!\n";
    foreach my $tver ( @tvers ) {
        $dest = sprintf "%s_%0d", "$run_dir/tre/sims.tver", $tnum;
        $dest = File::Spec->rel2abs( $dest );   # clean up path, if relative
        `cp $tver $dest`;
        die "$prg: could not copy tver: $tver: to $dest\n" if ($?);
        printf IVER "%s\n", $dest;
        $tnum++;
    } # foreach tver
    close IVER;

    return $tre_search;

} # freeze_tre

###############################################################################

sub expand_filename {
  my $filename = shift;

  $filename =~ s/^\s+//;
  # twiddle expansion
  $filename =~
    s{ ^ ~ ([^/]*) }
      { $1 ? (getpwnam($1))[7] :
          ( $ENV{HOME} || $ENV{LOGDIR} || (getpwuid($>))[7]) }ex;
  # environment variable expansion
  $filename =~ s/\${*(\w+)}*/expand_env($1)/ge;

  return $filename;
}

###############################################################################

sub expand_env {
  my $envvar = shift;

  return $ENV{$envvar} if exists $ENV{$envvar};
  die "$prg: Environment variable '$envvar' not defined!\n";
}

###############################################################################

sub get_tvers_from_iver {
  my $iver = shift;
  local (*IVER);

  $iver = expand_filename($iver);
  return unless -e $iver;
  open IVER, "<$iver" or die "$prg:  Can't open '$iver': $!\n";
  my @tvers;
  while(<IVER>) {
    chomp;
    s/\#.*$//;
    $_ = expand_filename($_);
    next unless /\S/;
    print "  -- tver file: $_\n" if $opt_debug;
    push @tvers, $_;
  }
  return @tvers;
}




################################################################################
# assemble diag
################################################################################

sub assemble_diag
{
    # first clean up the diag area
    `rm -rf diag.pal diag.s diag.pl diag.exe mem.image diag.ev symbol.tbl` ;
    die "DIE. could not clean up assembly diag run area"  if ($?) ;

    # find diagnostic
    my $diag_full_path = &find_diag_path ($opt{asm_diag_name}, $opt{asm_diag_path}, $opt{asm_diag_root}) ;

    my $diag_name ;
    if ($opt{asm_diag_name} =~ /\.pal/) { $diag_name = "diag.pal" ; }
    elsif ($opt{asm_diag_name} =~ /\.s\.gz/) { $diag_name = "diag.s.gz" ; }
    else { $diag_name = "diag.s" ; }

    # copy diagnostic to run area
    `cp $diag_full_path $diag_name` ;
    die ("DIE. unable to copy assembly diag to $ENV{PWD}") if ($?) ;
    `chmod +w $diag_name` ;
    die ("DIE. unable to permission of assembly diag") if ($?) ;

    # gunzip if needed
    if ($opt{asm_diag_name} =~ /\.s\.gz/)
    {
      `gzip -d diag.s.gz` ;
      die ("DIE. unable to gunzip assembly diag") if ($?) ;
      $diag_name = "diag.s" ;
    }

    $ENV{ASM_DIAG_NAME} = $opt{asm_diag_name};

    # pre process if needed
    &pre_process ;

    # extract sims options from diag.s
    if ($diag_name =~ /\.s/)
    {
      open (DIAGIN, "< diag.s") or die "DIE. Could not open diag.s" ;

      while (<DIAGIN>)
      {
        my $line = $_ ;

        if ($line =~ /^\!SIMS\+ARGS\:/)
        {
          my (@plusargs) = split (/\s+/, $line) ;
          shift (@plusargs) ;
          push (@ARGV, @plusargs) ;
          print "$prg: Found sims arguments in diag.s: @plusargs\n" ;
          parse_args ("dummy", 0) ;
        }
      }

      close (DIAGIN) ;
    }

    # assemble
    push (@{$opt{midas_args}}, "-DFAST_BOOT") if ($opt{fast_boot}) ;
    push (@{$opt{midas_args}}, "-diag_root=$dv_root") ;
    push (@{$opt{midas_args}}, "-DTG_SEED=$opt{tg_seed}") if ($opt{midas_use_tgseed}) ;
    push (@{$opt{midas_args}}, "-pal_diag_args=-seed=$opt{tg_seed}") if ($opt{pal_use_tgseed}) ;
    push (@{$opt{midas_args}}, "$diag_name") ;

    push (@{$opt{midas_args}}, "-DCIOP") if ($opt{icv_run} or ($opt{sim_type} eq "icv")) ;

    print "$prg: assembling diag\n" ;
    my $cmd = "midas " ;
    $cmd .= join (" ", @{$opt{midas_args}}) ;
    print "$prg: $cmd\n";

    my $waitstatus = call_program($cmd, "midas.log");
    die ("DIE. midas compilation error") if ($waitstatus) ;

    if ($opt{midas_only} and $opt{regress}) {
        if ($opt{tarcopy}) {
            `tar cfE - . | ( cd $launch_dir; tar vxfEBp - )`;
        } else {
            `cp -r * $launch_dir` ;
        }
        print ("$prg: warning could not copy files back to $launch_dir\n") if ($?) ;
    }

    exit (0) if ($opt{midas_only}) ;
}

################################################################################
# call_program - runs a program, tee's the output to a log, and returns exit
# status
################################################################################

sub call_program {
  my $cmd  = shift;
  my $file = shift;

  local (*PROGFH, *TEE);
  open( PROGFH,  "$cmd 2>&1 |" ) or die "Can't run '$cmd': $!\n";

  open( TEE, ">$file" ) or die "Can't open '$file': $!\n";

  my $old_fh = select(TEE);
  $| = 1;
  select($old_fh);

  while(<PROGFH>) {
    print;
    print TEE;
  }

  close( TEE );

  close( PROGFH );
  return $?;
}

################################################################################
# copy diag image
################################################################################

sub copy_image
{
    # first clean up the diag area
    `rm -rf diag.pal diag.s diag.pl diag.exe mem.image diag.ev symbol.tbl` ;
    die ("DIE. could not clean up image run area")  if ($?) ;

    my $image_full_path = &find_diag_path ($opt{image_diag_name}, $opt{image_diag_path}, $opt{image_diag_root}) ;

    `cp $image_full_path mem.image` ;
    die ("DIE. unable to copy memory image into $ENV{PWD}") if ($?) ;
    `chmod +w mem.image` ;
    die ("DIE. unable to change permission of memory image") if ($?) ;

    $image_full_path =~ s/\.image/\.ev/ ;
    `cp $image_full_path diag.ev` ;
    die ("DIE. unable to copy diag event file into $ENV{PWD}") if ($?) ;
    `chmod +w diag.ev` ;
    die ("DIE. unable to change permission of diag event file") if ($?) ;

    $image_full_path =~ s/\.ev/\.tbl/ ;
    `cp $image_full_path symbol.tbl` ;
    die ("DIE. unable to copy symbol table file into $ENV{PWD}") if ($?) ;
    `chmod +w symbol.tbl` ;
    die ("DIE. unable to change permission of symbol table") if ($?) ;

    # pre process if needed
    &pre_process ;
}

################################################################################
# copy efuse image
################################################################################

sub copy_efuse_image
{
    # first clean up the diag area
    `rm -rf efuse.img` ;
    die ("DIE. could not clean up efuse image from run area")  if ($?) ;

    my $efuse_image_full_path = &find_diag_path ($opt{efuse_image_name}, $opt{efuse_image_path}, $opt{efuse_image_root}) ;

    `cp $efuse_image_full_path efuse.img` ;
    die ("DIE. could not copy efuse image to $ENV{PWD}") if ($?) ;
    `chmod +w efuse.img` ;
    die ("DIE. could not change permission of efuse image") if ($?) ;
}

################################################################################
# generate efuse image
################################################################################

sub generate_efuse_image
{
    # first clean up the diag area
    `rm -rf efuse.img` ;
    die ("DIE. could not clean up efuse image from run area")  if ($?) ;

    my $cmd = "efcgen.pl " ;
    $cmd .= join (" ", @{$opt{efc_args}}) ;
    $cmd .= " -seed=$opt{tg_seed} " ;
    print "$prg: $cmd\n" ;

    system ($cmd) ;
    die ("DIE. failed efuse image generation") if ($?) ;

    `chmod +w efuse.img` ;
    die ("DIE. could not change permission of efuse image") if ($?) ;
}

################################################################################
# compile dftvert vera diag
################################################################################

sub compile_dftvert_diag
{
    # first clean up the diag area
    `rm -rf diag.vr diag.vrpal diag.vro` ;
    die ("DIE. could not clean up dftvert vera diag run area") if ($?) ;

    my $vera_full_path = &find_diag_path ($opt{vera_diag_name}, $opt{vera_diag_path}, $opt{vera_diag_root}) ;

    ## ($opt{vera_diag_path}) = $vera_full_path =~ m/(.*)\//o;

    if ( $vera_full_path =~ /\.vrpal$/ ) {	# pal diag to be expanded
	`cp -f $vera_full_path diag.vrpal` ;
	die ("DIE. failed dftvert vera pal diag copy to $ENV{PWD}") if ($?) ;
        my $pal_opts = join (" ", @{$opt{vera_pal_diag_args}}) ;
        $pal_opts .= " -seed=$opt{tg_seed} " if ($opt{pal_use_tgseed}) ;
	`pal $pal_opts -o diag.vr diag.vrpal`;
	die ("DIE. failed dftvert vera pal diag expansion to diag.vr") if ($?) ;
    } else {
	`cp -f $vera_full_path diag.vr` ;
	die ("DIE. failed dftvert vera diag copy to $ENV{PWD}") if ($?) ;
    }
    `chmod +w diag.vr` ;
    die ("DIE. failed to change permission of dftvert vera diag") if ($?) ;

    # pre process if needed
    &pre_process ;

    print "$prg: Compiling dftvert vera diag\n" ;
    my $cmd = "dftvert ";
    $cmd .= "-srcdir $opt{env_base}/vera " ;
    $cmd .= "-diagfile diag.vr " ;
    $cmd .= "-resultdir . " ;
    $cmd .= "-cmpdiag" ;
    print "$prg: $cmd\n" ;
    system ($cmd) ;
    die ("DIE. failed dftvert vera diag compilation") if ($?) ;
}

################################################################################
# compile vera diag
################################################################################

sub compile_vera_diag
{
    # first clean up the diag area
    `rm -rf diag.vr diag.vrpal diag.vro` ;
    die ("DIE. could not clean up vera diag run area") if ($?) ;

    my $vera_full_path = &find_diag_path ($opt{vera_diag_name}, $opt{vera_diag_path}, $opt{vera_diag_root}) ;

    ## ($opt{vera_diag_path}) = $vera_full_path =~ m/(.*)\//o;

    if ( $vera_full_path =~ /\.vrpal$/ ) {	# pal diag to be expanded
	`cp -f $vera_full_path diag.vrpal` ;
	die ("DIE. failed vera pal diag copy to $ENV{PWD}") if ($?) ;
        my $pal_opts = join (" ", @{$opt{vera_pal_diag_args}}) ;
        $pal_opts .= " -seed=$opt{tg_seed} " if ($opt{pal_use_tgseed}) ;
	`pal $pal_opts -o diag.vr diag.vrpal`;
	die ("DIE. failed vera pal diag expansion to diag.vr") if ($?) ;
    } else {
	`cp -f $vera_full_path diag.vr` ;
	die ("DIE. failed vera diag copy to $ENV{PWD}") if ($?) ;
    }
    `chmod +w diag.vr` ;
    die ("DIE. failed to change permission of vera diag") if ($?) ;

    # pre process if needed
    &pre_process ;

    print "$prg: Compiling vera diag\n" ;
    my $cmd = "vera -cmp -max_error 5 -q -I $model_path/vera ";

    foreach my $obj (@{$opt{vera_cov_obj}})
    {
      $obj =~ tr/a-z/A-Z/ ;
      push (@{$opt{vera_diag_args}}, "-D$obj") ;
    }

    $cmd .= join (" ", @{$opt{vera_diag_args}}) ;
    $cmd .= " diag.vr" ;

    print "$prg: $cmd\n" ;

    if (! $opt{dryrun})
    {
      system ($cmd) ;
      die ("DIE. failed vera diag compilation") if ($?) ;
    }
}

################################################################################
# complile vera config
################################################################################

sub compile_vera_config
{
    # first clean up the diag area
    `rm -rf config.vr config.vro`;
    die ("DIE. could not clean up vera config run area") if ($?) ;

    my $vera_full_path  = &find_diag_path ($opt{vera_config_name}, $opt{vera_config_path}, $opt{vera_config_root}) ;

    `cp -f $vera_full_path config.vr; chmod +w config.vr` ;
    die ("DIE. failed vera config copy to $ENV{PWD}") if ($?) ;

    # pre process if needed
    &pre_process ;

    print "$prg: Compiling vera config\n" ;
    my $cmd = "vera -cmp -max_error 5 -q -I $model_path/vera ";
    $cmd .= join (" ", @{$opt{vera_diag_args}}) ;
    $cmd .= " config.vr " ;
    print "$prg: $cmd\n" ;
    if (! $opt{dryrun})
    {
      system ($cmd) ;
      die ("DIE. failed vera config compilation") if ($?) ;
    }
}

################################################################################
# copy tap diag
################################################################################

sub assemble_tap_diag
{
  # first clean up the diag area
  `rm -rf tap.cmd`;
  die ("DIE. could not clean up tap run area") if ($?) ;

  my $tap_full_path = &find_diag_path ($opt{tap_diag_name}, $opt{tap_diag_path}, $opt{tap_diag_root}) ;

  `cp $tap_full_path diag.tap` ;
  die ("DIE. could not copy tap diag to $ENV{PWD}") if ($?) ;
  `chmod +w diag.tap` ;
  die ("DIE. could not change permission of tap diag") if ($?) ;

  # pre process if needed
  &pre_process ;

  # compile the tap diag

  my $cmd = "tapasm" ;
  system ($cmd) ;
  die ("DIE. could not assemble tap diag") if ($?) ;
}

################################################################################
# copy tpt diag
################################################################################

sub copy_tpt
{
  # first clean up the diag area
  `rm -rf diag.tpt`;
  die ("DIE. could not clean up tpt run area") if ($?) ;

  my $tpt_full_path = &find_diag_path ($opt{tpt_diag_name}, $opt{tpt_diag_path}, $opt{tpt_diag_root}) ;

  `cp $tpt_full_path diag.tpt` ;
  die ("DIE. could not copy tpt diag to $ENV{PWD}") if ($?) ;
  `chmod +w diag.tpt` ;
  die ("DIE. could not change permission of tpt diag") if ($?) ;

  # pre process if needed
  &pre_process ;
}

################################################################################
# generate an sjm diag
################################################################################

sub generate_sjm_diag
{
  # first clean up the diag area
  `rm -rf sjm_4.cmd sjm_5.cmd`;
  die ("DIE. could not clean up sjm run area") if ($?) ;

  my $cmd = "sjm_tstgen.pl " ;
  $cmd .= join (" ", @{$opt{sjm_args}}) ;
  $cmd .= " -seed=$opt{tg_seed} " ;

  if (($opt{sjm_diag_name} ne "") or ($opt{sjm_diag_path} ne ""))
  {
    my $sjm_full_path = &find_diag_path ($opt{sjm_diag_name}, $opt{sjm_diag_path}, $opt{sjm_diag_root}) ;
    `cp ${sjm_full_path}/sjm_4.cmd sjm_4.cmd` ;
    die ("DIE. could not copy sjm_4 diag to $ENV{PWD}") if ($?) ;
    `chmod +w sjm_4.cmd` ;
    die ("DIE. could not change permission of sjm_4 diag") if ($?) ;

    `cp ${sjm_full_path}/sjm_5.cmd sjm_5.cmd` ;
    die ("DIE. could not copy sjm_5 diag to $ENV{PWD}") if ($?) ;
    `chmod +w sjm_5.cmd` ;
    die ("DIE. could not change permission of sjm_5 diag") if ($?) ;
  }
  else
  {
    system ($cmd) ;
    die ("DIE. could not generate sjm diag") if ($?) ;
  }

  # pre process if needed
  &pre_process ;
}

################################################################################
# generate an pci diag
################################################################################

sub generate_pci_diag
{
  # first clean up the diag area
  # `rm -rf pci_4.cmd pci_5.cmd`;
  # die ("DIE. could not clean up pci run area") if ($?) ;

  my $cmd = "pci_cmdgen.pl " ;
  $cmd .= join (" ", @{$opt{pci_args}}) ;
  $cmd .= " -seed=$opt{tg_seed} " ;

  if (($opt{pci_diag_name} ne "") or ($opt{pci_diag_path} ne ""))
  {
    my $pci_full_path = &find_diag_path ($opt{pci_diag_name}, $opt{pci_diag_path}, $opt{pci_diag_root}) ;
    `cp ${pci_full_path}/* .` ;
    die ("DIE. could not copy pci diag to $ENV{PWD}") if ($?) ;
    `chmod +w *` ;
    die ("DIE. could not change permission of pci diag") if ($?) ;
  }
  else
  {
    system ($cmd) ;
    die ("DIE. could not generate pci diag") if ($?) ;
  }

  # pre process if needed
  &pre_process ;
}

################################################################################
# locate a diag based on diag_root, diag_path and diag_name
################################################################################

sub find_diag_path
{
  my $diag_name = shift ;
  my $diag_path = shift ;
  my $diag_root = shift ;

  my @full_path = () ;

  print "$prg: locating diag $diag_name\n" ;

  if (($diag_path ne "") and (-e "${diag_path}/$diag_name"))
  {
    push (@full_path, "${diag_path}/$diag_name\n") ;
  }
  else
  {
    foreach my $root (@{$diag_root})
    {
      print "$prg: Looking for diag under $root\n" ;
      @full_path = `find $root -follow -name '$diag_name'`;
      last if ($#full_path > -1) ;
    }
  }

  if ($#full_path == -1) { die ("DIE. no diag with name $diag_name found") ; }
  if ($#full_path > 0) { die ("DIE. multiple diags with name $diag_name found $#full_path $full_path[0] $full_path[1]") ; }

  chomp $full_path[0];
  print "$prg: Found diag under $full_path[0]\n" ;
  return $full_path[0] ;
}

################################################################################
# parse all arguments from command line and config file
################################################################################

sub parse_args
{
  my $sys = shift ;
  my $doconfig = shift ;

  &get_config ($sys, \@ARGV) if ($opt{use_config} and $doconfig) ;

  print "\@ARGV: @{ARGV}\n" if ($opt_debug) ;

  foreach my $i (0 .. $#ARGV)
  {
    ($ARGV[$i] =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($ARGV[$i] =~ /\s/) and ($ARGV[$i] !~ /-.*?="/)) ;
    ## print "$i $ARGV[$i]\n" ;
  }

  GetOptions (\%opt,
            'alias=s',
            'asm_diag_name=s',
            'asm_diag_path=s',
            'asm_diag_root=s@',
            'auditr_args=s@',
            'build!',
            'cc_dv_root=s',
	    'clearcase!',
            'config_cpp_args=s@',
            'config_rtl=s@',
            'copyall!',
            'copydump!',
            'debug!',
            'debussy!',
            'dftvert!',
            'diag_pl_args=s@',
            'diaglist=s',
            'diaglist_cpp_args=s@',
            'drmlog!',
            'jobcommand_name=s',
            'dryrun!',
            'dv_root=s',
            'efc!',
            'efc_args=s@',
            'efuse_image_name=s',
            'efuse_image_path=s',
            'efuse_image_root=s@',
            'env_base=s',
            'fast_boot!',
            'finish_mask=s',
            'flist=s@',
            'fsdb2vcd!',
            'fsdbfile=s',
            'fsdbDumplimit=s',
            'fsdb_glitch!',
            'graft_flist=s',
            'group=s@',
            'group_name=s',
            'gzip!',
            'icv_build!',
            'icv_build_args=s@',
            'icv_run!',
            'image_diag_name=s',
            'image_diag_path=s',
            'image_diag_root=s@',
            'injobq!',
            'interactive!',
            'max_cycle=i',
            'midas_args=s@',
            'midas_only!',
            'midas_use_tgseed!',
            'model=s',
            'model_dir=s',
            'network_config=s',
            'ncv_build!',
            'ncv_build_args=s@',
            'ncv_run!',
            'ntb_lib!',
            'overwrite!',
            'pal_use_tgseed!',
            'parallel!',
            'pci!',
            'pci_args=s@',
            'pci_diag_name=s',
            'pci_diag_path=s',
            'pci_diag_root=s@',
            'pico!',
            'pico_het!',
            'post_process_cmd=s@',
            'pre_process_cmd=s@',
            'reg_count=i',
            'regress!',
            'regress_date=s',
            'regress_id=s',
            'regress_time=s',
            'report!',
            'rerun!',
            'result_dir=s',
            'rtl_timeout=i',
	    'run_diag_pl!',
            'sas!',
            'saslog!',
            'sas_run_args=s@',
	    'other_sim_build!',
            'sim_build_args=s@',
            'other_sim_build_cmd=s',
	    'other_sim_run!',
            'sim_run_args=s@',
            'other_sim_run_cmd=s',
            'sim_type=s',
            'sim_q_command=s',
            'sims_config=s',
            'simslog!',
            'simslog_name=s',
            'sjm!',
            'sjm_args=s@',
            'sjm_diag_name=s',
            'sjm_diag_path=s',
            'sjm_diag_root=s@',
            'spis_diag_name=s',
            'spis_diag_path=s',
            'spis_diag_root=s@',
            'start_dump=i',
            'stop_dump=i',
            'stub_mask=s',
            'sys=s',
            'tap_diag_name=s',
            'tap_diag_path=s',
            'tap_diag_root=s@',
	    'tcl_tap!',
	    'tcl_tap_diag=s',
            'tg_seed=i',
            'tmp_dir=s',
            'tarcopy!',
            'tpt_diag_name=s',
            'tpt_diag_path=s',
            'tpt_diag_root=s@',
            'use_auditr!',
            'use_config!',
            'use_denalirc=s',
            'use_oolm!',
            'use_sims_iver!',
            'vcd!',
            'vcdfile=s',
            'vcs_build!',
            'vcs_build_args=s@',
            'clean!',
            'vcs_cm_args=s',
            'vcs_cm_cond=s',
            'vcs_cm_config=s',
            'vcs_cm_fsmcfg=s',
            'vcs_cm_merge!',
            'vcs_cm_name=s',
            'vcs_finish=i',
            'vcs_prof!',
            'build_id=s',
            'vcs_run!',
            'vcs_use_2state!',
            'vcs_use_cli!',
            'vcs_use_cm!',
            'vcs_use_fsdb!',
            'vcs_use_initreg!',
            'vcs_use_ntb!',
            'vcs_use_rad!',
            'vcs_use_radincr!',
            'vcs_use_sdf!',
            'vcs_use_vcsd!',
            'vcs_use_vera!',
            'vera_build!',
            'vera_build_args=s@',
            'vera_clean!',
            'vera_config_name=s',
            'vera_config_path=s',
            'vera_config_root=s@',
            'vera_cov_obj=s@',
            'vera_diag_args=s@',
            'vera_dummy_diag=s',
            'vera_pal_diag_args=s@',
            'vera_diag_root=s@',
            'vera_diag_name=s',
            'vera_diag_path=s',
            'vera_proj_args=s@',
            'vera_run!',
            'vera_vcon_file=s',
            'verbose!',
            'vfile=s@',
            'vlint_args=s@',
            'vlint_run!',
            'vlint_top=s',
            'illust_run!',
            'illust_args=s@',
            'verix_args=s@',
            'verix_libs=s@',
            'verix_run!',
            'verix_top=s',
            'wait_cycle_to_kill=i',
            'zeroIn_build!',
            'zeroIn_dbg_args=s@',
            'zeroInSearch_build!',
            'zeroIn_checklist!',
            'zeroIn_build_args=s@',
            'num_tile=s',
            'x_tiles=s',
            'y_tiles=s',
            'dynamic_csm=s',
            'gui!',
            'debug_all!',
            'ibm!',
            'xilinx!',
            'ml605!',
            'artix7!',
            'vc707!',
            'ed_enable!',
            'ed_sync_method=s',
            'slurm!',
            'dmbr!',
            'dmbr_checker!',
            'oram!',
           );

  # print out all command line arguments + config arguments
  # if debugging is enabled

  if ($opt_debug)
  {
    print "Command Line Arguments:\n" ;
    print "Key  Value\n" ;

    foreach my $key (keys %opt)
    {
      if (defined $opt{$key})
      {
        if (ref ($opt{$key}) eq "ARRAY")
        {
          print "$key  @{$opt{$key}}\n" ;
        }
        elsif (ref ($opt{$key}) eq "SCALAR")
        {
          print "$key  ${$opt{$key}}\n";
        }
        else
        {
          print "$key  $opt{$key}\n";
        }
      }
    }

    print "\@ARGV: @ARGV\n" ;
  }


  my @configurables = (
    "config_l1i_size",
    "config_l1i_associativity",
    "config_l1d_size",
    "config_l1d_associativity",
    "config_l15_size",
    "config_l15_associativity",
    "config_l2_size",
    "config_l2_associativity",
    );

  foreach my $config (@configurables) {
    GetOptions (\%opt,
            "${config}=s",
    );
    my $ucn = uc($config);
    if ($opt{$config}) {
        $ENV{$ucn} = $opt{$config};
    }
  }

  $ENV{PROTOSYN_RUNTIME_DESIGN_PATH} = $ENV{DV_ROOT} . "/verif/env/manycore";
  $ENV{PROTOSYN_RUNTIME_BOARD} = "";

  # these arguments may not have any options associated with them

  foreach my $x (@ARGV)
  {
    if ($x =~ /\.s/) { $opt{asm_diag_name} = $x  ; }
    elsif ($x =~ /\.pal/) { $opt{asm_diag_name} = $x ; }
    elsif ($x =~ /\.s\.gz/) { $opt{asm_diag_name} = $x ; }
    elsif ($x =~ /\.tpt/) { $opt{tpt_diag_name} = $x ; }
    elsif ($x =~ /\.tap/) { $opt{tap_diag_name} = $x ; }
    elsif ($x =~ /\.image/) { $opt{image_diag_name} = $x ; }
    elsif ($x =~ /\.vrpal/) { $opt{vera_diag_name} = $x ; }
    elsif ($x =~ /\.vr/) { $opt{vera_diag_name} = $x ; }
    elsif ($x =~ /\.dat/) { $opt{efuse_image_name} = $x ; }
    else { die ("DIE. Unprocessed argument: $x") ; }
  }

  # Override the vera diag name if not specified and dummy is specified
  if (($opt{vera_dummy_diag} ne "" ) and ($opt{vera_diag_name} eq "")){
    print "$prg: using vera dummy diag $opt{vera_dummy_diag}\n";
    $opt{vera_diag_name} = $opt{vera_dummy_diag};
  }

  # expand environment variables
  $opt{env_base} =~ s/\$(\w+)/$ENV{$1}/g ;

  # if -nobuild specified disable all build options
  if ($opt{build} == 0)
  {
    $opt{vcs_build} = 0 ;
    $opt{ncv_build} = 0 ;
    $opt{icv_build} = 0 ;
    $opt{other_sim_build} = 0 ;
    $opt{vera_build} = 0 ;
    $opt{zeroIn_build} = 0 ;
    $opt{zeroInSearch_build} = 0 ;
  }

  # generate a random number generator seed if not specified
  # $opt{tg_seed} = int(rand (hex("ffffffff"))) if ($opt{tg_seed} == -1) ;

  if ($opt{tg_seed} == -1)
  {
    my $seed ;
    open (RANDOM, "< /dev/random") or die "DIE. Could not open /dev/random" ;
    sysread (RANDOM, $seed, 4) ;
    close (RANDOM) ;
    $opt{tg_seed} =  int(unpack ("L*", $seed)) ;
    if ($opt{tg_seed} == 0) {
        $opt{tg_seed} = int(rand(hex("ffffffff")));
    }
  }

  if (!$opt{pal_use_tgseed}) {
    $opt{tg_seed} = 0;
  }
  print "$prg: using random seed $opt{tg_seed}\n" ;

  # let ntb over ride vera so users can try NTB from the command line w/o having
  # to edit the bench config file.
  if ($opt{vcs_use_ntb} and $opt{vcs_use_vera}) {
    undef $opt{vcs_use_vera};
    undef $opt{vera_run};
  }

  # PITON flag: disables PLL if sim_pll is not set
  push (@{$opt{config_rtl}}, "USE_FAKE_PLL_AND_CLKMUX");
  # Disable IOs
  push (@{$opt{config_rtl}}, "USE_FAKE_IOS");

  # set up network_config defines
  if ($opt{network_config}) {
    if (($opt{network_config} eq "xbar_config") or ($opt{network_config} eq "2dmesh_config")) {
      $ENV{PTON_NETWORK_CONFIG}=$opt{network_config};
    }
    else {
      die ("DIE. network_config can only be xbar_config or 2dmesh_config");
    }
  }
  else {
    print "network_config not specified, assuming 2dmesh configuration";
    $ENV{PTON_NETWORK_CONFIG}="2d_mesh";
  }

  die ("DIE. -pico and -pico_het cannot both be set") if ($opt{pico} && $opt{pico_het}) ;
  $ENV{PITON_PICO}=$opt{pico};
  $ENV{PITON_PICO_HET}=$opt{pico_het};
  push (@{$opt{config_rtl}}, "PITON_PICO") if ($opt{pico});
  push (@{$opt{config_rtl}}, "PITON_PICO_HET") if ($opt{pico_het});

  # conveniently sets up the tile RTL defines for manycore model
  if ($opt{x_tiles} && $opt{y_tiles}) {

    die ("DIE. x_tiles can be at most 256") if ($opt{x_tiles} > 256) ;
    die ("DIE. y_tiles can be at most 256") if ($opt{y_tiles} > 256) ;

    for (my $i = 0; $i < ($opt{x_tiles} * $opt{y_tiles}); $i++) {
        if ($opt{pico} || ($opt{pico_het} && ($i % 2 == 1))) {
            push (@{$opt{config_rtl}}, "RTL_PICO" . $i);
	}
        else {
            push (@{$opt{config_rtl}}, "RTL_SPARC" . $i);
        }
    }
    my $pton_num_tiles=($opt{x_tiles} * $opt{y_tiles});

    $ENV{PTON_X_TILES}=$opt{x_tiles};
    $ENV{PTON_Y_TILES}=$opt{y_tiles};
    $ENV{PTON_NUM_TILES}=$pton_num_tiles;
    if($opt{dynamic_csm}) {
        $ENV{PTON_DYNAMIC_CSM}=$opt{dynamic_csm};
        push (@{$opt{midas_args}}, "-DDYNAMIC_CSM=$opt{dynamic_csm}");
    }
    else {
        $ENV{PTON_DYNAMIC_CSM}=0;
    }

    push (@{$opt{midas_args}}, "-DPTON_X_TILES=$opt{x_tiles}");
    push (@{$opt{midas_args}}, "-DPTON_Y_TILES=$opt{y_tiles}");
    push (@{$opt{midas_args}}, "-DPTON_NUM_TILES=$pton_num_tiles");
  } else {
    print "x_tiles and y_tiles not defined, assuming x dimension is 8 wide\n" ;
    if (! $opt{num_tile}) {
        print "num_tile not defined, assuming just one tile\n" ;   
        $opt{num_tile} = 1;
    }
    
    for (my $i=0; $i < $opt{num_tile}; $i++) {
        # print "$i\n";
        if ($opt{pico} || ($opt{pico_het} && ($i % 2 == 1))) {
            push (@{$opt{config_rtl}}, "RTL_PICO" . $i);
	}
        else {
            push (@{$opt{config_rtl}}, "RTL_SPARC" . $i);
        }
    }
    my $pton_x_tiles=(($opt{num_tile}-1)%8)+1;
    my $pton_y_tiles=(($opt{num_tile}-1)/8)+1;
    my $pton_num_tiles=$opt{num_tile};

    $ENV{PTON_X_TILES}=$pton_x_tiles;
    $ENV{PTON_Y_TILES}=$pton_y_tiles;
    $ENV{PTON_NUM_TILES}=$pton_num_tiles;
    if($opt{dynamic_csm}) {
        $ENV{PTON_DYNAMIC_CSM}=$opt{dynamic_csm};
        push (@{$opt{midas_args}}, "-DDYNAMIC_CSM=$opt{dynamic_csm}");
    }
    else {
        $ENV{PTON_DYNAMIC_CSM}=0;
    }

    push (@{$opt{midas_args}}, "-DPTON_X_TILES=$pton_x_tiles");
    push (@{$opt{midas_args}}, "-DPTON_Y_TILES=$pton_y_tiles");
    push (@{$opt{midas_args}}, "-DPTON_NUM_TILES=$pton_num_tiles");
    # die("TRITEST");
  }

  # Alexey: set default value for UART_DIV_LATCH define
  if (index("@{$opt{midas_args}}", "UART_DIV_LATCH") == -1) {
    print "Setting UART_DIV_LATCH to 0xb\n";
    push (@{$opt{midas_args}}, "-DUART_DIV_LATCH=0xb");
  }

  #
  push (@{$opt{sim_run_args}}, "-gui") if ($opt{gui}) ;
  push (@{$opt{vcs_build_args}}, "-debug_all") if ($opt{debug_all}) ;

  # Push optional execution drafting enable
  push (@{$opt{midas_args}}, "-DED_ENABLE") if ($opt{ed_enable});

  # Push optional execution drafting sync method
  if ($opt{ed_sync_method})
  {
    push (@{$opt{midas_args}}, "-DED_SYNC_METHOD_STSM") if ($opt{ed_sync_method} eq "stsm");
    push (@{$opt{midas_args}}, "-DED_SYNC_METHOD_RTSM") if ($opt{ed_sync_method} eq "rtsm");
    push (@{$opt{midas_args}}, "-DED_SYNC_METHOD_HTSM") if ($opt{ed_sync_method} eq "htsm");
  }

  # Push optional dmbr enable
  push (@{$opt{midas_args}}, "-DDMBR_ENABLE") if ($opt{dmbr});
}

################################################################################
# get options from the diaglist if necessary
################################################################################

sub get_opt_from_diaglist
{
    # put the pre-processed diaglist in here

    die ("DIE. Diag list $diaglist not found") if (! -f $diaglist) ;

    print "$prg: processing diaglist ($diaglist)..\n" ;
    my $diagcppargs = join(' ', @{$opt{diaglist_cpp_args}});
    system ("bw_cpp -B -undef $diagcppargs -I$dv_root/verif/diag $diaglist > master_diaglist") ;
    die  ("DIE. Could not pre-process the master_diaglist") if ($?) ;

    # open the diaglist and look for the group in it

    my $diagList = DiagList->new ("master_diaglist") ;
    my $group = $diagList->find_group (${$opt{group}} [0]) ;

    die ("DIE. Group name $opt{group} not found in diag list $diaglist") if (! defined $group) ;

    my @tags =  $group->build_tags () ;

    die ("DIE. Group name $opt{group} corrresponds to multiple build tags") if ($#tags > 0) ;

    my $tag = $tags [0] ;
    my $buildargs = $diagList->build_args ($tag) ;
    my ($sys) = ($buildargs =~ /sys\s*=\s*([a-z0-9_]+)\s*/i) ;

    foreach my $diagname ($group->list_diags($tag))
    {
      my $diag    = $group->find_diag($tag, $diagname) ;
      my $alias = $diag->get_name () ;

      if ($alias eq $opt{alias})
      {
        my @runargs = $diag->get_cmd_argv() ;
        print "$prg: found alias $alias with arguments -sys=$sys @runargs\n" ;

        unshift (@ARGV, "-sys=$sys") ;
        unshift (@ARGV, @runargs) ;
        return ;
      }
    }

    die ("DIE. The alias $opt{alias} could not be found in the diaglist") ;
}

################################################################################
# format 64bit dump_start/stop time into t+ht
################################################################################

sub bigtime2plus
{
    use Math::BigInt;
    my $time = shift;
    my $btime = Math::BigInt->new($time);
    return (($btime&4294967295)."+".($btime>>32));

}

################################################################################
# VCS Solaris 10 workaround setup
################################################################################

sub vcs_s10_setup
{
    my $os_ver = `uname -r`;
    my $os_cpu = `uname -p`;
    $os_ver =~ s/\n//g;
    $os_cpu =~ s/\n//g;
    if (($os_ver eq "5.10") and ($os_cpu eq "sparc"))
    {
	print "Adding workaround for VCS/Solaris 10\n";
	$ENV{_UNAME_RELEASE} = "5.9";
	my $fake_lib = $ENV{DV_ROOT};
	$fake_lib .=  "/tools/SunOS/sparc/lib/fake_uname.so";
	$ENV{LD_PRELOAD} =  $fake_lib;
    }
}

sub usage
{

print <<EOF;

NAME

sims - Verilog rtl simulation environment and regression script

SYNOPSIS

 sims [args ...]
  where args are:

NOTE: Use "=" instead of "space" to separate args and their options.

SIMULATION ENV

    -sys=NAME
            sys is a pointer to a specific testbench configuration
            to be built and run. a config file is used to associate
            the sys with a set of default options to build the
            testbench and run diagnostics on it. the arguments
            in the config file are the same as the arguments passed
            on the command line.

    -group=NAME
            group name identifies a set of diags to run in a
            regression. The presence of this argument indicates
            that this is a regession run. the group must be found
            in the diaglist. multiple groups may be specified to be
            run within the same regression.

    -group=NAME -alias=ALIAS
            this combination of options gets the diag run time options
            from the diaglist based on the given group and alias.
            the group must be found in the diaglist. the alias is
            made up of diag_alias:name_tag. only one group should be
            specified when using this command format.

OPENPITON ARGUMENTS
    
    -sys=manycore -x_tiles=X -y_tiles=Y
            this combination of options for the "manycore" simulation
            model specifies a 2D mesh topology of tiles, with X tiles
            in the x dimension and Y tiles in the y dimension. If 
            -x_tiles and -y_tiles is not specified, the default is
            X=1 and Y=1. The maximum value for both X and Y is 1024.
    
    -ed_enable
            enable Execution Drafting in each core.

    -ed_sync_method=SYNC_METHOD
            sets the Execution Drafting thread synchronization method (TSM)
            to SYNC_METHOD.  Possible values for SYNC_METHOD are "rtsm",
            "stsm", or "htsm".  The default is "stsm".  Please refer to
            the Execution Drafting paper or OpenPiton documentation for
            more information on TSMs.

    -ibm
            use simulation models from the IBM SRAM compiler.  These are not
            provided with the OpenPiton download, but if the user has access
            to download them, there is infrastructure for them to be dropped
            in and used.  Please refer to the OpenPiton documentation for more
            information on this option.

    -xilinx
            use simulation models from Xilinx IP, e.g. BRAMS, clock gen, etc.,
            to simulate the FPGA version of OpenPiton.  The Xilinx IP is
            not provided with the OpenPiton download, but if the user has access
            to download them, there is infrastructure for them to be dropped in
            and used.  If you are planning to synthesize OpenPiton to an FPGA,
            it recommended to use this option for simulation.  Please refer to
            the OpenPiton documentation for more information on this option.

    -ml605
            use block memories generated by ISE tools, required for ML605
            evaluation board. Can be used only in conjunction with -xilinx option.

    -artix7
            use block memories generated by Vivado tool chain, required for Artix7
            evaluation board. Can be used only in conjunction with -xilinx option.

    -vc707
            use block memories generated by Vivado tool chain, required for Xilinx VC707 
            evaluation board. Can be used only in conjunction with -xilinx option.

    -debug_all
            a shortcut for -vcs_build_args=-debug_all.  In Synopsys VCS, this
            causes the simulation model to be built with the -debug_all flag.
            This allows for the simulation to be run in the DVE environment,
            convenient for waveform viewing and debugging.

    -gui
            a shortcut for -sim_run_args=-gui.  In Synopsys VCS, this causes
            the simulation to be run within the DVE environment, convenient
            for waveform viewing and debugging.  When building the simulation
            model specified by the -sys option, the -debug_all argument
            must have been passed to sims.

    -slurm -sim_q_command=sbatch
            specifies simulations should be submitted with the Simple Linux
            Utility for Resource Management (SLURM) and run in parallel. The
            -sim_q_command=sbatch must also be specified. The -jobcommand_name
            argument may also be used to specify the job name.

VERILOG COMPILATION RELATED

    -sim_type=vcs/ncv/icv
	  defines which simulator to use vcs, ncverilog, or icarus, defaults to vcs.

    -sim_q_command="command"
	  defines which job queue manager command to use to launch jobs.
          Defaults to /bin/sh and runs simulation jobs on the local machine.

    -ncv_build/-noncv_build
           builds a ncverilog model and the vera testbench. defaults to off.

    -ncv_build_args=OPTION
           ncverilog compile options. multiple options can be specified using
           multiple such arguments.

    -icv_build/-noicv_build
           builds an icarus model and the vera testbench. defaults to off.

    -icv_build_args=OPTION
           icarus compile options. multiple options can be specified using
           multiple such arguments.

    -vcs_build/-novcs_build
           builds a vcs model and the vera testbench. defaults to off.

    -vcs_build_args=OPTION
           vcs compile options. multiple options can be specified using
           multiple such arguments.

    -clean/-noclean
           wipes out the model directory and rebuilds it from scratch.
           defaults to off.

    -vcs_use_2state/-novcs_use_2state
           builds a 2state model instead of the default 4state model.
           this defaults to off.

    -vcs_use_initreg/-novcs_use_initreg
           initialize all registers to a valid state (1/0).
           this feature works with -tg_seed to set the seed of the random
           initialization. this defaults to off.

    -vcs_use_fsdb/-novcs_use_fsdb
           use the debussy fsdb pli and include the dump calls in the
           testbench. this defaults to on.

    -vcs_use_vcsd/-novcs_use_vcsd
           use the vcs direct kernel interface to dump out debussy files.
           this defaults to on.

    -vcs_use_vera/-novcs_use_vera
           compile in the vera libraries. if -vcs_use_ntb and -vcs_use_vera
           are used, -vcs_use_ntb wins. this defaults to off.

    -vcs_use_ntb/-novcs_use_ntb
           enable the use of NTB when building model (simv) and running simv.
           if -vcs_use_ntb and -vcs_use_vera are used, -vcs_use_ntb wins.
           this defaults to off.

    -vcs_use_rad/-novcs_use_rad
           use the +rad option when building a vcs model (simv).
           defaults to off.

    -vcs_use_sdf/-novcs_use_sdf
           build vcs model (simv) with an sdf file.
           defaults to off.

    -vcs_use_radincr/-novcs_use_radincr
           use incremental +rad when building a vcs model (simv).
           defaults to off.
           this is now permanently disabled as synopsys advises against
           using it.

    -vcs_use_cli/-novcs_use_cli
           use the +cli -line options when building a vcs model (simv).
           defaults to off.

    -flist=FLIST
           full path to flist to be appended together to generate the
           final verilog flist. multiple such arguments may be used and
           each flist will be concatenated into the final verilog flist
           used to build the model.

    -graft_flist=GRAFTFILE
           GRAFTFILE is the full path to a file that lists each verilog
           file that will be grafted into the design. the full path to
           the verilog files must also be given in the GRAFTFILE.

    -vfile=FILE
           verilog file to be included into the flist

    -config_rtl=DEFINE
           each such parameter is place as a `define in config.v to
           configure the model being built properly. this allows
           each testbench to select only the rtl code that it needs
           from the top level rtl file.

    -model=NAME
           the name of a model to be built. the full path to a model
           is $ENV{MODEL_DIR}/model/build_id.

    -build_id=NAME
            specify the build id of the model to be built. the full path
            to a model is $ENV{MODEL_DIR}/model/build_id.

VERA COMPILATION RELATED

    VERA and NTB share all of the vera options except a few. See NTB RELATED.

    -vera_build/-novera_build
           builds the vera/ntb testbench. default on.

    -vera_clean/-novera_clean
           performs a make clean on the vera/ntb testbench before building
           the model. defaults to off.

    -vera_build_args=OPTION
           vera testbench compile time options. multiple options can be
           specified using multiple such commands. these are passed as
           arguments to the gmake call when building the vera testbench.

    -vera_diag_args=OPTION
           vera/ntb diag compile time options.
	   multiple options can be specified using multiple such arguments.

    -vera_dummy_diag=NAME
           this option provides a dummy vera diag name that will be
           overridden if a vera diag is specified, else used for vera
           diag compilation

    -vera_pal_diag_args=OPTION
           vera/ntb pal diag expansion options
	   (i.e. "pal OPTIONS -o diag.vr diag.vrpal")
	   multiple options can be specified using multiple such arguments.

    -vera_proj_args=OPTION
           vera proj file generation options. multiple options can be
           specified using multiple such arguments.

    -vera_vcon_file=ARG
           name of the vera vcon file that is used when running the simulation.

    -vera_cov_obj=OBJ
           this argument is passed to the vera Makefile as a OBJ=1 and to
           vera as -DOBJ to enable a given vera coverage object. multiple
           such arguments can be specified for multiple coverage objects.

NTB RELATED

    NTB and VERA share all of the vera options except these:

      -vcs_use_ntb/-novcs_use_ntb
             enable the use of NTB when building model (simv).
             if -vcs_use_ntb and -vcs_use_vera are used, -vcs_use_ntb wins.
             defaults to off.

      -ntb_lib/-nontb_lib
             enables the NTB 2 part compile where the Vera/NTB files get
             compiled first into a libtb.so file which is dynamically
             loaded by vcs at runtime. The libtb.so file is built by
             the Vera Makefile, not sims. Use the Makefile to affect the
             build. If not using -ntb_lib, sims will build VCS and NTB
             together in one pass (use Makefile to affect that build as
             well). default is off.


VERILOG RUNTIME RELATED

    -vera_run/-novera_run
           runs the vcs simulation and loads in the vera proj file
           or the ntb libtb.so file. defaults to on.

    -vcd/-novcd
           signals the bench to dump in VCD format

    -vcdfile=filename
           the name of the vcd dump file.  if the file name starts with
           a "/", that is the file dumped to, otherwise, the actual file is
           created under 'tmp_dir/vcdfile' and copied back to the current
           directory when the simulation ends.  use "-vcdfile=`pwd`/filename"
           to force the file to be written in the current directory directly
           (not efficient since dumping is done over network instead of to
           a local disk).

    -vcs_run/-novcs_run
           runs the vcs simulation (simv). defaults to off.

    -sim_run_args=OPTION
           sim runtime options. multiple options can be specified
           using multiple such arguments.

    -vcs_finish=TIMESTAMP
           forces vcs to finish and exit at the specified timestamp.

    -fast_boot/-nofast_boot
           speeds up booting when using the ciop model. this passes the
           +fast_boot switch to the simv run and the -sas_run_args=-DFAST_BOOT
           and -midas_args=-DFAST_BOOT to sas and midas. Also sends
           -DFAST_BOOT to the diaglist and config file preprocessors.

    -debussy/-nodebussy
           enable debussy dump. this must be implemented in the testbench
           to work properly. defaults to off.

    -start_dump=START
           start dumping out a waveform after START number of units

    -stop_dump=STOP
           stop dumping out a waveform after STOP number of units

    -fsdb2vcd
           runs fsdb2vcd after the simulation has completed to generate
           a vcd file.

    -fsdbfile=filename
           the name of the debussy dump file.
	   If the file name starts with a "/", that is the file dumped to,
	   otherwise, the actual file is created under 'tmp_dir/fsdbfile'
	   and copied back to the current directory when the simulation ends.
	   Use "-fsdbfile=`pwd`/filename" to force the file to be
	   written in the current directory directly (not efficient since
	   dumping is done over network instead of to a local disk).

    -fsdbDumplimit=SIZE_IN_MB
	   max size of Debussy dump file.  minimum value is 32MB.
	   Latest values of signal values making up that size is saved.

    -fsdb_glitch
           turn on glitch and sequence dumping in fsdb file. this will collect
           glitches and sequence of events within time in the fsdb waveform.
           beware that this will cause the fsdb file size to grow significantly.
           this is turned off by default. this option effectively does this:
           setenv FSDB_ENV_DUMP_SEQ_NUM 1
           setenv FSDB_ENV_MAX_GLITCH_NUM 0

    -rerun
           rerun the simulation from an existing regression run directory.

    -post_process_cmd=COMMAND
           post processing command to be run after vcs (simv) run completes

    -pre_process_cmd=COMMAND
           pre processing command to be run before vcs (simv) run starts

    -use_denalirc=FILE
          use FILE as the .denalirc in the run area. Default copies
          'env_base/.denalirc'

VLINT OPTIONS

         -vlint_run/-novlint_run
                runs the vlint program. defaults to off.

         -vlint_args
                vlint options. The <sysName>.config file can contain
                the desired vlint arguments, or they can also be given on
                the command line.  Typically the -vlint_compile is given
                on the command line.

                vlint also requires identification of a rules deck.

         -illust_run
                run illust after x2e

         -illust_args
                illust options

	-vlint_top
                top level module on which to run vlint

VERIX OPTIONS

    -verix_run/-noverix_run
           runs the verix program. defaults to off.

    -verix_libs
           specify the library files to add to the vlist

    -verix_args
           verix template options. The <sysName>.config file can contain
           these desired verix arguments

           verix also requires <top>.verix.tmplt in the config dir.

    -verix_top
           top level module on which to run verix


ZEROIN RELATED

    -zeroIn_checklist
           run 0in checklist

    -zeroIn_build
           build 0In pli for simulation into vcs model

    -zeroInSearch_build
           build 0in search pli for simulation into vcs model

    -zeroIn_build_args
           additional arguments to be passed to the 0in command

    -zeroIn_dbg_args
           additional debug arguments to be passed to the 0in shell

SAS/SIMICS RELATED

    -sas/-nosas
           run architecture-simulator. If vcs_run option is OFF,
           simulation is sas-only. If vcs_run option is ON, sas
           runs in lock-step with rtl. default to off.

    -sas_run_args=DARGS
           Define arguments for sas.

TCL/TAP RELATED

    -tcl_tap/-notcl_tap
           run tcl/expect TAP program. If vcs_run option is OFF,
           simulation is tcl-only. If vcs_run option is ON, tcl
           runs in lock-step with rtl. default to off.
	   NOTE: You _must_ compile with -tcl_tap as well, to enable
		 to enable functions that are needed for running with tcl

    -tcl_tap_diag=diagname
           Define top level tcl/expect diag name.

MIDAS

midas is the diag assembler

    -midas_args=DARGS
           arguments for midas. midas creates memory image and user-event
           files from the assembly diag.

    -midas_only
           Compile the diag using midas and exit without running it.

    -midas_use_tgseed
           Add -DTG_SEED=tg_seed to midas command line. Use -tg_seed to
           set the value passed to midas or use a random value from /dev/random.

PCI

pci is the pci bus functional model

    -pci_args
           arguments to be passed in to pci_cmdgen.pl for generation of a pci
           random diagnostic.

    -pci/-nopci
           generates a random pci diagnostic using the -tg_seed if provided.
           default is off.

    -tg_seed
           random generator seed for pci random test generators
           also the value passed to +initreg+ to randomly initialize registers
           when -vcs_use_initreg is used.

SJM

sjm is the Jbus bus functional model

    -sjm_args
           arguments to be passed in to sjm_tstgen.pl for generation of an sjm
           random diagnostic.

    -sjm/-nosjm
           generates a random sjm diagnostic using the -tg_seed if provided.
           default is off.

    -tg_seed
           random generator seed for sjm random test generators
           also the value passed to +initreg+ to randomly initialize registers
           when -vcs_use_initreg is used.

EFCGEN

efcgen.pl is a script to generate efuse.img files (default random),
which is used by the efuse controller after reset.
It is invoked by -efc.

    -efc/-noefc
           generates an efuse image file using the -tg_seed if provided.
           default is off.  Random if no -efc_args specified.

    -efc_args
           arguments to be passed in to efcgen.pl for generation of
	   an efuse image file.
	   Default is random efuse replacement for each block.

    -tg_seed
           random generator seed for efcgen.pl script
           also the value passed to +initreg+ to randomly initialize
	   registers when -vcs_use_initreg is used.

VCS COVERMETER

    -vcs_use_cm/-novcs_use_cmd
           passes in the -cm switch to vcs at build time and simv at runtime
           default to off.

    -vcs_cm_args=ARGS
           argument to be given to the -cm switch

    -vcs_cm_cond=ARGS
           argument to be given to the -cm_cond switch.

    -vcs_cm_config=ARGS
           argument to be given to the -cm_hier switch

    -vcs_cm_fsmcfg=ARGS
           argument to be given to the -cm_fsmcfg switch
	   specifies an FSM coverage configuration file

    -vcs_cm_name=ARGS
           argument to be given to the -cm_name switch. defaults to cm_data.

DFT

    -dftvert
          modifies the sims flow to accomodate dftvert. this skips compiling
          the vera testbench and modifies the simv command line at runtime.

MISC

    -nobuild
          this is a master switch to disable all building options.
          there is no such thing as -build to enable all build options.

    -copyall/-nocopyall
          copy back all files to launch directory after passing
	  regression run.  Normally, only failing runs cause a
	  copy back of files.
	  Default is off.

    -copydump/-nocopydump
          copy back dump file to launch directory after passing
	  regression run.  Normally, only failing runs cause a copy
	  back of non-log files.  The file copied back is sim.fsdb,
	  or sim.vcd if -fsdb2vcd option is set.
	  Default is off.

    -tarcopy/-notarcopy
          copy back files using 'tar'. This only works in copyall or
          in the case the simulations 'fails' (per sims' determination).
          Default is to use 'cp'.

    -diag_pl_args=ARGS
          If the assembly diag has a Perl portion at the end, it
	  is put into diag.pl and is run as a Perl script.
	  This allows you to give arguments to that Perl script.
	  The arguments accumulate, if the option is used multiple
	  times.

    -pal_use_tgseed
           Send '-seed=<tg_seed_value> to pal diags.  Adds
           -pal_diag_args=-seed=tg_seed to midas command line, and
           -seed=tg_seed to pal options (vrpal diags). Use -tg_seed to set
           the value passed to midas or use a random value from /dev/random.

    -parallel
            when specifying multiple groups for regressions this switch will
            submit each group to Job Q manager to be executed as a
            separate regression. This has the effect of speeding up
            regression submissions.
            NOTE: This switch must not be used with -injobq

    -reg_count=COUNT
            runs the specified group multiple times in regression mode. this
            is useful when we want to run the same diag multiple times using
            a different random generator seed each time or some such.

    -regress_id=ID
            specify the name of the regression

    -report
            This flag is used to produce a report of a an old or running
            regression. With -group options, sims produces the report
            after the regression run. Report for the previous
            regression run can be produced using -regress_id=ID
            option along with this option,

    -finish_mask=MASK
           masks for vcs simulation termination. Simulation terminates
           when it hits 'good_trap' or 'bad_trap'. For multithread
           simulation, simulation terminates when any of the thread
           hits bad_trap, or all the threads specified by the finish_mask
           hits the good_trap.
           example: -finish_mask=0xe
           Simulation will be terminated by good_trap, if thread 1, 2 and
           3 hits the good_trap.

    -stub_mask=MASK
           mask for vcs simulation termination. Simulation ends when the
           stub driving the relevant bit in the mask is asserted. This
           is a hexadecimal value similar to -finish_mask

    -wait_cycle_to_kill=VAL
           passes a +wait_cycle_to_kill to the simv run. a testbench
           may chose to implement this plusarg to delay killing a
           simulation by a number of clock cycles to allow collection
           of some more data before exiting (e.g. waveform).

    -rtl_timeout
           passes a +TIMEOUT to the simv run.
           sets the number of clock cycles after all threads have become
           inactive for the diag to exit with an error. if all threads hit
           good trap on their own the diag exits right away. if any of the
           threads is inactive without hitting good trap/bad trap the
           rtl_timeout will be reached and the diag fails. default is 5000.
           this is only implemented in the cmp based testbenches.

    -max_cycle
           passes a +max_cycle to the simv run.
           sets the maximum number of clock cycle that the diag will take
           to complete. the default is 30000. if max_cycle is hit the diag
           exits with a failure. not all testbenches implement this
           feature.

    -norun_diag_pl
           Does not run diag.pl (if it exists) after simv (vcs) run.
           Use this option if, for some reason, you want to run an
	   existing assembly diag without the Perl part that is in
	   the original diag.

    -nosaslog
           turns off redirection of sas stdout to the sas.log file.
           use this option when doing interactive runs with sas.

    -nosimslog
           turns off redirection of stdout and stderr to the sims.log file.
           use this option to get to the cli prompt when using vcs or to
           see a truncated sim.log file that exited with an error. this
           must be used if you want control-c to work while vcs is running.

    -nogzip
           turns off compression of log files before they are copied over
           during regressions.

    -version
            print version number.

    -help
            prints this

IT SYSTEM RELATED

    -use_iver=FILE
            full path to iver file for frozen tools

    -use_sims_iver
            For reruns of regression tests only, use sims.iver to choose
            TRE tool versions saved during original regression run

    -dv_root=PATH
            absolute path to design root directory. this overrides DV_ROOT.

    -model_dir=PATH
            absolute path to model root directory. this overrides MODEL_DIR.

    -tmp_dir=PATH
            path where temporary files such as debussy dumps will be created

    -sims_config=FILE
            full path to sims config file

    -env_base=PATH
            this specifies the root directory for the bench environment.
            it is typically defined in the bench config file. It has no
            default.

    -config_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the testbench configuration file is
            processed through cpp. Multiple options are concatenated
            together.

    -result_dir=PATH
            this allows the regression run to be launched from a different
            directory than the one sims was launced from. defaults to
            $ENV{PWD}.

    -diaglist=FILE
            full path to diaglist file

    -diaglist_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the diaglist file is processed through
            cpp. Multiple options are concatenated together.

    -asm_diag_name=NAME
    -tpt_diag_name=NAME
    -tap_diag_name=NAME
    -vera_diag_name=NAME
    -vera_config_name=NAME
    -efuse_image_name=NAME
    -image_diag_name=NAME
    -sjm_diag_name=NAME
    -pci_diag_name=NAME
            name of the diagnostic to be run.

    -asm_diag_root=PATH
    -tpt_diag_root=PATH
    -tap_diag_root=PATH
    -vera_diag_root=PATH
    -vera_config_root=PATH
    -efuse_image_root=PATH
    -image_diag_root=PATH
    -sjm_diag_root=PATH
    -pci_diag_root=PATH
            absolute path to diag root directory. sims will perform a find
            from here to find the specified type of diag. if more than one
            instance of the diag name is found under root sims exits with
            an error. this option can be specified multiple times to allow
            multiple roots to be searched for the diag.

    -asm_diag_path=PATH
    -tpt_diag_path=PATH
    -tap_diag_path=PATH
    -vera_diag_path=PATH
    -vera_config_path=PATH
    -efuse_image_path=PATH
    -image_diag_path=PATH
    -sjm_diag_path=PATH
    -pci_diag_path=PATH
            absolute path to diag directory. sims expects the specified
            diag to be in this directory. the last value of this option
            is the one used as the path.

ClearCase

    -clearcase
	  assume we are in ClearCase environment for setting DV_ROOT and
	  launching Job Q manager commands. default is off.

    -noclearcase
	  force clearcase option off

    -cc_dv_root=PATH
          ClearCase path to design root directory. this overrides
          $ENV{CC_DV_ROOT}.

ENV VARIABLES

sims sets the following ENV variables that may be used with pre/post
processing scripts, and other internal tools:

    ASM_DIAG_NAME   : Contains the assembly diag name.
    SIMS_LAUNCH_DIR : Path to launch directory where sims is running the
                      job.
    VERA_LIBDIR     : Dir where Vera files are compiled.

    DV_ROOT         : -dv_root if specifed
    MODEL_DIR       : -model_dir if specified
    TRE_SEARCH      : Based on -use_iver, -use_sims_iver
    DENALI          : User defined
    VCS_HOME        : User defined
    VERA_HOME       : User defined

PLUSARGS

+args are not implemented in sims. they are passed directly to vcs at
compile time and simv at runtime. the plusargs listed here are for
reference purposes only.

    +STACK_DIMM 32 bits physical address space - default is 31 bits

    +STACK_DIMM +RANK_DIMM 33 bits physical address space - default is 31 bits

    +max_cycle see -max_cycle

    +TIMEOUT   see -rtl_timeout

    +vcs+finish see -vcs_finish

    +wait_cycle_to_kill see -wait_cycle_to_kill

DESCRIPTION

sims is the frontend for vcs to run single simulations and regressions

HOWTO

Build models

Build a vcs model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_build

Build a ncverilog model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -ncv_build

Build an icarus model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -icv_build

Build the vera testbench only using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vera_build

Build a model from any design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 
       -vcs_build -dv_root=/home/regress/2002_06_03

Build a graft model from any design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 
       -vcs_build -dv_root=/model/2002_06_03 \
       -graft_flist=/regress/graftfile

Build a model and re-build the vera

  sims -sys=manycore -x_tiles=1 -y_tiles=1 
       -vcs_build -vera_clean

Build a model and turn off incremental compile

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_build -clean

Build a model with a given name

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_build -build_id=mymodel

Run models

Run a diag with default model

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_run diag.s

Run a diag with a specified model

  sims -sys=manycore -x_tiles=1 -y_tiles=1 
       -build_id=mymodel -vcs_run diag.s

Run a diag with debussy dump with default model

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -debussy 
       +dump=cmp_top:0 -vcs_run diag.s

Run regressions

Run a regression using DV_ROOT as design root

  sims -group=tile1_mini

Run a regression using DV_ROOT as design root and specify the diaglist

  sims -group=tile1_mini -diaglist=/home/user/my_dialist

Run a regression using any design root

  sims -group=tile1_mini -dv_root=/import/design/regress/model/2002_06_03

Run a regression using any design root and a graft model

  sims -group=tile1_mini -dv_root=/regress/model/2002_06_03 \
       -graft_flist=/home/regress/graftfile

EOF
}
__END__
