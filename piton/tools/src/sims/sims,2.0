# Modified by Princeton University on June 9th, 2015
# ========== Copyright Header Begin ==========================================
#
# OpenSPARC T1 Processor File: sims,1.262
# Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
#
# The above named program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License version 2 as published by the Free Software Foundation.
#
# The above named program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this work; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ========== Copyright Header End ============================================

################################################################################
# Verilog run/build/regression script
# sims -help for help
#
#                           sims
#                             |
#                         +--------+--------+------------+--------+
#                         |        |        |            |        |
#                         |      injobq  interactive     help   version
#                         |        |        |
#                         |<-------+--------+
#                         |
#                       normal
#                         |
#            +-------+--------+--------+
#            |       |        |        |
#           vcs    build    rerun     regr
#                                      |
#                                     build
#                                      |
#                                     injobq
#
#
################################################################################

use warnings;
use strict;

use Cwd;
use Cwd 'chdir';
use File::Basename ;
use File::Find ;
use File::Spec ;
use Getopt::Long ;
use TRELoad 'DiagList', 'Sims' => [':all'] ;
use Fcntl ':flock' ;
use Socket;

################################################################################
# patch PWD just in case
################################################################################

$ENV{PWD} = Cwd::cwd () ;
$| = 1 ;

################################################################################
# install signal handlers
################################################################################

# $SIG{INT} = \&sighandler ;
# $SIG{TERM} = \&sighandler ;
# $SIG{QUIT} = \&sighandler ;
$SIG{__DIE__} = \&sighandler ;

################################################################################
# declare all global variables
################################################################################

my $prg = $0 ;
$prg =~ s/.*\/// ;
my $version = $prg ;
$prg =~ s/,.*// ;          # name of this program
$version =~ s/.*,// ;      # tre version of script
my $pid = $$ ;             # process id of this job
my $opt_debug = 0 ;        # debug flag
my @argv_copy = @ARGV ;    # copy of original command line arguments
my $user = $ENV{USER} ;    # user name
my $work_dir = undef ;       # work directory
my $launch_dir = $ENV{PWD};  # work directory
my $home_dir = (exists $ENV{HOME}) ? $ENV{HOME} : "~";
my %opt = () ;             # all command line arguments
                           # + config file arguments are concatenated
                           # and stored here
my $sim_start ;            # date when sim started
my $sim_top ;              # date when sim stops
my $orig_tre_search = $ENV{TRE_SEARCH} ;
my $vcs_license_id = 0 ;   # oolm license ids

my $os_cpu_slash = `uname -s`;
$os_cpu_slash =~ s/\n//g;
$os_cpu_slash .= "/";
$os_cpu_slash .= `uname -m`;
$os_cpu_slash =~ s/\n//g;

my $os_cpu_dot = `uname -s`;
$os_cpu_dot =~ s/\n//g;
$os_cpu_dot .= ".";
$os_cpu_dot .= `uname -m`;
$os_cpu_dot =~ s/\n//g;

################################################################################
# configure Getopt::Long
################################################################################

# Getopt::Long::Configure ('debug') ;
Getopt::Long::Configure ('prefix=-') ;
Getopt::Long::Configure ('no_ignore_case') ;
Getopt::Long::Configure ('permute') ;
Getopt::Long::Configure ('pass_through') ;
Getopt::Long::Configure ('no_auto_abbrev') ;

################################################################################
# declare hash to hold command line arguments + config arguments
################################################################################

%opt = (
        'alias' => "",
        'asm_diag_name' => "",
        'asm_diag_path' => "",
        'asm_diag_root' => [],
        'build' => 1,
        'config_rtl' => [],
        'config_cpp_args' => [],
        'copyall' => 0,
        'debug' => \$opt_debug,
        'diaglist' => "",
        'diaglist_cpp_args' => [],
        'jobcommand_name' => "sim_command",
        'dryrun' => 0,
        'dv_root' => "",
        'fast_boot' => 0,
        'finish_mask' => "",
        'flist' => [],
        'gcc_args' => [],
        'group' => [],
        'group_name' => "",
        'gzip' => 1,
        'h' => 0,
        'help' => 0,
        'icv_build' => 0,
        'icv_build_args' => [],
        'icv_run' => 0,
        'image_diag_name' => "",
        'image_diag_path' => "",
        'image_diag_root' => [],
        'injobq' => -1,
        'max_cycle' => 0,
        'midas_args' => [],
        'midas_only' => 0,
        'midas_use_tgseed' => 0,
        'model' => "",
        'model_dir' => "",
        'msm_build' => 0,
        'msm_build_args' => [],
        'msm_run' => 0,
        'ncv_build' => 0,
        'ncv_build_args' => [],
        'ncv_run' => 0,
        'overwrite' => 0,
        'pal_use_tgseed' => 0,
        'parallel' => 0,
        'ost1' => 0,
        'ariane' => 0,
        'pico' => 0,
        'pico_het' => 0,
        'post_process_cmd' => [],
        'pre_process_cmd' => [],
        'reg_count' => 0,
        'regress' => 0,
        'regress_date' => "",
        'regress_id' => "",
        'regress_time' => "",
        'report' => 0,
        'rerun' => 0,
        'result_dir' => "",
        'riv_build' => 0,
        'riv_build_args' => [],
        'riv_run' => 0,		
        'rtl_timeout' => 5000,
        'run_diag_pl' => 1,
        'rv32' => 0,
        'rv32_mabi=s' => "",
        'rv32_march=s' => "",
        'rv32_target_triple=s' => "",
        'rv64' => 0,
        'rv64_mabi=s' => "",
        'rv64_march=s' => "",
        'rv64_target_triple=s' => "",
        'rv64_platform' => 0,
        'other_sim_build' => 0,
        'sim_build_args' => [],
        'other_sim_build_cmd' => "",
        'other_sim_run' => 0,
        'sim_run_args' => [],
        'other_sim_run_cmd' => "",
        'sim_type' => "vcs",
        'sim_q_command' => "/bin/sh",
        'sims_config' => "",
        'simslog' => 1,
        'simslog_name' => "sims.log",
        'sparcv9' => 0,
        'sys' => "",
        'tg_seed' => -1,
        'tmp_dir' => ".",
        'toplevel' => [],
        'tarcopy' => 0,
        'use_config' => 1,
        'vcs_build' => 0,
        'vcs_build_args' => [],
        'clean' => 0,
        'vcs_cm_args' => "",
        'vcs_cm_cond' => "",
        'vcs_cm_config' => "",
        'vcs_cm_fsmcfg' => "",
        'vcs_cm_merge' => 0,
        'vcs_cm_name' => "cm_data",
        'vcs_prof' => 0,
        'build_id' => "",
        'vcs_run' => 0,
        'vcs_use_cm' => 0,
        'vcs_use_cli' => 0,
        'vcs_use_initreg' => 0,
        'vlt_build' => 0,
        'vlt_build_args' => [],
        'vlt_run' => 0,
        'version' => 0,
        'vfile' => [],
        'mem_init_py' => ""
       );

################################################################################
# parse initial command line options
################################################################################

GetOptions (\%opt,
            'h!',
            'help!',
            'version!',
           ) ;

################################################################################
# print out version
################################################################################

if ($opt{version}) {
  print "$prg version: $version\n";
  exit (0);
}

################################################################################
# print out help
################################################################################

if ($opt{help} or $opt{h}) {
  &usage;
  exit (0);
}

################################################################################
# rerun a diag
################################################################################

GetOptions (\%opt,
            'overwrite!',
            'rerun!',
            'dryrun!',
            'dv_root=s',
           ) ;

if ($opt{rerun}) {
  &rerun () ;
  exit (0) ;
}


################################################################################
# define $dv_root
################################################################################

my $dv_root ;

if ($opt{dv_root} ne "") { $dv_root = $opt{dv_root} ; }
elsif (defined $ENV{DV_ROOT}) { $dv_root = $ENV{DV_ROOT} ; }
else { die ("DIE. could not initialize dv_root") ; }

$ENV{DV_ROOT} = $dv_root;

################################################################################
# if this diag must be run in Job Q Manager send ourselves back out
################################################################################

GetOptions (\%opt,
            'injobq!',
            'interactive!',
           ) ;

if (($opt{injobq} == 1) or $opt{interactive}) {
  run_injobq (\@argv_copy, []) ;
  exit (0) ;
}

################################################################################
# parse second set of command line options
################################################################################

GetOptions (\%opt,
            'alias=s',
            'config_cpp_args=s@',
            'debug' => \$opt_debug,
            'diaglist=s',
            'diaglist_cpp_args=s@',
            'group=s@',
            'model_dir=s',
            'parallel!',
            'ost1!',
            'ariane!',
            'pico!',
            'pico_het!',
            'sparcv9!',
            'rv32!',
            'rv64!',
            'rv64_platform!',
            'regress!',
            'regress_id=s',
            'report!',
            'result_dir=s',
            'sim_type=s',
            'sim_q_command=s',
            'sims_config=s',
            'simslog!',
            'simslog_name=s',
            'build_id=s',
            'sys=s',
           ) ;

die ("DIE. -ariane and -pico/-pico_het cannot be set simultaneously") if ($opt{ariane} && ($opt{pico} || $opt{pico_het})) ;
die ("DIE. -pico and -pico_het cannot both be set") if ($opt{pico} && $opt{pico_het}) ;

# Setting ost1 by default. This works better than default to 1
# for heterogeneous-ISA stuff
if ((!$opt{pico} && !$opt{ariane} && !$opt{ost1}) && ($opt{sys} eq "manycore")) {
  die ("DIE. Calling sims without specifying a core is no longer supported (you probably want to add -ariane, -ost1, or similar to your sims command)") ;
}

push (@{$opt{config_cpp_args}}, "-DFLIST_OST1")     if ($opt{ost1} || $opt{pico_het}) ;
push (@{$opt{config_cpp_args}}, "-DFLIST_PICO")     if ($opt{pico} || $opt{pico_het}) ;
push (@{$opt{config_cpp_args}}, "-DFLIST_ARIANE")   if ($opt{ariane}) ;
push (@{$opt{config_cpp_args}}, "-DFLIST_ORAM")     if ($opt{oram}) ;

push (@{$opt{diaglist_cpp_args}}, "-DSPARCV9")      if ($opt{ost1} || $opt{pico_het}) ;
push (@{$opt{diaglist_cpp_args}}, "-DRISCV32")      if ($opt{pico} || $opt{pico_het}) ;
push (@{$opt{diaglist_cpp_args}}, "-DRISCV64")      if ($opt{ariane}) ;

################################################################################
# define $result_dir
################################################################################

my $result_dir ;

if ($opt{result_dir} ne "") { $result_dir = $opt{result_dir} ; }
else { $result_dir = $ENV{PWD} ; }

################################################################################
# define $sims_config
################################################################################

my $sims_config ;

if ($opt{sims_config} ne "") { $sims_config = $opt{sims_config} ; }
else { $sims_config = "$dv_root/$proj_vars{sims_config}/sims.config" ; }

################################################################################
# define $model_dir
################################################################################

my $model_dir ;

if ($opt{model_dir} ne "") { $model_dir = $opt{model_dir} ; }
elsif (defined $ENV{MODEL_DIR}) { $model_dir = $ENV{MODEL_DIR}; }
else { die ("DIE. could not initialize model_dir") ; }

$ENV{MODEL_DIR} = $model_dir ;

################################################################################
# define $diaglist
################################################################################

my $diaglist ;

if ($opt{diaglist} ne "") {
  $diaglist = $opt{diaglist} ;

  if (!($diaglist =~ /^\//)) {
    $diaglist = "$ENV{PWD}/$diaglist" ;
  }
} else {
  $diaglist = "$dv_root/$proj_vars{diaglist}/master_diaglist" ;
}

################################################################################
# Check the env vars
################################################################################

if (defined $ENV{DRMJOBSCRATCHSPACE}) { $opt{tmp_dir} = $ENV{DRMJOBSCRATCHSPACE} ; }
elsif (-d "/var/tmp") { $opt{tmp_dir} = "/var/tmp"; }

################################################################################
# run a regression instead of a single diag
################################################################################

if (($#{$opt{group}} != -1) and ($opt{alias} eq ""))
{
  &regress();
  exit (0) ;
}

################################################################################
# get diag options from diaglist
################################################################################

if (($#{$opt{group}} != -1) and ($opt{alias} ne ""))
{
  &get_opt_from_diaglist () ;
}

################################################################################
# create the run area for the diag when in regression mode and cd there
################################################################################

if ($opt{regress})
{
  my $job_id = undef ;
  if (defined $ENV{SLURM_JOB_ID}) {
      $job_id = $ENV{SLURM_JOB_ID} ;
  } else {
      $job_id = int(rand(100000000)) ;
  }

  if (defined $ENV{DRMJOBSCRATCHSPACE}) { $work_dir = "$ENV{DRMJOBSCRATCHSPACE}/$opt{alias}:job${job_id}" ; }
  else { $work_dir = "$opt{tmp_dir}/${user}:$opt{alias}:$$:job${job_id}" ; }

  `mkdir -p $work_dir` ;
  die ("DIE. could not create directory $work_dir to run regression") if ($?) ;
  chdir "$work_dir" ;
}

################################################################################
# this is a regular vcs build run
################################################################################

GetOptions (\%opt,
            'sys=s',
           ) ;

################################################################################
#
################################################################################

&redirect () ;
&print_header () ;

################################################################################
# if this is not a regression a sys must be defined
################################################################################

die ("DIE. -sys argument not defined") if ($opt{sys} eq "") ;
&parse_args ($opt{sys}, 1) ;
print "$prg: group_name = $opt{group_name}\n" if ($opt{regress}) ;
print "$prg: regress_date = $opt{regress_date}\n" if ($opt{regress}) ;
print "$prg: regress_time = $opt{regress_time}\n" if ($opt{regress}) ;

################################################################################
# first check that the model and build_id are defined
################################################################################

die ("DIE. -model is not defined") if ($opt{model} eq "") ;

my $model_path ;

if ($opt{build_id} eq "") { $model_path = "$model_dir/$opt{model}/rel-0.1" ; }
else { $model_path = "$model_dir/$opt{model}/$opt{build_id}" ; }

################################################################################
# create the model area if necessary
################################################################################

&create_model_path () if ($opt{vcs_build} or $opt{other_sim_build} or
                          $opt{icv_build} or $opt{ncv_build} or
                          $opt{msm_build} or $opt{vlt_build} or
						  $opt{riv_build}) ;

################################################################################
# do some pre building stuff - generate flist
################################################################################

&pre_build () if ($opt{vcs_build} or $opt{other_sim_build} or
                  $opt{icv_build} or $opt{ncv_build} or
                  $opt{msm_build} or $opt{vlt_build} or
				  $opt{riv_build}) ;

################################################################################
# build the simulation model
################################################################################

&generic_sim_build () if ($opt{vcs_build} or $opt{ncv_build} or
                          $opt{icv_build} or $opt{other_sim_build} or
                          $opt{msm_build} or $opt{vlt_build} or
						  $opt{riv_build}) ;

################################################################################
# assemble .s diag
################################################################################

&assemble_diag () if ($opt{asm_diag_name} ne "") ;

################################################################################
# copy .image diag
################################################################################

&copy_image () if ($opt{image_diag_name} ne "") ;

&oram_image () if (($opt{vcs_run} or $opt{ncv_run} or
                    $opt{icv_run} or $opt{other_sim_run} or
                    $opt{msm_run} or $opt{vlt_run} or $opt{riv_run}) and
                    $opt{oram}); #if ($opt{image_diag_name}

################################################################################
# launch simulator
################################################################################

&generic_sim_run () if ($opt{vcs_run} or $opt{ncv_run} or
                        $opt{icv_run} or $opt{other_sim_run} or
                        $opt{msm_run} or $opt{vlt_run} or $opt{riv_run}) ;

################################################################################
# run diag.pl if present
################################################################################

if (    -e "diag.pl" and
  ( $opt{vcs_run} or $opt{ncv_run} or
      $opt{icv_run} or $opt{other_sim_run} or
      $opt{msm_run} or $opt{vlt_run} or $opt{riv_run}) and
       $opt{run_diag_pl} )
{
  print "$prg: executing diag.pl\n";

  if (!$opt{dryrun}) {
    my $waitstatus = call_program("$ENV{PERL_CMD} diag.pl", "diag_pl.log");
    print ("$prg: Warning diag.pl run exited with error\n") if ($waitstatus) ;
  }
}

################################################################################
# post process the output
################################################################################

&post_process if ($opt{vcs_run} or $opt{ncv_run} or
                  $opt{icv_run} or $opt{other_sim_run} or
                  $opt{msm_run} or $opt{vlt_run} or $opt{riv_run}) ;

&print_footer () ;

exit (0);

################################################################################
# run simulation in Job Q Manager
################################################################################

sub run_injobq
{
  my $argv_ref = shift ;
  my $drm_opt_ref = shift ;
  my @argv_copy = @ARGV ;
  # Save global options because they get modified by drm_opt ..
  my %opt_copy = %opt ;

  unshift (@ARGV, @{$drm_opt_ref}) ;

  GetOptions (\%opt,
              'jobcommand_name=s',
              'group=s',
              'slurm!',
             ) ;

  @ARGV = @argv_copy ;

  # create the Job Q Manager command
  `rm -rf $opt{jobcommand_name}` ;

  open (JOBCMD, "> $opt{jobcommand_name}") or die ("DIE. Could not open simulation command file") ;

  if ($opt{slurm}) {
    print JOBCMD "#!/bin/sh\n" ;
    print JOBCMD "#SBATCH -N 1                   # nodes=1\n" ;
    print JOBCMD "#SBATCH --ntasks-per-node=1    # ppn=1\n" ;
    print JOBCMD "#SBATCH --mem=2048              # mem=2GB\n" ;
    print JOBCMD "#SBATCH -t 3:20:00               # walltime=1hr6mins\n" ;
    print JOBCMD "#SBATCH -J  $opt{jobcommand_name} # jobname\n\n" ;
  }

  my $os = `uname -s`;
  $os =~ s/\n//g;

  print JOBCMD "$prg \\\n" ;

  foreach my $x (@{$argv_ref}) {
    next if (($x =~ /-injobq/) or ($x =~ /-interactive/));
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/));

    print JOBCMD "$x \\\n" ;
  }
  close (JOBCMD) ;

  `chmod 0777 $opt{jobcommand_name}` ;

  # submit to job Q manager
  my $job_submit = $opt{sim_q_command};

  my $cmd = $job_submit;
  $cmd .= " ";

  # $cmd .= "-m -i " if ($opt{interactive}) ;

  $cmd .= "$ENV{PWD}/$opt{jobcommand_name} " ;

  #system ($cmd) if (!($opt{dryrun})) ;
  #($output = `until $cmd; do echo "Submit failed"; sleep 30; done`) if (!($opt{dryrun})) ;

  if (!($opt{dryrun})) {
    my $returncode = system ($cmd) ;
    while ($returncode) {
      sleep 30;
      print "Submit failed" ;
      $returncode = system ($cmd) ;
    }
  }

  # Restore global options ..
  %opt = %opt_copy ;
}

################################################################################
# redirect all output to tee
################################################################################

sub redirect
{
  my $logfile = $opt{simslog_name} ;

  if ($opt{regress}) {
    $logfile = "$launch_dir/$opt{simslog_name}" ;
  }

  if ($opt{simslog}) {
    tee_stdout ($logfile) ;
    open(STDERR, ">&=STDOUT") or die "DIE. Could not make stderr an alias to stdout: $!";
  }
}

################################################################################
# tee stdout to log file
################################################################################

sub tee_stdout {
  my $file = shift;
  die "DIE. tee_stdout() called without a filename" unless defined $file;
  return if my $pid = open(STDOUT, '|-');
  die "DIE. Cannot fork when trying to tee stdout: $!" unless defined $pid;

  open(SIMSLOG, ">$file") or die "DIE.  Could not open $file for writing: $!";
  my $old_fh = select SIMSLOG;
  $| = 1;
  select $old_fh;
  $| = 1;
  while(<STDIN>) {
    print;
    print SIMSLOG;
  }
  exit(0);
}

################################################################################
# print out a header when sims starts
################################################################################

sub print_header
{
  # print "$prg @argv_copy\n";
  open (SIMS_HISTORY, ">> history.sims") ;
  my $date = `date` ;
  chomp ($date) ;

  print "$prg ";
  print SIMS_HISTORY "$date $prg ";

  foreach my $x (@argv_copy) {
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    print "$x " ;
    print SIMS_HISTORY "$x " ;
  }

  print "\n" ;
  print SIMS_HISTORY "\n" ;

  print "$prg: ====================================================\n";
  print "$prg:   Simulation Script for OpenPiton\n";
  print "$prg:   Modified by Princeton University on June 9th, 2015\n";
  print "$prg: ====================================================\n";

  print "$prg: ====================================================\n";
  print "$prg:   Simulation Script for OpenSPARC T1\n";
  print "$prg:   Copyright (c) 2001-2006 Sun Microsystems, Inc.\n";
  print "$prg:   All rights reserved.\n";
  print "$prg: ====================================================\n";

  print "$prg: start_time $date\n";
  print "$prg: running on ";
  system ("hostname") ;
  print "$prg: uname is ";
  system ("uname -a") ;
  print "$prg: version $version\n";
  print "$prg: dv_root $dv_root\n";
  print "$prg: model_dir $model_dir\n";
  print "$prg: tre_search $ENV{TRE_SEARCH}\n" ;
  print "$prg: Frozen tre_search $orig_tre_search\n" if (($#{$opt{group}} != -1) and ($opt{alias} eq "")) ;
  print "$prg: drmjobid $ENV{DRMRJSJOBOID}\n" if (defined $ENV{DRMRJSJOBOID}) ;
  print "\$RESULT_DIR=$result_dir\n" if $opt_debug ;
  print "\$DV_ROOT=$dv_root\n" if $opt_debug ;
  print "\$SIMS_CONFIG=$sims_config\n" if $opt_debug ;
  print "\$MODEL_DIR=$model_dir\n" if $opt_debug ;
  print "\$DIAGLIST=$diaglist\n" if $opt_debug ;
  print "\$TMP_DIR=$opt{tmp_dir}\n" if $opt_debug ;
  print "\$PWD=$ENV{PWD}\n" if $opt_debug ;
}

################################################################################
# print out a footer when sims ends
################################################################################

sub print_footer
{
  print "$prg: stop_time ";
  system ("date") ;
}

################################################################################
# regress subroutine
################################################################################

sub regress
{
  # figure out the name of the regression

  my $regress_date = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;
  my $regress_time = sprintf "%2.2d_%2.2d_%2.2d", (localtime) [2], (localtime) [1], (localtime) [0] ;

  my $regress_id ;
  if ($opt{regress_id} eq "") {
    $regress_id = $regress_date ;
    my $count = 0 ;
    while (-d "$result_dir/${regress_date}_${count}") {$count++;}
    $regress_id .= "_$count" ;
  } else {
    $regress_id = $opt{regress_id} ;
  }

  # create the directory where regression will be run
  system ("mkdir -p $result_dir/$regress_id") ;
  die  ("DIE. Could not create result area for regression") if ($?) ;

  chdir ("$result_dir/$regress_id") or die ("DIE. Could not change directory into $result_dir/$regress_id") ;

  # recreate a copy of all the tre files in this directory
  my $tre_search = &freeze_tre( "$result_dir/$regress_id" );
  $ENV{TRE_SEARCH} = $tre_search if $tre_search ne "";

  if ($opt{parallel}) {
    my @new_args = () ;

    foreach my $x (@argv_copy) {
      if ($x =~ /-group/)
      { }
      elsif ($x =~ /-parallel/)
      { }
      else {
        ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
        push (@new_args, $x) ;
      }
    }

    foreach my $gname (@{$opt{group}}) {
      my @cmd ;
      push (@cmd, "-result_dir=$result_dir") ;
      push (@cmd, "-regress_id=$regress_id") ;
      push (@cmd, "-group=$gname") ;
      push (@cmd, "-simslog_name=sims.$gname.log") ;
      push (@cmd, @new_args) ;

      my @drm_opt ;
      push (@drm_opt, "-jobcommand_name=drm_command_$gname") ;

      run_injobq (\@cmd, \@drm_opt) ;
      die  ("DIE. Could not launch group") if ($?) ;
    }

    exit (0) ;
  }

  &redirect () ;
  &print_header () ;

  @argv_copy = @ARGV ;

  # Pass the config_cpp_args through ..
  foreach my $x ( @{$opt{config_cpp_args}} ) {
    push(@argv_copy, "-config_cpp_args $x");
  }


  my $nobuild = 0 ;

  foreach my $x (@argv_copy) {
    $nobuild = 1 if ($x =~ /-nobuild/) ;
    if ($x =~ /-fast_boot/) {
      push (@{$opt{diaglist_cpp_args}}, "-DFAST_BOOT") ;
      push (@{$opt{config_cpp_args}}, "-DFAST_BOOT") ;
      push(@argv_copy, "-config_cpp_args -DFAST_BOOT");
    }
  }

  foreach my $gname (@{$opt{group}}) {
    # put the pre-processed diaglist in here
    die ("DIE. Diag list $diaglist not found") if (! -f $diaglist) ;

    my $diagcppargs = join(' ', @{$opt{diaglist_cpp_args}});
    print "$prg: processing diaglist $diaglist ($diagcppargs) ..\n" ;
    system ("bw_cpp -B $diagcppargs -undef -I$dv_root/verif/diag $diaglist > $result_dir/$regress_id/master_diaglist.$gname") ;
    die  ("DIE. Could not pre-process the master_diaglist") if ($?) ;

    # open the diaglist and look for the group in it

    my $diagList = DiagList->new ("$result_dir/$regress_id/master_diaglist.$gname") ;

    my $group = $diagList->find_group ($gname) ;

    die ("DIE. Group name $gname not found in diag list $diaglist") if (! defined $group) ;

    print "$prg: processing group $gname\n";
    foreach my $tag ($group->build_tags ()) {
      my $buildargs = $diagList->build_args ($tag) ;
      my ($sys) = ($buildargs =~ /sys\s*=\s*([a-z0-9_]+)\s*/i) ;

      # read the config file for this sys
      my @argv_config ;
      &get_config ($sys, \@argv_config) ;

      # extract the options from the config file
      my @dream_options  = () ;

      foreach my $x (@argv_config) {
        push (@dream_options, $x) if ($x =~ /\-drm\_/) ;
      }

      # figure out the name of the model build id
      my $build_id ;

      if (($opt{build_id} eq "") and ($nobuild == 0)) {
        $build_id = sprintf "%4.4d_%2.2d_%2.2d", 1900 + (localtime) [5], 1 + (localtime) [4], (localtime) [3] ;
        my $count = 0 ;
        open (MODEL_LOCK, "> lock") or die "DIE. Could not lock model" ;
        flock (MODEL_LOCK, LOCK_EX) ;
        while (-d "$model_dir/$sys/${tag}_${build_id}_${count}") {$count++;}
        $build_id = "${tag}_${build_id}_${count}" ;
        system ("mkdir -p $model_dir/$sys/$build_id") ;
        die "DIE. Could not create build_id for regression" if ($?) ;
        flock (MODEL_LOCK, LOCK_UN) ;
        close (MODEL_LOCK) ;
      } elsif ($opt{build_id} eq "") {
        $build_id = "rel-0.1" ;
      } else {
        $build_id = $opt{build_id} ;
      }

      # call sims to build this model
      my $cmd ;
      $cmd .= "$prg " ;
      $cmd .= "-nosimslog " ;
      if (($opt{sim_type}) eq "vcs") {
          $cmd .= "-vcs_build " ;
      } elsif (($opt{sim_type}) eq "ncv") {
          $cmd .= "-ncv_build " ;
      } elsif (($opt{sim_type}) eq "icv") {
          $cmd .= "-icv_build " ;
      } elsif (($opt{sim_type}) eq "msm") {
          $cmd .= "-msm_build " ;
      } elsif (($opt{sim_type}) eq "vlt") {
          $cmd .= "-vlt_build " ;
      } elsif (($opt{sim_type}) eq "riv") {
          $cmd .= "-riv_build " ;
      } else {
          $cmd .= "-other_sim_build " ;
      }
      $cmd .= "$buildargs " ;
      $cmd .= "-build_id=$build_id " ;

      foreach my $x (@argv_copy) {
        ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
        $cmd .= " $x " ;
      }

      $cmd .= " -novcs_run " ;

      my $rc = 0 ;
      print "$cmd\n" if $opt_debug ;
      if (! $opt{dryrun}) {
        system ($cmd) ; my $build_stat = $?;
        `cp -f $model_dir/$sys/$build_id/diff_rel.log $result_dir/$regress_id/diff_rel_$tag.log` if (-f "$model_dir/$sys/$build_id/diff_rel.log") ;
        die  ("DIE. Could not build model for regression") if ($build_stat) ;
      }

      chdir "$result_dir/$regress_id" or die  ("DIE. Could not cd to result area for regression") ;


      foreach my $diagname ($group->list_diags($tag))
      {
        my $diag    = $group->find_diag($tag, $diagname) ;
        my @runargs = $diag->get_cmd_argv() ;
        my @run_dream_options = @dream_options ;

        my @argv = @argv_copy ;
        unshift (@argv, @runargs) ;
        # unshift (@argv, @dream_options) ;

        foreach my $x (@runargs) {
          push (@run_dream_options, $x) if ($x =~ /\-drm\_/) ;
        }

        my $reg_count = 0 ;

        foreach my $x (@argv) {
          if ($x =~ /\-reg\_count/) {
            $reg_count = $x ;
            $reg_count =~ s/\-reg\_count=(.*)/$1/ ;
            $reg_count-- ;
          }
        }

        my $alias = $diag->get_full_name () ;

        while ($reg_count >= 0) {
          my $dirname = "$alias:$reg_count" ;

          `rm -rf $dirname` ;
          die  ("DIE. Could not remove diag area $dirname for regression") if ($?) ;
          `mkdir $dirname` ;
          die  ("DIE. Could not create diag area $dirname for regression") if ($?) ;

          chdir $dirname or die  ("DIE. Could not cd to diag area $dirname") ;

          my @cmd ;
          # push (@cmd, "$prg") ;
          if (($opt{sim_type}) eq "vcs") {
            push (@cmd, "-vcs_run") ;
          } elsif (($opt{sim_type}) eq "ncv") {
            push (@cmd, "-ncv_run") ;
          } elsif (($opt{sim_type}) eq "icv") {
            push (@cmd, "-icv_run") ;
          } elsif (($opt{sim_type}) eq "msm") {
            push (@cmd, "-msm_run") ;
          } elsif (($opt{sim_type}) eq "vlt") {
            push (@cmd, "-vlt_run") ;
          } elsif (($opt{sim_type}) eq "riv") {
            push (@cmd, "-riv_run") ;
          } else {
            push (@cmd, "-other_sim_run") ;
          }
          push (@cmd, "-sys=${sys}") ;
          push (@cmd, "-build_id=${build_id}") ;
          push (@cmd, "-regress_id=${regress_id}") ;
          push (@cmd, "-alias=${dirname}") ;
          push (@cmd, "-dv_root=${dv_root}") ;
          push (@cmd, "-model_dir=${model_dir}") ;
          push (@cmd, "-result_dir=${result_dir}") ;
          push (@cmd, "-sims_config=${sims_config}") ;
          push (@cmd, "-group_name=$gname") ;
          push (@cmd, "-regress_date=$regress_date") ;
          push (@cmd, "-regress_time=$regress_time") ;
          my $real_asm_diag_name = $dirname;
          $real_asm_diag_name =~ s/\:.*//;
          push (@cmd, "-vcs_cm_name=$real_asm_diag_name") ;
          # push (@cmd, "-vcs_cm_name=${dirname}") ;
          push (@cmd, @argv) ;
          push (@cmd, "-nobuild") ;
          # push (@cmd, "-novcs_build") ;
          push (@cmd, "-regress") ;

          # submit command Job Q manager

          print "$prg: ${dirname}\n" ;
          print ("$cmd\n") if ($opt_debug) ;
          # print (@cmd) ;

          if (! $opt{dryrun}) {
            # system ($cmd) ;
            if ($opt{injobq} != 0) {
              run_injobq (\@cmd, \@run_dream_options) ;
            } else {
              my $cmd = join (" ", @cmd) ;
              system ("$prg $cmd") ;
            }
          }

          $reg_count-- ;
          chdir ".." or die  ("DIE. Could not cd up to result directory") ;
        }
      }
    }
  }

  chdir "$result_dir" or die  ("DIE. Could not cd to result directory for regression report") ;
  if ($opt{report}) {
    print "$prg: launching regreport !!!\n" ;
    `regreport wait_sec=300 -regress $result_dir/$regress_id/regress.log $result_dir/$regress_id` ;
  }

  &print_footer () ;
}

################################################################################
# rerun a diag from the sims.log
################################################################################

sub rerun
{
  my $args = "" ;

  foreach my $x (@argv_copy) {
    next if ($x =~ /-rerun/) ;
    ($x =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($x =~ /\s/) and ($x !~ /-.*?="/)) ;
    $args .= " $x ";
  }

  if (! -f "sims.log") {die ("DIE. Could not find original run command");}

  open (CMD, "< sims.log") or die ("DIE. Could not open sims.log") ;
  my $cmd = <CMD> ;
  close (CMD) ;

  chomp $cmd ;
  $cmd =~ s/\s+-regress_id=\S+//g ;
  $cmd =~ s/\s+-regress_date=\S+//g ;
  $cmd =~ s/\s+-regress_time=\S+//g ;
  $cmd =~ s/\s+-regress//g ;
  $cmd =~ s/\s+-result_dir=\S+//g ;

  my @sims_tg_seed = `grep 'using random' sims.log` ;
  my $sims_tg_seed = $sims_tg_seed[0] ;
  $sims_tg_seed =~ s/.*?(\d+)/$1/ ;
  chomp $sims_tg_seed ;

  if (!$opt{overwrite}) {
    my $count = 0 ;
    while (-d "rerun_${count}") {$count++;}
    my $rerun_dir = "rerun_${count}" ;

    system ("mkdir -p $rerun_dir") ;
    die ("DIE. could not create rerun directory $rerun_dir") if ($?) ;

    chdir $rerun_dir or die ("DIE. could not change to rerun directory $rerun_dir") ;
  }

  if ( $sims_tg_seed ne "" ) {
      system ("$cmd -tg_seed=$sims_tg_seed $args") ;
  } else {
      system ("$cmd $args") ;
  }
}

################################################################################
# Generate the verilog config file
################################################################################

sub gen_config
{
  open (OCONF, ">config.v") or die ("DIE. can't open file config.v") ;

  print OCONF "`timescale 1ps/1ps\n" ;

  foreach my $unit (@{$opt{config_rtl}}) {
    print OCONF "`define $unit\n";
  }

  close (OCONF);
}

################################################################################
# Generate the flist file
################################################################################

sub gen_flist
{
  open (OFLIST, ">flist") or die ("DIE. can't open flist file") ;

  print OFLIST "$ENV{PWD}/config.v\n";

  foreach my $flist (@{$opt{flist}}) {
    $flist =~ s/\$(\w+)/$ENV{$1}/g ;

    # look for IBM flists
    if ($opt{ibm}) {
       my $ibmflist = $flist . ".ibm";
       if (-e $ibmflist) {
          $flist = $ibmflist;
          # print("debug: IBM flist found: $flist\n");
       }
    }

    open (IFLIST, "< $flist") or die ("DIE. can't open flist file $flist") ;

    print "$flist\n";

    while (<IFLIST>) {
      my $line = $_ ;
      my $base = dirname ($flist) ;

      $line =~ s/^\s*(.*?)\s*$/$1/ ;
      $line .= "\n" ;

      if (($line =~ /^\s*\/\//) or ($line =~ /^\s*$/)) {
        next ;
      }

      $line =~ s/\$(\w+)/$ENV{$1}/g ;

      if ($line =~ /^\+incdir\+\//)
      { }
      elsif ($line =~ /^\+incdir\+/) {
        $line =~ s/^\+incdir\+(.*)/\+incdir\+$base\/$1/ ;
      }
      elsif ($line =~ /^\-v\s\//)
      { }
      elsif ($line =~ /^\-v/) {
        $line =~ s/-v\s*(.*)/-v $base\/$1/ ;
      }
      elsif ($line =~ /^-y\s\//)
      { }
      elsif ($line =~ /^-y/) {
        $line =~ s/-y\s*(.*)/-y $base\/$1/ ;
      }
      elsif (($line =~ /^\+define/) or
             ($line =~ /^\+libext/) or
             ($line =~ /^\+librescan/))
      { }
      elsif ($line !~ /^\//) {
        $line = "$base/$line" ;
      }

      # Tri
      # Now we run pyphp

      my $ibmfile = (split(' ',substr($line, 0, -1)))[-1] . ".ibm.v";
      if ($opt{ibm} and -e $ibmfile) {
           $line = $ibmfile . "\n";
           # print("debug: IBM sram found: $line\n");
      } else {
        my $linepyv = (split(' ',substr($line, 0, -1)))[-1] . ".pyv";
        # print("\$linepyv is $linepyv\n");
        my $linetmp = substr($line, 0, -3) . ".tmp.". substr($line, -2, 1);
        my $linetmpout = (split(' ',substr($line, 0, -3)))[-1] . ".tmp." . substr($line, -2, 1);
        if (-e $linepyv) {
          # print("original is $line\n");
          !system("pyhp.py $linepyv > $linetmpout") or die("Error running PyHP for $linepyv\n");;
          $line = $linetmp . "\n";
        }
      }

      print OFLIST $line ;
    }

    close (IFLIST) ;
  }

  foreach my $file (@{$opt{vfile}}) {
    chomp $file ;
    $file =~ s/\$(\w+)/$ENV{$1}/g ;
    print OFLIST "$file\n" ;
  }

  close (OFLIST) ;
}

################################################################################
# if a signal is received do some cleanup - delete tmp directories
################################################################################

sub sighandler
{
  my $sig = shift ;

  print "$prg: Caught a SIG${sig}\n" ;

  `regreport -1 > status.log` ;

  if ($opt{regress}) {
    if ((defined ($work_dir)) and (-d "$work_dir")) {
      chdir $launch_dir ;
      `/bin/cp -r $work_dir/* $launch_dir` ;
      `/bin/rm -rf $work_dir` ;
      `/bin/rmdir $work_dir` ;
    }
  }

  exit (1) ;
}


################################################################################
# create model area
################################################################################

sub create_model_path
{
    my $cur_dir = $ENV{PWD};

    print "$prg: creating model directory $model_path\n" ;
    `mkdir -p $model_path` ;
    die ("DIE. could not create directory $model_path") if ($?) ;
    chdir ($model_path) or die ("DIE. Could not cd to $model_path") ;

    # clean up the model area as needed

    if ($opt{clean}) {
      print "$prg: cleaning up build directory\n" ;
      `rm -rf csrc simv.daidir simv AxisWork` ;
    }

    `mkdir -p lib` ;
    die ("DIE. could not create directory lib under $model_path") if ($?) ;

    # go back to where the script was invoked
    chdir $cur_dir ;
}

################################################################################
# pre build vcs code
################################################################################

sub pre_build
{
  my $cur_dir = $ENV{PWD};

  # go to the model area
  chdir $model_path or die ("DIE. Can't cd to $model_path\n") ;

  # generate the rtl config file
  &gen_config ($opt{model});

  # Generate the flist file
  &gen_flist ();

  system("cp -f flist $cur_dir");

  if($opt{rv64_platform}) {
    print "compiling rv64 DTS and bootroms...\n";
    !system("cd $ENV{DV_ROOT}/design/chipset/rv64_platform/bootrom/baremetal && make clean && make all && cd - > /dev/null") or
      die (" Error compiling rv64 DTS.");
    !system("cd $ENV{DV_ROOT}/design/chipset/rv64_platform/bootrom/linux && make clean && make all MAX_HARTS=$ENV{PITON_NUM_TILES} && cd - > /dev/null") or
      die (" Error compiling rv64 DTS.");
    print "done\n";
    # currently we have two sources (hardcoded in chipset_impl): UART and Ethernet
    my $num_sources = 2;
    # 2 targets per core (M/S mode)
    my $num_targets = 2 * $ENV{PITON_NUM_TILES};
    print "generating PLIC for rv64 platform with $num_targets targets and $num_sources sources...\n";
    !system("cd $ENV{ARIANE_ROOT}/corev_apu/rv_plic/rtl && ./gen_plic_addrmap.py -t $num_targets -s $num_sources > plic_regmap.sv") or
      die (" Error generating PLIC for rv64 platform.");
    print "done\n";
  }

  # go back to where this block was invoked
  chdir $cur_dir ;
}

################################################################################
# generic simulator build (incorporates vcs, ncv, icv, msm, vlt, other)
################################################################################

sub generic_sim_build
{
    my $cur_dir = $ENV{PWD};
    my $lib_path = "";
    my $build_cmd = "";
    my $ld_lib_path = "";

    # go to the model area
    chdir $model_path or die ("DIE. Can't cd to $model_path") ;

    if ($opt{vcs_build} or $opt{ncv_build}) {
      chomp(my $vcsd = "vcsd".$proj_vars{vcsprefix});
      $vcsd =~ s/(vcsd)vcs(\d+)\.(\d+).*/$1$2$3/;
      my $vcsd_tab = "vcsd.tab";

      # figure out the location of vcs from variable
      if ($opt{vcs_build}) {
        if (!defined($ENV{VCS_HOME})) { die ("DIE. VCS_HOME not defined.") }
        print "$prg: VCS_HOME is $ENV{VCS_HOME}\n";
      }
      if ($opt{ncv_build}) {
        if (!defined($ENV{NCV_HOME})) { die ("DIE. NCV_HOME not defined.") }
        print "$prg: NCV_HOME is $ENV{NCV_HOME}\n";
      }
      if ($opt{icv_build}) {
        if (!defined($ENV{ICARUS_HOME})) { die ("DIE. ICARUS_HOME not defined.") }
        print "$prg: ICARUS_HOME is $ENV{ICARUS_HOME}\n";
      }
      if ($opt{msm_build}) {
        if (!defined($ENV{MODELSIM_HOME})) { die ("DIE. MODELSIM_HOME not defined.") }
        print "$prg: MODELSIM_HOME is $ENV{MODELSIM_HOME}\n";
      }
      if ($opt{riv_build}) {
        if (!defined($ENV{RIVIERA_HOME})) { die ("DIE. RIVIERA_HOME not defined.") }
        print "$prg: RIVIERA_HOME is $ENV{RIVIERA_HOME}\n";
      }
    }

    if ($ENV{LM_LICENSE_FILE}) {
      print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";
    } else {
      print "$prg: LM_LICENSE_FILE : none\n";
    }

    push (@{$opt{sim_build_args}}, "-f flist") ;

    if ($opt{vcs_build}) {
      $lib_path = "-L$ENV{DV_ROOT}/tools/";
      $lib_path .= $os_cpu_slash;
      $lib_path .= "/lib ";

      foreach my $top_n (@{$opt{toplevel}}) {
        push(@{$opt{vcs_build_args}}, "-top $top_n") ;
      }

      push (@{$opt{vcs_build_args}}, "+initreg") if ($opt{vcs_use_initreg}) ;
      push (@{$opt{vcs_build_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm}) ;
      push (@{$opt{vcs_build_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne "")) ;
      push (@{$opt{vcs_build_args}}, "-cm_fsmcfg $opt{vcs_cm_fsmcfg}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_fsmcfg} ne "")) ;
      push (@{$opt{vcs_build_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne "")) ;
      push (@{$opt{vcs_build_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm}) ;
      push (@{$opt{vcs_build_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}) ;
      push (@{$opt{vcs_build_args}}, "+cli -line") if ($opt{vcs_use_cli}) ;

      # tri: adds some lint info
      # tri: remove the useless inout port lintings
      # push (@{$opt{vcs_build_args}}, "+lint=TFIPC-L,noPCTIO-L");
      # push (@{$opt{vcs_build_args}}, "+lint=noPCTIO-L");
      # VNGS = variable never get set, happens a lot when variables are wires set by submodules
      #
      push (@{$opt{vcs_build_args}}, "+lint=all,noVCDE,noVNGS,noPCTIO-L,noPCTIO");
      push (@{$opt{vcs_build_args}}, "+warn=all");
      push (@{$opt{vcs_build_args}}, "-l compile.log") ;

      if ($opt{ibm}) {
          push (@{$opt{config_rtl}}, "IBM_SRAM_RF16X160_MODEL_CHECKER") ;
          push (@{$opt{config_rtl}}, "IBM_SRAM_RF32X80_MODEL_CHECKER") ;
          push (@{$opt{config_rtl}}, "IBM_SRAM_CACHE_TAG_MODEL_CHECKER") ;
          push (@{$opt{config_rtl}}, "IBM_SRAM_LSU_ICACHE_MODEL_CHECKER") ;
      }

      push (@{$opt{config_rtl}}, "COPROCESSOR_ON") if ($opt{dmbr}) ;
      push (@{$opt{config_rtl}}, "DMBR_CHECKER") if ($opt{dmbr_checker}) ;
    }
    if ($opt{ncv_build}) {
      # build ncelab and ncsim executable files if not present

      my $ncsim = "$ENV{DV_ROOT}/tools/";
      $ncsim .= $os_cpu_slash;
      $ncsim .= "/ncsim";

      my $ncelab = "$ENV{DV_ROOT}/tools/";
      $ncelab .= $os_cpu_slash;
      $ncelab .= "/ncelab";

      if ( -f $ncsim) { print "$prg: file $ncsim found\n"; }
      if ( -f $ncelab) { print "$prg: file $ncelab found\n"; }

      if ((! -f $ncsim ) or (! -f $ncelab )) {
        my $cur_dir = $ENV{PWD};
        chdir $ENV{DV_ROOT} or die ("DIE can't change directory to $ENV{DV_ROOT}");
        chdir "tools/pli" or die ("DIE can't change directory to tools/pli");
        print "$prg: Calling make ncvexe\n";
        system("make ncvexe");
        die ("DIE. failed building ncsim or ncelab executable") if ($?) ;
        chdir $cur_dir ;
      }

      my $cmd = "+ncsimexe+";
      $cmd .= $ncsim;
      $cmd .= " +ncelabexe+";
      $cmd .= $ncelab;
      $cmd .= " " ;
      push (@{$opt{ncv_build_args}}, $cmd);
      push (@{$opt{ncv_build_args}}, "-arr_access");
      push (@{$opt{ncv_build_args}}, "+access+rw");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libiob_ncv:iob_boot");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libjbus_mon_ncv:jbus_monboot");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libmem_pli_ncv:mem_boot");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libmonitor_ncv:monitor_boot");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libsjm_ncv:sjm_boot");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libsocket_pli_ncv:socketboot");
      #push (@{$opt{ncv_build_args}}, "+ncloadpli1=$dv_root/tools/pli/libutility_ncv:utility_boot");

      push (@{$opt{ncv_build_args}}, "+name+$opt{sys}") ;
      push (@{$opt{ncv_build_args}}, "-l compile.log") ;

    }
    if ($opt{icv_build}) {
      foreach my $top_n (@{$opt{toplevel}}) {
        push (@{$opt{icv_build_args}}, "-s $top_n") ;
      }
#      push (@{$opt{icv_build_args}}, "-I $ENV{DV_ROOT}/design/include") ;
#      push (@{$opt{icv_build_args}}, "-I $ENV{DV_ROOT}/design/chipset/include") ;
      push (@{$opt{icv_build_args}}, "-g 2001") ;
    }

    # copy vcs/icv/ncv/msm/vlt_build_args to generic sim_build_args
    if ($opt{vcs_build}) {
      foreach my $x (@{$opt{vcs_build_args}})
      {
          push (@{$opt{sim_build_args}}, $x);
      }
    }
    if ($opt{ncv_build}) {
      foreach my $x (@{$opt{ncv_build_args}})
      {
          push (@{$opt{sim_build_args}}, $x);
      }
    }
    if ($opt{icv_build}) {
      foreach my $x (@{$opt{icv_build_args}})
      {
          push (@{$opt{sim_build_args}}, $x);
      }
    }
    if ($opt{msm_build}) {
      foreach my $x (@{$opt{msm_build_args}})
      {
          push (@{$opt{sim_build_args}}, $x);
      }
    }
    if ($opt{riv_build}) {
      foreach my $x (@{$opt{riv_build_args}})
      {
          push (@{$opt{sim_build_args}}, $x);
      }
    }
    if ($opt{vlt_build}) {
      foreach my $x (@{$opt{vlt_build_args}})
      {
          push (@{$opt{sim_build_args}}, $x);
      }
    }

    if ($opt{ncv_build}) {
      $ld_lib_path .= "$ENV{DV_ROOT}/tools/";
      $ld_lib_path .= $os_cpu_slash;
      $ld_lib_path .= "/lib";
      $ld_lib_path .= ":$ENV{NCV_HOME}/tools/lib/64bit:";
      $ld_lib_path .= $ENV{LD_LIBRARY_PATH};
      $ENV{LD_LIBRARY_PATH} = $ld_lib_path;
      print "$prg: LD_LIBRARY_PATH is $ENV{LD_LIBRARY_PATH}\n";
    }

    # build the model
    print "$prg: Building rtl model\n" ;

    if ($opt{vcs_build}) {
      if ($ENV{VCS_BIN}) {
        $build_cmd = "$ENV{VCS_BIN} ";
      } else {
        $build_cmd  = "vcs " ;
      }
      # lib_path needs to be before vcs_build_args
      $build_cmd .= $lib_path;
    }
    if ($opt{ncv_build}) {
      $build_cmd = "LD_LIBRARY_PATH=";
      $build_cmd .= $ld_lib_path;
      $build_cmd  .= " ; export LD_LIBRARY_PATH;  ncverilog -C " ;
    }
    if ($opt{icv_build}) {
      $build_cmd = "iverilog " ;
      $build_cmd .= " ";
    }
    if ($opt{msm_build}) {
      $build_cmd = "vlog" ;
      if ($ENV{MODELSIM_VERSION}) {
        $build_cmd .= "$ENV{MODELSIM_VERSION}" ;
      }
      # compile everything as one compile unit (in order to keep the global defines in config.v)
      $build_cmd .= " -mfcu ";
      # also suppress the following warning, which unfortunately is hardly avoidable when using
      # always_comb blocks that operate on arrays inside a generate statement.
      # [SVCHK] - Some checking for conflicts with always_comb and always_latch variables not yet supported.
      $build_cmd .= " -suppress 2583 ";
    }
    if ($opt{riv_build}) {
      $build_cmd = "vlib work; vlog " ;
    }
	
    if ($opt{vlt_build}) {
      $build_cmd = "verilator -cc " ;
      $build_cmd .= "-exe $dv_root/tools/verilator/my_top.cpp " ;
      $build_cmd .= "$dv_root/tools/pli/iop/b_ary.c " ;
      $build_cmd .= "$dv_root/tools/pli/iop/bw_lib.c " ;
      $build_cmd .= "$dv_root/tools/pli/iop/iob_main.cc " ;
      $build_cmd .= "$dv_root/tools/pli/iop/iob.cc " ;
      $build_cmd .= "$dv_root/tools/pli/iop/cpx.cc " ;
      $build_cmd .= "$dv_root/tools/pli/iop/pcx.cc " ;
      $build_cmd .= "--top-module cmp_top " ;
      $build_cmd .= "-Wno-fatal " ;
      $build_cmd .= "-Wno-BLKANDNBLK " ;
      $build_cmd .= "-Wno-TIMESCALEMOD " ;
      $build_cmd .= "-DPITON_DPI " ;
      $build_cmd .= "--unroll-count 256 " ;
      $build_cmd .= "-CFLAGS -DVERILATOR " ;
      $build_cmd .= "-CFLAGS -DPITON_DPI " ;
      $build_cmd .= "-CFLAGS -lstdc++ " ;
      $build_cmd .= "-CFLAGS -I$dv_root/tools/pli/iop " ;
      $build_cmd .= "-CFLAGS -I$dv_root/tools/verilator " ;
    }
    if ($opt{other_sim_build}) {
      if (($opt{other_sim_build_cmd}) eq "") {
        die ("DIE. other_sim_build_cmd not defined");
      }

      $build_cmd = $opt{other_sim_build_cmd};
      $build_cmd .= " ";
    }

    # Transfer some build args to the flist
    open (IFLIST, "> flist.new") or die ("DIE. can't open flist.new") ;
    foreach my $x (@{$opt{sim_build_args}}) {
      $x =~ s/^"(.*?)"$/$1/ ;
      if ($x =~ /\+define+|^-v |^-y |^-f (?!(flist|.*0in.*?\.arg))/) {
        print IFLIST "$x\n";
      } else {
        $build_cmd .= "$x " ;
      }
    }

    # Append flist to flist.new and rename to flist.
    open (FLIST, "flist") or die ("DIE. can't open flist");
    while (<FLIST>) {
        print IFLIST "$_";
    }
    close FLIST;
    close IFLIST;
    rename "flist", "flist.orig" or die ("DIE. can't rename flist");
    rename "flist.new", "flist" or die ("DIE. can't rename flist.new");

    print "$prg: $build_cmd\n";

    if (! $opt{dryrun}) {
      system ($build_cmd) ;
      die ("DIE. failed building model") if ($?) ;
    }

    if ($opt{vlt_build}) {
      $build_cmd = "make -j -C $model_path/obj_dir -f Vcmp_top.mk Vcmp_top" ;

      print "$prg: $build_cmd\n";

      if (! $opt{dryrun}) {
        system ($build_cmd) ;
        die ("DIE. failed building model") if ($?) ;
      }
    }

    # go back to where the script was invoked
    chdir $cur_dir ;
}

################################################################################
# generic simulator run (incorporates vcs, ncv, icv, msm, vlt, other)
################################################################################

sub generic_sim_run
{
    my $ncvcommand = "";
    my $cmd = "";
    my $ld_lib_path = "";

    # first clean up the diag area
    `rm -rf sim.log *.rpt coverage`;
    die ("DIE. could not clean up diag run area") if ($?) ;

    # copy the diff release over
    system ("cp -f $model_path/diff_rel.log .") if (-f "$model_path/diff_rel.log") ;

    # copy the flist over
    system ("cp -f $model_path/flist .") ;
    die ("DIE. could not copy flist to $ENV{PWD}") if ($?) ;

    # verify that a model was compiled
    die ("DIE. simv not found in $model_path") if ($opt{vcs_run} and ! -e "$model_path/simv") ;
    die ("DIE. INCA_libs not found in $model_path") if ($opt{ncv_run} and ! -e "$model_path/INCA_libs") ;
    die ("DIE. a.out not found in $model_path") if ($opt{icv_run} and ! -e "$model_path/a.out") ;
    die ("DIE. work/ not found in $model_path") if ($opt{msm_run} and ! -d "$model_path/work") ;
	die ("DIE. work/ not found in $model_path") if ($opt{riv_run} and ! -d "$model_path/work") ;
    die ("DIE. obj_dir/ not found in $model_path") if ($opt{vlt_run} and ! -d "$model_path/obj_dir") ;

    # pass the good trap and bad trap addresses to the testbench
    my $good_trap = "";
    my $bad_trap = "";

    if (($opt{asm_diag_name} ne "") or ($opt{image_diag_name} ne ""))
    {
      die ("DIE. could not find symbol.tbl file") if (!-f "symbol.tbl") ;

      my @good_trap_list = `grep -w good_trap symbol.tbl`;
      my @bad_trap_list = `grep -w bad_trap symbol.tbl`;
      my %good_trap_list ;
      my %bad_trap_list ;
      my @good_trap ;
      my @bad_trap ;

      if ($#good_trap_list >= 0) {
        $good_trap = "" ;
        my $trap_i=0;
        foreach my $trap (@good_trap_list) {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $good_trap .= " +good_trap$trap_i=" . $pa ;
          $trap_i++;
          $good_trap_list{$pa} = 1 ;
        }
      }

      if ($#bad_trap_list >= 0)
      {
        $bad_trap = "" ;
        my $trap_i=0;
        foreach my $trap (@bad_trap_list) {
          my ($tmp1, $va, $ra, $pa) = ($trap =~ /([\w_\.]+)\s+(\w+)\s+(\w+)\s+(\w+)/) ;
          $bad_trap .= " +bad_trap$trap_i=" . $pa ;
          $trap_i++;
          $bad_trap_list{$pa} = $pa;
        }
      }
    }

    # add in switches for signal dumping

    if ($opt{ncv_run}) {
      $ncvcommand = "\"run\"";
    }

    # convert -args to +args
    push (@{$opt{sim_run_args}}, "+finish_mask=$opt{finish_mask}") if ($opt{finish_mask} ne "") ;
    push (@{$opt{sim_run_args}}, "+TIMEOUT=$opt{rtl_timeout}") if ($opt{rtl_timeout}) ;
    push (@{$opt{sim_run_args}}, "+max_cycle=$opt{max_cycle}") if ($opt{max_cycle}) ;

    push (@{$opt{sim_run_args}}, "+initreg+$opt{tg_seed}") if ($opt{vcs_use_initreg}) ;
    push (@{$opt{sim_run_args}}, "+tg_seed=$opt{tg_seed}") ;
    push (@{$opt{sim_run_args}},  $good_trap) if ($good_trap ne "") ;
    push (@{$opt{sim_run_args}},  $bad_trap) if ($bad_trap ne "") ;
    # push (@{$opt{sim_run_args}}, "-l sim.log") ;
    # push (@{$opt{sim_run_args}}, "-l ncverilog.log") ;
    push (@{$opt{sim_run_args}}, "+nolog") if ($opt{ncv_run}) ;
    # push (@{$opt{sim_run_args}}, "+vcs+nostdout") if ($opt{regress});
    push (@{$opt{sim_run_args}}, "-cm $opt{vcs_cm_args}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_cond $opt{vcs_cm_cond}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_cond} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_hier $opt{vcs_cm_config}") if ($opt{vcs_use_cm} and ($opt{vcs_cm_config} ne ""));
    push (@{$opt{sim_run_args}}, "-cm_name $opt{vcs_cm_name}") if ($opt{vcs_use_cm});
    push (@{$opt{sim_run_args}}, "-cm_dir $model_path") if ($opt{vcs_use_cm}); #$ENV{PWD}
    push (@{$opt{sim_run_args}}, "+asm_diag_name=$opt{asm_diag_name}") if ($opt{asm_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+image_diag_name=$opt{image_diag_name}") if ($opt{image_diag_name} ne "") ;
    push (@{$opt{sim_run_args}}, "+fast_boot") if ($opt{fast_boot}) ;
    push (@{$opt{sim_run_args}}, "+dv_root=$dv_root") ;

    # run the command
    if ($opt{vcs_run}) {
      $cmd .= "collect " if ($opt{vcs_prof}) ;
      $cmd .= "$model_path/simv " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
    }

    if ($opt{ncv_run}) {
      $ld_lib_path = $ENV{LD_LIBRARY_PATH};
      $ld_lib_path .= ":$ENV{DV_ROOT}/tools/";
      $ld_lib_path .= $os_cpu_slash;
      $ld_lib_path .= "/lib";
      $ld_lib_path .= ":$ENV{NCV_HOME}/tools/lib/64bit";
      $cmd .= "#!/bin/csh -f\nsetenv LD_LIBRARY_PATH ";
      $cmd .= $ld_lib_path;
      $cmd .= "\n" ;
      $cmd .= "echo ";
      $cmd .= $ncvcommand;
      $cmd .= " | ncverilog " ;
      $cmd .= "+nclibdirname+$model_path/INCA_libs " ;
      $cmd .= "-r worklib.$opt{sys}:v " ;
      $cmd .= "+name+$opt{sys} " ;
      $cmd .= "+ncsimexe+$ENV{DV_ROOT}/tools/";
      $cmd .= $os_cpu_slash;
      $cmd .= "/ncsim " ;
      $cmd .= "+ncelabexe+$ENV{DV_ROOT}/tools/";
      $cmd .= $os_cpu_slash;
      $cmd .= "/ncelab -s " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
    }

    if ($opt{icv_run}) {
      $cmd .= "vvp " ;
      $cmd .= "-M$ENV{DV_ROOT}/tools/";
      $cmd .= $os_cpu_slash;
      $cmd .= "/lib ";
      $cmd .= " -mveriuser $model_path/a.out " ;
      $cmd .= " " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
    }

    if ($opt{msm_run}) {
      $cmd .= "vsim" ;
      if ($ENV{MODELSIM_VERSION}) {
        $cmd .= "$ENV{MODELSIM_VERSION}" ;
      }
      $cmd .= " ";
      #modelsim cannot be called with -c and -gui at the same time
      if (!$opt{gui}) {
        $cmd .= " -c " ;
      }
      if ($opt{log_all}) {
      	# this logs everything such that the sim can be inspected later on
      	print("$prg: dumping all waves to save.wlf - this file can get very large so make sure you run this on a fast disk with enough space.\n");
      	$cmd .= " -wlfcompress -wlf all-waves.wlf -do \"log -r /*\" ";
      }
      $cmd .= "-lib ";
      $cmd .= "$model_path/work ";
      $cmd .= "-do \"run -all\" ";

      foreach my $top_n (@{$opt{toplevel}}) {
        $cmd .= "$top_n ";
      }

      $cmd .= "-pli \"";
      $cmd .= "$ENV{DV_ROOT}/tools/";
      $cmd .= $os_cpu_slash;
      $cmd .= "/lib/libmodelsimpli.so\"";
      $cmd .= " " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
      print("====================================\n$cmd\n====================================");
    }
	
if ($opt{riv_run}) {
    if (!$opt{gui}) {
        $cmd .= "vsimsa" ;
		$cmd .= " ";
		$cmd .= "-do \" vsim ";
		$cmd .= "-lib ";
		$cmd .= "$model_path/work ";
		

		foreach my $top_n (@{$opt{toplevel}}) {
			$cmd .= "$top_n ";
		}
		$cmd .= "+access +r ";
		$cmd .= "-pli \"";
		$cmd .= "$ENV{DV_ROOT}/tools/";
		$cmd .= $os_cpu_slash;
		$cmd .= "/lib/librivierapli.so\"";
		$cmd .= " " ;
		$cmd .= join (" ", @{$opt{sim_run_args}}) ;
		$cmd .= "; run -all\" ";
		print("====================================\n$cmd\n====================================");
     }
	 else {
      $cmd .= "vsim" ;
	  $cmd .= " ";

      $cmd .= "-lib ";
      $cmd .= "$model_path/work ";
      $cmd .= "-do \"run -all\" ";

      foreach my $top_n (@{$opt{toplevel}}) {
        $cmd .= "$top_n ";
      }
	  $cmd .= "+access +r ";
      $cmd .= "-pli \"";
      $cmd .= "$ENV{DV_ROOT}/tools/";
      $cmd .= $os_cpu_slash;
      $cmd .= "/lib/librivierapli.so\"";
      $cmd .= " " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
      print("====================================\n$cmd\n====================================");
	 } 
    }	

    if ($opt{vlt_run}) {
      $cmd .= "$model_path/obj_dir/Vcmp_top " ;
      $cmd .= " " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
    }

    if ($opt{other_sim_run}) {
      if (($opt{other_sim_run_cmd}) eq "") {
        die ("DIE. other_sim_run_cmd not defined");
      }
      $cmd = $opt{other_sim_run_cmd};
      $cmd .= " " ;
      $cmd .= join (" ", @{$opt{sim_run_args}}) ;
    }

    print "$prg: $cmd\n";

    if ($opt{ncv_run}) {
      open (NCVCMD, "> ncv_cmd") ;
      print NCVCMD "$cmd\n" ;
      close (NCVCMD) ;
      `chmod +x ncv_cmd`;

      $cmd = "./ncv_cmd";

      $ENV{LD_LIBRARY_PATH} = $ld_lib_path;
    }

    print "$prg: LD_LIBRARY_PATH is $ENV{LD_LIBRARY_PATH}\n" if (!$opt{vcs_run}) ;

    if ($opt{vcs_run}) {
      # figure out the location of vcs from variable
      if (!defined($ENV{VCS_HOME})) { die ("DIE. VCS_HOME not defined.") }
      print "$prg: VCS_HOME is $ENV{VCS_HOME}\n";
    }

    if ($opt{ncv_run}) {
      if (!defined($ENV{NCV_HOME})) { die ("DIE. NCV_HOME not defined.") }
      print "$prg: NCV_HOME is $ENV{NCV_HOME}\n";
    }

    if ($opt{icv_run}) {
      if (!defined($ENV{ICARUS_HOME})) { die ("DIE. ICARUS_HOME not defined.") }
      print "$prg: ICARUS_HOME is $ENV{ICARUS_HOME}\n";
    }

    if ($opt{msm_run}) {
      if (!defined($ENV{MODELSIM_HOME})) { die ("DIE. MODELSIM_HOME not defined.") }
      print "$prg: MODELSIM_HOME is $ENV{MODELSIM_HOME}\n";
    }

    if ($opt{riv_run}) {
      if (!defined($ENV{RIVIERA_HOME})) { die ("DIE. RIVIERA_HOME not defined.") }
      print "$prg: RIVIERA_HOME is $ENV{RIVIERA_HOME}\n";
    }	
	
    if ($ENV{LM_LICENSE_FILE}) {
      print "$prg: LM_LICENSE_FILE : $ENV{LM_LICENSE_FILE}\n";
    } else {
      print "$prg: LM_LICENSE_FILE : none\n";
    }

    if (!$opt{dryrun}) {
      $main::sim_start  = `date` ;
      print "$prg: sim_start $main::sim_start" ;

      if ($opt{regress}) {
        system ("$cmd > sim.log 2>&1") ;
        die ("DIE. simulator exited with an error") if ($?) ;
      } elsif (($opt{vcs_run} and $opt{vcs_use_cli}) or ($opt{ncv_run} and $opt{ncv_use_cli})) {
        system ($cmd) ;
      } else {
        my $waitstatus = call_program ($cmd, "sim.log") ;
        die ("DIE. simulator exited with an error") if ($waitstatus) ;
      }
      $main::sim_stop = `date` ;
      print "$prg: sim_stop $main::sim_stop" ;

      open (PERFLOG, "> sim.perf.log") ;
      print PERFLOG "$prg: sim_start $main::sim_start" ;
      print PERFLOG "$prg: sim_stop $main::sim_stop" ;
      close (PERFLOG) ;
    }
}


################################################################################
# run pre processing scripts
################################################################################

sub pre_process {
  # Set the launch dir for pre-pocessors to use

  $ENV{SIMS_LAUNCH_DIR} = $launch_dir;

  foreach my $cmd (@{$opt{pre_process_cmd}}) {
    print "$prg: $cmd\n";

    if (!$opt{dryrun}) {
      $cmd =~ s/"(.*?)"/$1/ ;
      system ($cmd) ;
      print ("$prg: warning failed execution of $cmd") if ($?) ;
    }
  }
}

################################################################################
# run post processing scripts
################################################################################

sub post_process
{
    # run post processing script if needed
    my $pass = 0 ;

    # Set the launch dir for post-processors to use
    $ENV{SIMS_LAUNCH_DIR} = $launch_dir;

    foreach my $cmd (@{$opt{post_process_cmd}}) {
      print "$prg: $cmd\n";

      if (!$opt{dryrun}) {
        $cmd =~ s/"(.*?)"/$1/ ;
        system ($cmd) ;
        print ("$prg. warning failed execution of $cmd\n") if ($?) ;
      }
    }

    # determine pass fail status from sim.log

    if (-f  "sim.log") {
      my $cmd = "grep -c PASS sim.log"; ## count lines with PASS
      my $count = `$cmd`;
      chomp $count;       ## get rid of newline at end
      $pass = 1 if ($count > 0);
    }

    if (-f "diag_pl.log") {
      open (DIAGPLLOG, "diag_pl.log") or die ("DIE. could not open diag_pl.log") ;
      my @diagpllog = <DIAGPLLOG> ;
      close (DIAGPLLOG) ;

      my @pass = grep (/PASS/, @diagpllog) ;
      $pass = 1 if ($#pass >= 0) ;
      my @fail = grep (/FAIL/, @diagpllog) ;
      $pass = 0 if ($#fail >= 0) ;
    }

    # if this is a regression copy the results back to the result area
    if ($opt{regress}) {
      # find out if diag passed

      if ($pass and (!$opt{copyall})) {
        # compress the files
        `gzip sim.log` if ($opt{gzip} and (-f "sim.log")) ;
        `gzip diag.exe` if ($opt{gzip} and (-f "diag.exe")) ;

        # copy back all relevant data

        `cp *.log.gz $launch_dir` ;
        print ("$prg: warning could not copy *.log.gz files back to $launch_dir\n") if ($?) ;
        `cp *.log $launch_dir` ;
        print ("$prg: warning could not copy *.log files back to $launch_dir\n") if ($?) ;
        `cp -r ${opt{vcs_cm_name}}* $launch_dir` if ($opt{vcs_use_cm}) ;
        print ("$prg: warning could not copy vcs coverage data back to $launch_dir\n") if ($?) ;
        `cp -r ${opt{vcs_cm_name}}* ${model_path}/coverage/verilog` if ($opt{vcs_use_cm}) and ($opt{vcs_cm_merge}) ;
        print ("$prg: warning could not copy vcs coverage data back to ${model_path}/coverage/verilog\n") if ($?) ;

        if ($opt{asm_diag_name} ne "") {
          `shopt -s nullglob; cp *.s *.S *.tbl *.ev *.exe.gz $launch_dir; shopt -u nullglob` ;
          print ("$prg: warning could not copy assembly files back to $launch_dir\n") if ($?) ;
        }
      }
      else  # diag failed or $opt{copyall} is set
      {
        if ($opt{tarcopy}) {
            `tar cfE - . | ( cd $launch_dir; tar vxfEBp - )`;
        } else {
            `cp -r * $launch_dir` ;
        }
        print ("$prg: warning could not copy files back to $launch_dir\n") if ($?) ;
      }

      # clean up the tmp area
      chdir $launch_dir ;
      `rm -rf $work_dir` ;
      print ("$prg: warning could not delete content of $work_dir\n") if ($?) ;
    }
}

################################################################################
# open up the config file and get the arguments for this sys
################################################################################

sub get_config
{
  my $sys_name = shift ;
  my $argvref = shift ;

  my $confcppargs = join(' ', @{$opt{config_cpp_args}});
  print "$prg: using config file $sims_config ($confcppargs)\n" ;
  open (SIMS_CONFIG, "bw_cpp -P -B $confcppargs -undef -I$dv_root/$proj_vars{sims_config} $sims_config | ") or die "DIE. Could not open $sims_config" ;
  my @sims_config_file = <SIMS_CONFIG> ;
  close (SIMS_CONFIG) ;

  my $sims_config_file = join ('', @sims_config_file) ;

  my ($body) = ($sims_config_file =~ /<\s*$sys_name\s*>\s+(.*?)<\s*\/$sys_name\s*>/ogis) ;

  die "DIE. could not find $sys_name in $sims_config" if (!defined $body) ;

  # Add OS/CPU specific configuration

  my $os_cpu_config = $dv_root;
  $os_cpu_config .= "/";
  $os_cpu_config .= $proj_vars{sims_config};
  $os_cpu_config .= "/";
  $os_cpu_config .= $sys_name;
  $os_cpu_config .= ".";
  $os_cpu_config .= $os_cpu_dot;
  if ( -f $os_cpu_config ) {
    open (SIMS_CONFIG, $os_cpu_config) or die "DIE. Could not open $os_cpu_config" ;
    my @sims_config_file = <SIMS_CONFIG> ;
    close (SIMS_CONFIG) ;

    my $sims_config_file = join ('', @sims_config_file) ;
    $body .= $sims_config_file;
  } else {
    print "$prg: $os_cpu_config Not found.\n";
  }

  my @argv = split (/\n/, $body) ;

  foreach my $x (@argv) {
    next if ($x =~ /^\s*$/o);  # Discard empty lines
    $x =~ s/^\s*(-.*)/$1/ ;
    $x =~ s/(.*?)\s*$/$1/ ;
    unshift (@{$argvref}, $x) ;
  }
}

################################################################################
# Freeze tool versions:
#       Given a run_dir, make copy of all tver files.
#       Construct an iver file pointing to these tvers
#       Return string which is new value of env variable: TRE_SEARCH
################################################################################

sub freeze_tre
{
  my $run_dir = shift ;
  my $tre_search = "";

  my $TRE_SEP = '/';

  if ( -d "$run_dir/tre" and -f "$run_dir/tre/sims.iver" ) {
    # recursive call.  tre_search already filled in
    # $tre_search = "$run_dir/tre/sims.iver"    if $opt{use_iver} eq "";
    return $tre_search;
  }

    my $entry = $TRE_SEP;

    ## $! = -1;
    die "$prg: \$TRE_SEARCH not set!\n" unless exists $ENV{TRE_SEARCH};
    die "$prg: \$TRE_SEARCH set to blank!\n" unless $ENV{TRE_SEARCH} =~ /\S/;

    my @ivers = split ' ', $ENV{TRE_SEARCH};
    my @tvers;
    my %seen_tver;
    foreach my $iver (@ivers) {
      print "CHECK IVER: $iver\n" if $opt_debug;
      my @tvers_from_iver = get_tvers_from_iver($iver);
      foreach my $tver (@tvers_from_iver) {
        if(not exists $seen_tver{$tver}) {
          push @tvers, $tver;
          $seen_tver{$tver} = 1;
          ## $! = 2;
          die "$prg: Cannot find tver '$tver'!\n" unless -e $tver;
        }
      }
    }

    ## at this point, all the tvers are now collected and in order
    ## we need to copy them to files in the run_dir directory
    ## and construct an iver that points to them.
    `mkdir -p $run_dir/tre`;
    die "$prg: cannot create $run_dir/tre: $!\n" if ($?);
    my $tnum = 0;
    my $iver = $run_dir . "/tre" . "/sims.iver";
    $tre_search = File::Spec->rel2abs( $iver ); # clean up path
    my $dest = "";
    local (*IVER);
    open IVER, "> $iver" or die "$prg: could not write to $iver: $!\n";
    foreach my $tver ( @tvers ) {
        $dest = sprintf "%s_%0d", "$run_dir/tre/sims.tver", $tnum;
        $dest = File::Spec->rel2abs( $dest );   # clean up path, if relative
        `cp $tver $dest`;
        die "$prg: could not copy tver: $tver: to $dest\n" if ($?);
        printf IVER "%s\n", $dest;
        $tnum++;
    } # foreach tver
    close IVER;

    return $tre_search;

} # freeze_tre

###############################################################################

sub expand_filename {
  my $filename = shift;

  $filename =~ s/^\s+//;
  # twiddle expansion
  $filename =~
    s{ ^ ~ ([^/]*) }
      { $1 ? (getpwnam($1))[7] :
          ( $ENV{HOME} || $ENV{LOGDIR} || (getpwuid($>))[7]) }ex;
  # environment variable expansion
  $filename =~ s/\$\{*(\w+)\}*/expand_env($1)/ge;

  return $filename;
}

###############################################################################

sub expand_env {
  my $envvar = shift;

  return $ENV{$envvar} if exists $ENV{$envvar};
  die "$prg: Environment variable '$envvar' not defined!\n";
}

###############################################################################

sub get_tvers_from_iver {
  my $iver = shift;
  local (*IVER);

  $iver = expand_filename($iver);
  return unless -e $iver;
  open IVER, "<$iver" or die "$prg:  Can't open '$iver': $!\n";
  my @tvers;
  while(<IVER>) {
    chomp;
    s/\#.*$//;
    $_ = expand_filename($_);
    next unless /\S/;
    print "  -- tver file: $_\n" if $opt_debug;
    push @tvers, $_;
  }
  return @tvers;
}

################################################################################
# assemble diag
################################################################################

sub assemble_diag
{
    # first clean up the diag area
    `rm -rf diag.pal diag.s diag.S diag.pl diag.exe mem.image diag.ev symbol.tbl` ;
    die "DIE. could not clean up assembly diag run area"  if ($?) ;

    # add default path to look for precompiled RISCV 64bit assembly tests diags
    if ($opt{ariane} and $opt{precompiled}) {
      push @{$opt{asm_diag_root}}, "$ENV{ARIANE_ROOT}/tmp/riscv-tests/build/isa";
      push @{$opt{asm_diag_root}}, "$ENV{ARIANE_ROOT}/tmp/riscv-tests/build/benchmarks";
    }

    # find diagnostic
    my $diag_full_path = &find_diag_path ($opt{asm_diag_name}, $opt{asm_diag_path}, $opt{asm_diag_root}) ;

    my $diag_name ;
    if ($opt{asm_diag_name} =~ /\.pal/)        { $diag_name = "diag.pal"  ; }
    elsif ($opt{asm_diag_name} =~ /\.s\.gz/)   { $diag_name = "diag.s.gz" ; }
    elsif ($opt{precompiled} and ($opt{rv32} | $opt{rv64})) { $diag_name = "diag.exe"  ; }
    elsif (($opt{rv32} | $opt{rv64}) and ($opt{asm_diag_name} =~ /\.S/)) { $diag_name = "diag.S" ; }
    elsif (($opt{rv32} | $opt{rv64}) and ($opt{asm_diag_name} =~ /\.c/)) { $diag_name = "diag.c" ; }
    else { $diag_name = "diag.s" ; }

    # copy diagnostic to run area
    `cp $diag_full_path $diag_name` ;
    die ("DIE. unable to copy assembly diag to $ENV{PWD}") if ($?) ;
    `chmod +w $diag_name` ;
    die ("DIE. unable to permission of assembly diag") if ($?) ;

    # gunzip if needed
    if ($opt{asm_diag_name} =~ /\.s\.gz/) {
      `gzip -d diag.s.gz` ;
      die ("DIE. unable to gunzip assembly diag") if ($?) ;
      $diag_name = "diag.s" ;
    }

    $ENV{ASM_DIAG_NAME} = $opt{asm_diag_name};
    $ENV{ASM_DIAG_NAME_NO_EXT} = substr $opt{asm_diag_name}, 0, -2;

    # pre process if needed
    &pre_process ;

    # extract sims options from diag.s
    if (($diag_name =~ /\.s/) or ($diag_name =~ /\.S/)) {
      open (DIAGIN, "< $diag_name") or die "DIE. Could not open $diag_name" ;

      while (<DIAGIN>) {
        my $line = $_ ;

        if ($line =~ /^\!SIMS\+ARGS\:/) {
          my (@plusargs) = split (/\s+/, $line) ;
          shift (@plusargs) ;
          push (@ARGV, @plusargs) ;
          print "$prg: Found sims arguments in $diag_name: @plusargs\n" ;
          parse_args ("dummy", 0) ;
        }
      }

      close (DIAGIN) ;
    }

    # Choose compilation flow based on ISA
    if ($opt{rv32}) {
      # RISCV flow for RV32
      if (!$opt{rv32_target_triple}) {
        if ($opt{pico}) {
          $ENV{RV32_TARGET_TRIPLE} = "riscv32-unknown-elf" ;
        }
      } else {
        $ENV{RV32_TARGET_TRIPLE} = $opt{rv32_target_triple} ;
      }
      if (!$opt{rv32_march}) {
        if ($opt{pico}) {
          $ENV{RV32_MARCH} = "rv32ima" ;
        }
      } else {
        $ENV{RV32_MARCH} = $opt{rv32_march} ;
      }
      if (!$opt{rv32_mabi}) {
        if ($opt{pico}) {
          $ENV{RV32_MABI} = "ilp32" ;
        }
      } else {
        $ENV{RV32_MABI} = $opt{rv32_mabi} ;
      }
      print "$prg: assembling 32bit riscv diag (RV32IM)\n" ;
      my $cmd = "rv32_as " ;
      #$cmd .= join (" ", @{$opt{midas_args}}) ;
      print "$prg: $cmd\n";

      my $waitstatus = call_program($cmd, "rv32_as.log");
      die ("DIE. rv32_as compilation error") if ($waitstatus) ;

    }
    if ($opt{rv64}) {
      # RISCV flow for RV64
      if (!$opt{rv64_target_triple}) {
        if ($opt{ariane}) {
          $ENV{RV64_TARGET_TRIPLE} = "riscv64-unknown-elf" ;
        }
      } else {
        $ENV{RV64_TARGET_TRIPLE} = $opt{rv64_target_triple} ;
      }
      if (!$opt{rv64_march}) {
        if ($opt{ariane}) {
          $ENV{RV64_MARCH} = "rv64imafdc" ;
        }
      } else {
        $ENV{RV64_MARCH} = $opt{rv64_march} ;
      }
      if (!$opt{rv64_mabi}) {
        if ($opt{ariane}) {
          $ENV{RV64_MABI} = "lp64d" ;
        }
      } else {
        $ENV{RV64_MABI} = $opt{rv64_mabi} ;
      }
      # only recompile if necessary
      if (!$opt{precompiled}) {
        print "$prg: assembling 64bit riscv diag (RV64IMAC)\n" ;
        my $defs = "-DPITON_NUMTILES=$ENV{PITON_NUM_TILES} ";
        if ($opt{uart_dmw}) {
          $defs .= " -DPITONSTREAM ";
        }
        foreach my $additional_args (@{$opt{gcc_args}}) {
          $defs .= " ${additional_args}";
        }
        my $cmd = "rv64_cc ${diag_name} \"$defs\"" ;
        print "$prg: $cmd\n";
        my $waitstatus = call_program($cmd, "rv64_cc.log");
        die ("DIE. rv64_cc compilation error") if ($waitstatus) ;
      }

      my $cmd = "rv64_img" ;

      print "$prg: $cmd\n";
      my $waitstatus = call_program($cmd, "rv64_img.log");
      die ("DIE. rv64_img error creating mem image") if ($waitstatus) ;

      if($opt{trap_offset}) {
        print "$prg: good/bad trap offset $opt{trap_offset} specified, patching traps...\n";

        my $filename = 'symbol.tbl';
        my @new_traps;
        my $fh;
        my $str;
        open($fh, '<:encoding(UTF-8)', $filename)
          or die "Could not open file '$filename' $!";
        while (my $row = <$fh>) {
          chomp $row;
          my @tmp     = split / /, $row;
          my @tmp_adj = @tmp;
          $tmp_adj[1] = hex($tmp[1]) - hex($opt{trap_offset});
          $tmp_adj[3] = hex($tmp[3]) - hex($opt{trap_offset});
          $str = sprintf("$tmp_adj[0] %016x $tmp_adj[2] %016x", $tmp_adj[1], $tmp_adj[3]);
          print "$prg: Adjusting trap $tmp[0] $tmp[1] $tmp[2] $tmp[3] -> $str\n";
          push(@new_traps, $str);
        }
        close($fh);
        open($fh, '>', $filename)
          or die "Could not open file '$filename' $!";
        foreach $str (@new_traps) {
          print $fh "$str\n";
        }
        close($fh);
      }
    }
    if ($opt{sparcv9}) {
      # standard flow for SAPRC
      # assemble
      push (@{$opt{midas_args}}, "-DFAST_BOOT") if ($opt{fast_boot}) ;
      push (@{$opt{midas_args}}, "-diag_root=$dv_root") ;
      push (@{$opt{midas_args}}, "-DTG_SEED=$opt{tg_seed}") if ($opt{midas_use_tgseed}) ;
      push (@{$opt{midas_args}}, "-pal_diag_args=-seed=$opt{tg_seed}") if ($opt{pal_use_tgseed}) ;
      push (@{$opt{midas_args}}, "$diag_name") ;

      #push (@{$opt{midas_args}}, "-DCIOP") if ($opt{icv_run} or ($opt{sim_type} eq "icv")) ;

      print "$prg: assembling diag\n" ;
      my $cmd = "midas " ;
      $cmd .= join (" ", @{$opt{midas_args}}) ;
      print "$prg: $cmd\n";

      my $waitstatus = call_program($cmd, "midas.log");
      die ("DIE. midas compilation error") if ($waitstatus) ;

      if ($opt{midas_only} and $opt{regress}) {
        if ($opt{tarcopy}) {
          `tar cfE - . | ( cd $launch_dir; tar vxfEBp - )`;
        } else {
          `cp -r * $launch_dir` ;
        }
        print ("$prg: warning could not copy files back to $launch_dir\n") if ($?) ;
      }
    }

    exit (0) if ($opt{midas_only}) ;
}

################################################################################
# call_program - runs a program, tee's the output to a log, and returns exit
# status
################################################################################

sub call_program {
  my $cmd  = shift;
  my $file = shift;

  local (*PROGFH, *TEE);
  open( PROGFH,  "$cmd 2>&1 |" ) or die "Can't run '$cmd': $!\n";

  open( TEE, ">$file" ) or die "Can't open '$file': $!\n";

  my $old_fh = select(TEE);
  $| = 1;
  select($old_fh);

  while(<PROGFH>) {
    print;
    print TEE;
  }

  close( TEE );

  close( PROGFH );
  return $?;
}

################################################################################
# copy diag image
################################################################################

sub copy_image
{
    # first clean up the diag area
    `rm -rf diag.pal diag.s diag.S diag.pl diag.exe mem.image diag.ev symbol.tbl` ;
    die ("DIE. could not clean up image run area")  if ($?) ;

    my $image_full_path = &find_diag_path ($opt{image_diag_name}, $opt{image_diag_path}, $opt{image_diag_root}) ;

    `cp $image_full_path mem.image` ;
    die ("DIE. unable to copy memory image into $ENV{PWD}") if ($?) ;
    `chmod +w mem.image` ;
    die ("DIE. unable to change permission of memory image") if ($?) ;

    $image_full_path =~ s/\.image/\.ev/ ;
    `cp $image_full_path diag.ev` ;
    die ("DIE. unable to copy diag event file into $ENV{PWD}") if ($?) ;
    `chmod +w diag.ev` ;
    die ("DIE. unable to change permission of diag event file") if ($?) ;

    $image_full_path =~ s/\.ev/\.tbl/ ;
    `cp $image_full_path symbol.tbl` ;
    die ("DIE. unable to copy symbol table file into $ENV{PWD}") if ($?) ;
    `chmod +w symbol.tbl` ;
    die ("DIE. unable to change permission of symbol table") if ($?) ;

    # pre process if needed
    &pre_process ;
}

sub oram_image
{
    my $script_path = $ENV{DV_ROOT};
    print "trying to create oram image\n";

    `python $script_path/verif/env/manycore/mem_to_queue.py mem.image mem.image.oram`;
    die ("DIE. couldn't create oram init image") if ($?) ;
}

################################################################################
# locate a diag based on diag_root, diag_path and diag_name
################################################################################

sub find_diag_path
{
  my $diag_name = shift ;
  my $diag_path = shift ;
  my $diag_root = shift ;

  my @full_path = () ;

  print "$prg: locating diag $diag_name\n" ;

  if (($diag_path ne "") and (-e "${diag_path}/$diag_name")) {
    push (@full_path, "${diag_path}/$diag_name\n") ;
  } else {
    foreach my $root (@{$diag_root}) {
      print "$prg: Looking for diag under $root\n" ;
      @full_path = `find $root -follow -name '$diag_name'`;
      last if ($#full_path > -1) ;
    }
  }

  if ($#full_path == -1) { die ("DIE. no diag with name $diag_name found") ; }
  if ($#full_path > 0) { die ("DIE. multiple diags with name $diag_name found $#full_path $full_path[0] $full_path[1]") ; }

  chomp $full_path[0];
  print "$prg: Found diag under $full_path[0]\n" ;
  return $full_path[0] ;
}

################################################################################
# parse all arguments from command line and config file
################################################################################

sub parse_args
{
  my $sys = shift ;
  my $doconfig = shift ;

  &get_config ($sys, \@ARGV) if ($opt{use_config} and $doconfig) ;

  print "\@ARGV: @{ARGV}\n" if ($opt_debug) ;

  foreach my $i (0 .. $#ARGV) {
    ($ARGV[$i] =~ s/(-.*?)=(.*)/$1=\"$2\"/) if (($ARGV[$i] =~ /\s/) and ($ARGV[$i] !~ /-.*?="/)) ;
    ## print "$i $ARGV[$i]\n" ;
  }

  GetOptions (\%opt,
            'alias=s',
            'asm_diag_name=s',
            'asm_diag_path=s',
            'asm_diag_root=s@',
            'build!',
            'precompiled!',
            'gcc_args=s@',
            'uart_dmw!',
            'trap_offset=s',
            'config_cpp_args=s@',
            'config_rtl=s@',
            'copyall!',
            'debug!',
            'diaglist=s',
            'diaglist_cpp_args=s@',
            'jobcommand_name=s',
            'dryrun!',
            'dv_root=s',
            'fast_boot!',
            'finish_mask=s',
            'flist=s@',
            'group=s@',
            'group_name=s',
            'gzip!',
            'icv_build!',
            'icv_build_args=s@',
            'icv_run!',
            'image_diag_name=s',
            'image_diag_path=s',
            'image_diag_root=s@',
            'injobq!',
            'interactive!',
            'max_cycle=i',
            'midas_args=s@',
            'midas_only!',
            'midas_use_tgseed!',
            'model=s',
            'model_dir=s',
            'msm_build!',
            'msm_build_args=s@',
            'msm_run!',
            'network_config=s',
            'ncv_build!',
            'ncv_build_args=s@',
            'ncv_run!',
            'overwrite!',
            'pal_use_tgseed!',
            'parallel!',
            'post_process_cmd=s@',
            'pre_process_cmd=s@',
            'reg_count=i',
            'regress!',
            'regress_date=s',
            'regress_id=s',
            'regress_time=s',
            'report!',
            'rerun!',
            'result_dir=s',
            'riv_build!',
            'riv_build_args=s@',
            'riv_run!',
            'rtl_timeout=i',
            'run_diag_pl!',
            'rv32!',
            'rv32_mabi=s',
            'rv32_march=s',
            'rv32_target_triple=s',
            'rv64!',
            'rv64_mabi=s',
            'rv64_march=s',
            'rv64_target_triple=s',
            'rv64_platform!',
            'other_sim_build!',
            'sim_build_args=s@',
            'other_sim_build_cmd=s',
            'other_sim_run!',
            'sim_run_args=s@',
            'other_sim_run_cmd=s',
            'sim_type=s',
            'sim_q_command=s',
            'sims_config=s',
            'simslog!',
            'simslog_name=s',
            'sparcv9!',
            'sys=s',
            'tg_seed=i',
            'tmp_dir=s',
            'toplevel=s@',
            'tarcopy!',
            'use_config!',
            'vcs_build!',
            'vcs_build_args=s@',
            'clean!',
            'vcs_cm_args=s',
            'vcs_cm_cond=s',
            'vcs_cm_config=s',
            'vcs_cm_fsmcfg=s',
            'vcs_cm_merge!',
            'vcs_cm_name=s',
            'vcs_prof!',
            'build_id=s',
            'vcs_run!',
            'vcs_use_cli!',
            'vcs_use_cm!',
            'vcs_use_initreg!',
            'verbose!',
            'vfile=s@',
            'vlt_build!',
            'vlt_build_args=s@',
            'vlt_run!',
            'num_tile=s',
            'x_tiles=s',
            'y_tiles=s',
            'dynamic_csm=s',
            'gui!',
            'log_all!',
            'debug_all!',
            'ibm!',
            'ed_enable!',
            'ed_sync_method=s',
            'slurm!',
            'dmbr!',
            'dmbr_checker!',
            'oram!',
           );

  # print out all command line arguments + config arguments
  # if debugging is enabled

  if ($opt_debug) {
    print "Command Line Arguments:\n" ;
    print "Key  Value\n" ;

    foreach my $key (keys %opt) {
      if (defined $opt{$key}) {
        if (ref ($opt{$key}) eq "ARRAY") {
          print "$key  @{$opt{$key}}\n" ;
        } elsif (ref ($opt{$key}) eq "SCALAR") {
          print "$key  ${$opt{$key}}\n";
        } else {
          print "$key  $opt{$key}\n";
        }
      }
    }

    print "\@ARGV: @ARGV\n" ;
  }


  my @configurables = (
    "config_l1i_size",
    "config_l1i_associativity",
    "config_l1d_size",
    "config_l1d_associativity",
    "config_l15_size",
    "config_l15_associativity",
    "config_l2_size",
    "config_l2_associativity",
    );

  foreach my $config (@configurables) {
    GetOptions (\%opt,
            "${config}=s",
    );
    my $ucn = uc($config);
    if ($opt{$config}) {
        $ENV{$ucn} = $opt{$config};
    }
  }

  $ENV{PROTOSYN_RUNTIME_DESIGN_PATH} = $ENV{DV_ROOT} . "/verif/env/manycore";
  $ENV{PROTOSYN_RUNTIME_BOARD} = "";


  # these arguments may not have any options associated with them
  foreach my $x (@ARGV) {
    if ($x =~ /\.s/)        { $opt{asm_diag_name}   = $x ; }
    elsif ($x =~ /\.S/)     { $opt{asm_diag_name}   = $x ; }
    elsif ($x =~ /\.riscv/) { $opt{asm_diag_name}   = $x ; }
    elsif ($x =~ /\.pal/)   { $opt{asm_diag_name}   = $x ; }
    elsif ($x =~ /\.s\.gz/) { $opt{asm_diag_name}   = $x ; }
    elsif ($x =~ /\.image/) { $opt{image_diag_name} = $x ; }
    elsif ($x =~ /\.c/)     { $opt{asm_diag_name}   = $x ; }
    else { die ("DIE. Unprocessed argument: $x") ; }
  }

  # in case a precompiled riscv binary is directly specified
  if ($opt{precompiled} and ($opt{rv32} | $opt{rv64})) {
    if (!($opt{asm_diag_name} =~ /\.riscv/)) {
        $opt{asm_diag_name} = fileparse($opt{asm_diag_name}, qr/\.[^.]*/);
    }
    print "$prg: looking for precompiled RISCV binary $opt{asm_diag_name}\n";
  }

  # if -nobuild specified disable all build options
  if ($opt{build} == 0) {
    $opt{vcs_build} = 0 ;
    $opt{ncv_build} = 0 ;
    $opt{icv_build} = 0 ;
    $opt{msm_build} = 0 ;
	$opt{riv_build} = 0 ;
    $opt{vlt_build} = 0 ;
    $opt{other_sim_build} = 0 ;
  }

  # generate a random number generator seed if not specified
  # $opt{tg_seed} = int(rand (hex("ffffffff"))) if ($opt{tg_seed} == -1) ;

  if ($opt{tg_seed} == -1) {
    my $seed ;
    open (RANDOM, "< /dev/random") or die "DIE. Could not open /dev/random" ;
    sysread (RANDOM, $seed, 4) ;
    close (RANDOM) ;
    $opt{tg_seed} =  int(unpack ("L*", $seed)) ;
    if ($opt{tg_seed} == 0) {
        $opt{tg_seed} = int(rand(hex("ffffffff")));
    }
  }

  if (!$opt{pal_use_tgseed}) {
    $opt{tg_seed} = 0;
  }
  print "$prg: using random seed $opt{tg_seed}\n" ;

  # PITON flag: disables PLL if sim_pll is not set
  push (@{$opt{config_rtl}}, "USE_FAKE_PLL_AND_CLKMUX");
  # Disable IOs
  push (@{$opt{config_rtl}}, "USE_FAKE_IOS");

  # set up network_config defines
  if ($opt{network_config}) {
    if (($opt{network_config} eq "xbar_config") or ($opt{network_config} eq "2dmesh_config")) {
      $ENV{PITON_NETWORK_CONFIG}=$opt{network_config};
    } else {
      die ("DIE. network_config can only be xbar_config or 2dmesh_config");
    }
  } else {
    print "$prg: network_config not specified, assuming 2dmesh configuration\n";
    $ENV{PITON_NETWORK_CONFIG}="2d_mesh";
  }

  $ENV{PITON_OST1}     = $opt{ost1};
  $ENV{PITON_PICO}     = $opt{pico};
  $ENV{PITON_PICO_HET} = $opt{pico_het};
  $ENV{PITON_ARIANE}   = $opt{ariane};
  $ENV{PITON_RV64_PLATFORM}   = "1" if ($opt{rv64_platform});
  push (@{$opt{config_rtl}}, "PITON_PICO_HET") if ($opt{pico_het});

  my $pton_x_tiles="";
  my $pton_y_tiles="";
  my $pton_num_tiles="";

  # conveniently sets up the tile RTL defines for manycore model
  if ($opt{x_tiles} && $opt{y_tiles}) {
    die ("DIE. x_tiles can be at most 256") if ($opt{x_tiles} > 256) ;
    die ("DIE. y_tiles can be at most 256") if ($opt{y_tiles} > 256) ;

    $pton_x_tiles=$opt{x_tiles};
    $pton_y_tiles=$opt{y_tiles};
    $pton_num_tiles=($opt{x_tiles} * $opt{y_tiles});
  } else {
    print "$prg: x_tiles and y_tiles not defined, assuming x dimension is <= 8\n" ;
    if (! $opt{num_tile}) {
        print "$prg: num_tile not defined, assuming just one tile\n" ;
        $opt{num_tile} = 1;
    }

    $pton_x_tiles=(($opt{num_tile}-1)%8)+1;
    $pton_y_tiles=(($opt{num_tile}-1)/8)+1;
    $pton_num_tiles=$opt{num_tile};
  }

  for (my $i=0; $i < $pton_num_tiles; $i++) {
    push (@{$opt{config_rtl}}, "RTL_TILE" . $i);
    if ($opt{pico} || ($opt{pico_het} && ($i % 2 == 1))) {
        push (@{$opt{config_rtl}}, "RTL_PICO" . $i);
    } elsif ($opt{ariane}) {
        push (@{$opt{config_rtl}}, "RTL_ARIANE" . $i);
    } elsif ($opt{ost1}) {
        push (@{$opt{config_rtl}}, "RTL_SPARC" . $i);
    }
  }

  $ENV{PITON_X_TILES}=$pton_x_tiles;
  $ENV{PITON_Y_TILES}=$pton_y_tiles;
  $ENV{PITON_NUM_TILES}=$pton_num_tiles;
  if($opt{dynamic_csm}) {
    $ENV{PITON_DYNAMIC_CSM}=$opt{dynamic_csm};
    push (@{$opt{midas_args}}, "-DDYNAMIC_CSM=$opt{dynamic_csm}");
  } else {
    $ENV{PITON_DYNAMIC_CSM}=0;
  }

  push (@{$opt{midas_args}}, "-DPITON_X_TILES=$pton_x_tiles");
  push (@{$opt{midas_args}}, "-DPITON_Y_TILES=$pton_y_tiles");
  push (@{$opt{midas_args}}, "-DPITON_NUM_TILES=$pton_num_tiles");

  # Alexey: set default value for UART_DIV_LATCH define
  if (index("@{$opt{midas_args}}", "UART_DIV_LATCH") == -1) {
    print "$prg: Setting UART_DIV_LATCH to 0xb\n";
    push (@{$opt{midas_args}}, "-DUART_DIV_LATCH=0xb");
  }

  #
  push (@{$opt{sim_run_args}}, "-gui") if ($opt{gui}) ;
  push (@{$opt{vcs_build_args}}, "-debug_all") if ($opt{debug_all}) ;

  # Push optional execution drafting enable
  push (@{$opt{midas_args}}, "-DED_ENABLE") if ($opt{ed_enable});

  # Push optional execution drafting sync method
  if ($opt{ed_sync_method}) {
    push (@{$opt{midas_args}}, "-DED_SYNC_METHOD_STSM") if ($opt{ed_sync_method} eq "stsm");
    push (@{$opt{midas_args}}, "-DED_SYNC_METHOD_RTSM") if ($opt{ed_sync_method} eq "rtsm");
    push (@{$opt{midas_args}}, "-DED_SYNC_METHOD_HTSM") if ($opt{ed_sync_method} eq "htsm");
  }

  # Push optional dmbr enable
  push (@{$opt{midas_args}}, "-DDMBR_ENABLE") if ($opt{dmbr});

  if ($opt{vcs_build} or $opt{ncv_build} or $opt{riv_build}) {
      push(@{$opt{config_rtl}}, "OST1_PLI_SLAM_RANDOM") ;
      push(@{$opt{config_rtl}}, "OST1_PLI_MRA_VAL") ;
  }

}

################################################################################
# get options from the diaglist if necessary
################################################################################

sub get_opt_from_diaglist
{
    # put the pre-processed diaglist in here
    die ("DIE. Diag list $diaglist not found") if (! -f $diaglist) ;

    print "$prg: processing diaglist ($diaglist)..\n" ;
    my $diagcppargs = join(' ', @{$opt{diaglist_cpp_args}});
    system ("bw_cpp -B -undef $diagcppargs -I$dv_root/verif/diag $diaglist > master_diaglist") ;
    die  ("DIE. Could not pre-process the master_diaglist") if ($?) ;

    # open the diaglist and look for the group in it

    my $diagList = DiagList->new ("master_diaglist") ;
    my $group = $diagList->find_group (${$opt{group}} [0]) ;

    die ("DIE. Group name $opt{group} not found in diag list $diaglist") if (! defined $group) ;

    my @tags =  $group->build_tags () ;

    die ("DIE. Group name $opt{group} corrresponds to multiple build tags") if ($#tags > 0) ;

    my $tag = $tags [0] ;
    my $buildargs = $diagList->build_args ($tag) ;
    my ($sys) = ($buildargs =~ /sys\s*=\s*([a-z0-9_]+)\s*/i) ;

    foreach my $diagname ($group->list_diags($tag)) {
      my $diag    = $group->find_diag($tag, $diagname) ;
      my $alias = $diag->get_name () ;

      if ($alias eq $opt{alias}) {
        my @runargs = $diag->get_cmd_argv() ;
        print "$prg: found alias $alias with arguments -sys=$sys @runargs\n" ;

        unshift (@ARGV, "-sys=$sys") ;
        unshift (@ARGV, @runargs) ;
        return ;
      }
    }

    die ("DIE. The alias $opt{alias} could not be found in the diaglist") ;
}

sub usage
{

print <<EOF;

NAME

sims - Verilog rtl simulation environment and regression script

SYNOPSIS

 sims [args ...]
  where args are:

NOTE: Use "=" instead of "space" to separate args and their options.

SIMULATION ENV

    -sys=NAME
            sys is a pointer to a specific testbench configuration
            to be built and run. a config file is used to associate
            the sys with a set of default options to build the
            testbench and run diagnostics on it. the arguments
            in the config file are the same as the arguments passed
            on the command line.

    -group=NAME
            group name identifies a set of diags to run in a
            regression. The presence of this argument indicates
            that this is a regession run. the group must be found
            in the diaglist. multiple groups may be specified to be
            run within the same regression.

    -group=NAME -alias=ALIAS
            this combination of options gets the diag run time options
            from the diaglist based on the given group and alias.
            the group must be found in the diaglist. the alias is
            made up of diag_alias:name_tag. only one group should be
            specified when using this command format.

OPENPITON ARGUMENTS

    -sys=manycore -x_tiles=X -y_tiles=Y
            this combination of options for the "manycore" simulation
            model specifies a 2D mesh topology of tiles, with X tiles
            in the x dimension and Y tiles in the y dimension. If
            -x_tiles and -y_tiles is not specified, the default is
            X=1 and Y=1. The maximum value for both X and Y is 1024.

    -ed_enable
            enable Execution Drafting in each core.

    -ed_sync_method=SYNC_METHOD
            sets the Execution Drafting thread synchronization method (TSM)
            to SYNC_METHOD.  Possible values for SYNC_METHOD are "rtsm",
            "stsm", or "htsm".  The default is "stsm".  Please refer to
            the Execution Drafting paper or OpenPiton documentation for
            more information on TSMs.

    -ibm
            use simulation models from the IBM SRAM compiler.  These are not
            provided with the OpenPiton download, but if the user has access
            to download them, there is infrastructure for them to be dropped
            in and used.  Please refer to the OpenPiton documentation for more
            information on this option.

    -debug_all
            a shortcut for -vcs_build_args=-debug_all.  In Synopsys VCS, this
            causes the simulation model to be built with the -debug_all flag.
            This allows for the simulation to be run in the DVE environment,
            convenient for waveform viewing and debugging.

    -gui
            a shortcut for -sim_run_args=-gui.  In Synopsys VCS, this causes
            the simulation to be run within the DVE environment, convenient
            for waveform viewing and debugging.  When building the simulation
            model specified by the -sys option, the -debug_all argument
            must have been passed to sims.

    -log_all
            in a msm_run, this command logs all signals and dumps them to the "all-waves.wlf" file for later inspection with a wave viewer.

    -slurm -sim_q_command=sbatch
            specifies simulations should be submitted with the Simple Linux
            Utility for Resource Management (SLURM) and run in parallel. The
            -sim_q_command=sbatch must also be specified. The -jobcommand_name
            argument may also be used to specify the job name.

VERILOG COMPILATION RELATED

    -sim_type=vcs/ncv/icv/msm/vlt/riv
         defines which simulator to use vcs, ncverilog, icarus, modelsim, riviera, or verilator, defaults to vcs.

    -sim_q_command="command"
         defines which job queue manager command to use to launch jobs.
          Defaults to /bin/sh and runs simulation jobs on the local machine.

    -ncv_build/-noncv_build
           builds a ncverilog model. defaults to off.

    -ncv_build_args=OPTION
           ncverilog compile options. multiple options can be specified using
           multiple such arguments.

    -icv_build/-noicv_build
           builds an icarus model. defaults to off.

    -icv_build_args=OPTION
           icarus compile options. multiple options can be specified using
           multiple such arguments.

    -msm_build/-nomsm_build
           builds a modelsim model. defaults to off.

    -msm_build_args=OPTION
           modelsim compile options. multiple options can be specified using
           multiple such arguments.

    -riv_build/-noriv_build
           builds a riviera model. defaults to off.

    -riv_build_args=OPTION
           riviera compile options. multiple options can be specified using
           multiple such arguments.		   
		   
    -vlt_build/-novlt_build
           builds a verilator model. defaults to off.

    -vlt_build_args=OPTION
           modelsim compile options. multiple options can be specified using
           multiple such arguments.

    -vcs_build/-novcs_build
           builds a vcs model. defaults to off.

    -vcs_build_args=OPTION
           vcs compile options. multiple options can be specified using
           multiple such arguments.

    -clean/-noclean
           wipes out the model directory and rebuilds it from scratch.
           defaults to off.

    -vcs_use_initreg/-novcs_use_initreg
           initialize all registers to a valid state (1/0).
           this feature works with -tg_seed to set the seed of the random
           initialization. this defaults to off.

    -vcs_use_cli/-novcs_use_cli
           use the +cli -line options when building a vcs model (simv).
           defaults to off.

    -flist=FLIST
           full path to flist to be appended together to generate the
           final verilog flist. multiple such arguments may be used and
           each flist will be concatenated into the final verilog flist
           used to build the model.

    -vfile=FILE
           verilog file to be included into the flist

    -config_rtl=DEFINE
           each such parameter is place as a `define in config.v to
           configure the model being built properly. this allows
           each testbench to select only the rtl code that it needs
           from the top level rtl file.

    -model=NAME
           the name of a model to be built. the full path to a model
           is $ENV{MODEL_DIR}/model/build_id.

    -build_id=NAME
           specify the build id of the model to be built. the full path
           to a model is $ENV{MODEL_DIR}/model/build_id.

    -ost1
           set by default - this specifies that the OpenSPARC T1 core will be used.
           in this case, programs are compiled and assembled using midas

    -pico
           this specifies that the PICORV32 core shall be used
           in this case, programs are compiled and assembled using the RISCV GCC toolchain.

    -pico_het
           this specifies that a heterogeneous arrangement with OpenSPARC and PICORV32 shall be built,
           where every odd core is a PICORV32 core (along the x-dimension).

    -ariane
           this specifies that the ARIANE RV64GC core shall be used
           in this case, programs are compiled and assembled using the RISCV GCC toolchain.

VERILOG RUNTIME RELATED

    -vcs_run/-novcs_run
           runs the vcs simulation (simv). defaults to off.

    -sim_run_args=OPTION
           sim runtime options. multiple options can be specified
           using multiple such arguments.

    -fast_boot/-nofast_boot
           speeds up booting when using the ciop model. this passes the
           +fast_boot switch to the simv run and the -midas_args=-DFAST_BOOT
           to midas. Also sends -DFAST_BOOT to the diaglist and config
           file preprocessors.

    -rerun
           rerun the simulation from an existing regression run directory.

    -post_process_cmd=COMMAND
           post processing command to be run after vcs (simv) run completes

    -pre_process_cmd=COMMAND
           pre processing command to be run before vcs (simv) run starts

MIDAS

midas is the diag assembler

    -midas_args=DARGS
           arguments for midas. midas creates memory image and user-event
           files from the assembly diag.

    -midas_only
           Compile the diag using midas and exit without running it.

    -midas_use_tgseed
           Add -DTG_SEED=tg_seed to midas command line. Use -tg_seed to
           set the value passed to midas or use a random value from /dev/random.

RISCV GCC

this is the compiler used for RISC-V cores

    -uart_dmw
           use this switch when compiling code for Pitonstream. this will add load
           instructions to magic addresses in the pass/fail exit functions in order to signal
           PASS/FAIL to the UART-DMW module.

    -precompiled
           specify this in order to use pre-built assembly tests and benchmarks from the RISC-V toolchain folder.
           combined with -ariane, this basically adds the two search paths
             $ENV{ARIANE_ROOT}/tmp/riscv-tests/build/isa
             $ENV{ARIANE_ROOT}/tmp/riscv-tests/build/benchmarks
           to @{$opt{asm_diag_root}}, and skips the compilation step.

    -gcc_args
           additional gcc arguments

    -rv32_target_triple
           specifies rv32 cross-compiler prefix (e.g. riscv32-unknown-elf)
           default varies by core

    -rv32_march
           specifies rv32 march string (e.g. rv32ima)
           default varies by core

    -rv32_mabi
           specifies rv32 mabi string (e.g. ilp32)
           default varies by core

    -rv64_target_triple
           specifies rv64 cross-compiler prefix (e.g. riscv64-unknown-elf)
           default varies by core

    -rv64_march
           specifies rv64 march string (e.g. rv64imafdc)
           default varies by core

    -rv64_mabi
           specifies rv64 mabi string (e.g. lp64d)
           default varies by core

VCS COVERMETER

    -vcs_use_cm/-novcs_use_cmd
           passes in the -cm switch to vcs at build time and simv at runtime
           default to off.

    -vcs_cm_args=ARGS
           argument to be given to the -cm switch

    -vcs_cm_cond=ARGS
           argument to be given to the -cm_cond switch.

    -vcs_cm_config=ARGS
           argument to be given to the -cm_hier switch

    -vcs_cm_fsmcfg=ARGS
           argument to be given to the -cm_fsmcfg switch
          specifies an FSM coverage configuration file

    -vcs_cm_name=ARGS
           argument to be given to the -cm_name switch. defaults to cm_data.

MISC

    -nobuild
          this is a master switch to disable all building options.
          there is no such thing as -build to enable all build options.

    -copyall/-nocopyall
          copy back all files to launch directory after passing
         regression run.  Normally, only failing runs cause a
         copy back of files.
         Default is off.

    -tarcopy/-notarcopy
          copy back files using 'tar'. This only works in copyall or
          in the case the simulations 'fails' (per sims' determination).
          Default is to use 'cp'.

    -pal_use_tgseed
           Send '-seed=<tg_seed_value> to pal diags.  Adds
           -pal_diag_args=-seed=tg_seed to midas command line, and
           -seed=tg_seed to pal options (vrpal diags). Use -tg_seed to set
           the value passed to midas or use a random value from /dev/random.

    -parallel
            when specifying multiple groups for regressions this switch will
            submit each group to Job Q manager to be executed as a
            separate regression. This has the effect of speeding up
            regression submissions.
            NOTE: This switch must not be used with -injobq

    -reg_count=COUNT
            runs the specified group multiple times in regression mode. this
            is useful when we want to run the same diag multiple times using
            a different random generator seed each time or some such.

    -regress_id=ID
            specify the name of the regression

    -report
            This flag is used to produce a report of a an old or running
            regression. With -group options, sims produces the report
            after the regression run. Report for the previous
            regression run can be produced using -regress_id=ID
            option along with this option,

    -finish_mask=MASK
           masks for vcs simulation termination. Simulation terminates
           when it hits 'good_trap' or 'bad_trap'. For multithread
           simulation, simulation terminates when any of the thread
           hits bad_trap, or all the threads specified by the finish_mask
           hits the good_trap.
           example: -finish_mask=0xe
           Simulation will be terminated by good_trap, if thread 1, 2 and
           3 hits the good_trap.

    -rtl_timeout
           passes a +TIMEOUT to the simv run.
           sets the number of clock cycles after all threads have become
           inactive for the diag to exit with an error. if all threads hit
           good trap on their own the diag exits right away. if any of the
           threads is inactive without hitting good trap/bad trap the
           rtl_timeout will be reached and the diag fails. default is 5000.
           this is only implemented in the cmp based testbenches.

    -max_cycle
           passes a +max_cycle to the simv run.
           sets the maximum number of clock cycle that the diag will take
           to complete. the default is 30000. if max_cycle is hit the diag
           exits with a failure. not all testbenches implement this
           feature.

    -norun_diag_pl
           Does not run diag.pl (if it exists) after simv (vcs) run.
           Use this option if, for some reason, you want to run an
          existing assembly diag without the Perl part that is in
          the original diag.

    -nosimslog
           turns off redirection of stdout and stderr to the sims.log file.
           use this option to get to the cli prompt when using vcs or to
           see a truncated sim.log file that exited with an error. this
           must be used if you want control-c to work while vcs is running.

    -nogzip
           turns off compression of log files before they are copied over
           during regressions.

    -version
            print version number.

    -help
            prints this

IT SYSTEM RELATED

    -dv_root=PATH
            absolute path to design root directory. this overrides DV_ROOT.

    -model_dir=PATH
            absolute path to model root directory. this overrides MODEL_DIR.

    -tmp_dir=PATH
            path where temporary files such as debussy dumps will be created

    -sims_config=FILE
            full path to sims config file

    -config_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the testbench configuration file is
            processed through cpp. Multiple options are concatenated
            together.

    -result_dir=PATH
            this allows the regression run to be launched from a different
            directory than the one sims was launced from. defaults to
            $ENV{PWD}.

    -diaglist=FILE
            full path to diaglist file

    -diaglist_cpp_args=OPTION
            this allows the user to provide CPP arguments (defines/undefines)
            that will be used when the diaglist file is processed through
            cpp. Multiple options are concatenated together.

    -asm_diag_name=NAME
    -image_diag_name=NAME
            name of the diagnostic to be run.

    -asm_diag_root=PATH
    -image_diag_root=PATH
            absolute path to diag root directory. sims will perform a find
            from here to find the specified type of diag. if more than one
            instance of the diag name is found under root sims exits with
            an error. this option can be specified multiple times to allow
            multiple roots to be searched for the diag.

    -asm_diag_path=PATH
    -image_diag_path=PATH
            absolute path to diag directory. sims expects the specified
            diag to be in this directory. the last value of this option
            is the one used as the path.

ENV VARIABLES

sims sets the following ENV variables that may be used with pre/post
processing scripts, and other internal tools:

    ASM_DIAG_NAME   : Contains the assembly diag name.
    SIMS_LAUNCH_DIR : Path to launch directory where sims is running the
                      job.

    DV_ROOT         : -dv_root if specifed
    MODEL_DIR       : -model_dir if specified
    TRE_SEARCH      : Based on -use_iver, -use_sims_iver
    VCS_HOME        : User defined

PLUSARGS

+args are not implemented in sims. they are passed directly to vcs at
compile time and simv at runtime. the plusargs listed here are for
reference purposes only.

    +max_cycle see -max_cycle

    +TIMEOUT   see -rtl_timeout

DESCRIPTION

sims is the frontend for vcs to run single simulations and regressions

HOWTO

Build models

Build a vcs model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_build

Build a ncverilog model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -ncv_build

Build an icarus model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -icv_build

Build a modelsim model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -msm_build
  
Build a riviera model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -riv_build  

Build a verilator model using DV_ROOT as design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vlt_build

Build a model from any design root

  sims -sys=manycore -x_tiles=1 -y_tiles=1
       -vcs_build -dv_root=/home/regress/2002_06_03

Build a model and turn off incremental compile

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_build -clean

Build a model with a given name

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_build -build_id=mymodel

Run models

Run a diag with default model

  sims -sys=manycore -x_tiles=1 -y_tiles=1 -vcs_run diag.s

Run a diag with a specified model

  sims -sys=manycore -x_tiles=1 -y_tiles=1
       -build_id=mymodel -vcs_run diag.s

Run regressions

Run a regression using DV_ROOT as design root

  sims -group=tile1_mini

Run a regression using DV_ROOT as design root and specify the diaglist

  sims -group=tile1_mini -diaglist=/home/user/my_dialist

Run a regression using any design root

  sims -group=tile1_mini -dv_root=/import/design/regress/model/2002_06_03

EOF
}
__END__
