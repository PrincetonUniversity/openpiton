#!/usr/bin/env python3
# Copyright (c) 2015 Princeton University
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of Princeton University nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#####################################################################
#  Filename      : protosyn.py
#  Version       : 2.5
#  Created On    : 2014-05-10
#  Author        : Alexey Lavrov
#  Company       : Princeton University
#  Email         : openpiton@princeton.edu
#
#  Description   : top level script for Piton synthesis flow
#
#####################################################################

import os, sys, re, make_mem_map, subprocess, stat, time
import image2stream as i2s
from optparse import OptionParser
from fpga_lib import *
from dbg import *

DV_ROOT = os.environ['DV_ROOT']
MODEL_DIR = os.environ['MODEL_DIR']
DESIGN_BLOCK_LIST = os.path.join(DV_ROOT, "tools/src/proto/block.list")
BOARD_TOOL_LIST = os.path.join(DV_ROOT, "tools/src/proto/board.list")
PROJECT_BUILD_LOG = "make_project.log"
PROJECT_IMPL_LOG = "implementation.log"

FLOW_STEP_OPTIONS = ["project", "impl"]

def usage():
    print(file=sys.stderr)
    print("Usage:\nprotosyn -b <board_type> [-d <design>] [--bram-test <test_name>]", end=' ', file=sys.stderr)
    print("[--from <FPGA flow step>] [--to <FPGA flow step>] [--no-ddr] [--uart-dmw ddr] [--eth] [--oled <string>]", file=sys.stderr)
    print(file=sys.stderr)
    print("       -b, --board  <board_type>", file=sys.stderr)
    print("              Name of a supported Xilinx's development board. Available options are:", file=sys.stderr)
    print("                  vc707", file=sys.stderr)
    print("                  vcu118", file=sys.stderr)
    print("                  xupp3r", file=sys.stderr)
    print("                  genesys2", file=sys.stderr)
    print("                  nexysVideo", file=sys.stderr)
    print("                  f1", file=sys.stderr)
    print("                  alveou200", file=sys.stderr)
    print("                  alveou250", file=sys.stderr)
    print("\n       -d, --design <design>", file=sys.stderr)
    print("              Name of design module to synthesize.  The default is 'system', which", file=sys.stderr)
    print("              synthesizes a full system with chip and chipset. See", file=sys.stderr)
    print("              $DV_ROOT/tools/src/proto/block.list for supported design modules", file=sys.stderr)
    print("\n       -c, --core <core_config>", file=sys.stderr)
    print("              Name of a supported core configuration:", file=sys.stderr)
    print("                  sparc     (opensparc T1 core, default)", file=sys.stderr)
    print("                  pico      (32bit RISCV core)", file=sys.stderr)
    print("                  pico_het  (heterogeneous pico+sparc arrangement)", file=sys.stderr)
    print("                  ariane    (64bit RISCV core)", file=sys.stderr)
    print("\n       --network_config <network_config>", file=sys.stderr)
    print("              Name of the network type to be used:", file=sys.stderr)
    print("                  2dmesh_config (default)", file=sys.stderr)
    print("                  xbar_config", file=sys.stderr)
    print("\n       --x_tiles <number>", file=sys.stderr)
    print("       --y_tiles <number>", file=sys.stderr)
    print("              Number of tiles to instantiate in each direction. Default: 1.", file=sys.stderr)
    print("       --num_tiles <number>", file=sys.stderr)
    print("              Total number of tiles. Default: 1.", file=sys.stderr)
    print("              In case the x/y tile defaults are not overridden, this creates an arrangement assuming x_tiles<=8.", file=sys.stderr)
    print("\n       --config_l1i_size <number>", file=sys.stderr)
    print("       --config_l1d_size <number>", file=sys.stderr)
    print("       --config_l15_size <number>", file=sys.stderr)
    print("       --config_l2_size <number>", file=sys.stderr)
    print("              Cache sizes in bytes, defaults: 8192 (L1D/L1.5), 16384 (L1I), 65536 (L2)", file=sys.stderr)
    print("\n       --config_l1i_associativity <number>", file=sys.stderr)
    print("       --config_l1d_associativity <number>", file=sys.stderr)
    print("       --config_l15_associativity <number>", file=sys.stderr)
    print("       --config_l2_associativity  <number>", file=sys.stderr)
    print("              Cache associativities, default: 4", file=sys.stderr)
    print("\n       --bram-test <test_name>", file=sys.stderr)
    print("              Name of the test to be mapped into BRAM", file=sys.stderr)
    print("\n       --no-ddr", file=sys.stderr)
    print("              Implement design without DDR memory", file=sys.stderr)
    print("\n       --eth", file=sys.stderr)
    print("              Add Ethernet controller to implementation", file=sys.stderr)
    print("\n       --uart-dmw <storage type>", file=sys.stderr)
    print("              Implement design with Direct Memory Write (DMW) from UART module turned on.", file=sys.stderr)
    print("              Storage type: \"ddr\"", file=sys.stderr)
    print("\n       --uart-reset", file=sys.stderr)
    print("              Attach UART traffic sniffer to the uart port. This sniffer will send", file=sys.stderr)
    print("              the reset signal to the whole system if it sees magic sequence 0x9a337213af278f34", file=sys.stderr)
    print("\n       --asic-rtl", file=sys.stderr)
    print("              Implement design with ASIC RTL.", file=sys.stderr)
    print("\n       --chip-bridge", file=sys.stderr)
    print("              Implement full system including the chip bridge", file=sys.stderr)
    print("\n       --inc-passthru", file=sys.stderr)
    print("              Include passthru between chip and chipset (requires --chip-bridge)", file=sys.stderr)
    print("\n       --passthru-dec", file=sys.stderr)
    print("              Use decode version of passthru (requires --inc-passthru if design", file=sys.stderr)
    print("              is not 'passthru' or 'passthru_loopback')", file=sys.stderr)
    print("\n       --passthru-dec-uart-pkttrace", file=sys.stderr)
    print("              Dumps packet trace seen by decode version of passthrough to UART", file=sys.stderr)
    print("              for debugging (requires --passthru-dec)", file=sys.stderr)
    print("\n       --define <comma separated list of defines>", file=sys.stderr)
    print("              Comma separated list of custom Verilog macro defines", file=sys.stderr)
    print("\n       --linux_bootrom [zsbl|uboot]", file=sys.stderr)
    print("              Choose the Linux bootrom to be used (default zsbl).", file=sys.stderr)
    print("\n       --make-mem-map", file=sys.stderr)
    print("              Create a mapping of test specified by --bram-test option to a BRAM", file=sys.stderr)
    print("\n       --from <step>", file=sys.stderr)
    print("              Start FPGA flow from a specified step. Available options are:", file=sys.stderr)
    print("                  project", file=sys.stderr)
    print("                  impl", file=sys.stderr)
    print("\n       --to  <step>", file=sys.stderr)
    print("              Run FPGA flow to a specified step (including). Available options are:", file=sys.stderr)
    print("                  project", file=sys.stderr)
    print("                  impl", file=sys.stderr)
    print("\n       --oled <string>", file=sys.stderr)
    print("\n            String to be displayed on OLED display.", file=sys.stderr)
    print("\n            (Genesys2 and nexysVideo boards only", file=sys.stderr)
    print("\n       --slurm", file=sys.stderr)
    print("              Run steps of flow using SLURM job scheduler", file=sys.stderr)
    print("\n       --swait", file=sys.stderr)
    print("\n            Wait for slurm jobs to finish", file=sys.stderr)
    print("\n       -j, --jobs", file=sys.stderr)
    print("              Number of jobs to use in Vivado implementation flow", file=sys.stderr)
    print("\n       --postroutephysopt", file=sys.stderr)
    print("              Use post-route physical optimisation in Vivado implementation flow (can improve timing, not recommended by default)", file=sys.stderr)
    print("\n       -h, --help", file=sys.stderr)
    print("              Display this help message and exit", file=sys.stderr)
    print("\n", file=sys.stderr)

def slurm_launch(cmd, log, tpn, mem_mb, time_str, jname, dep_list) :
    # Write slurm batch file
    slurm_file = jname + ".slurm"
    fp = open(slurm_file, "w")
    fp.write("#!/bin/sh\n")
    fp.write("#SBATCH -N 1                          # nodes=1\n")
    fp.write("#SBATCH --ntasks-per-node=%d          # ppn=%d\n" % (tpn, tpn))
    fp.write("#SBATCH --mem=%d                      # mem=%dMB\n" % (mem_mb, mem_mb))
    fp.write("#SBATCH -t %s                         # walltime=%s\n" % (time_str, time_str))
    fp.write("#SBATCH -J %s                         # jobname=%s\n\n" % (jname, jname))

    fp.write(' '.join(cmd) + " > " + log)

    fp.close()
    os.chmod(slurm_file, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)

    # Submit job, retrying on fails
    slurm_cmd = ["sbatch"]
    if dep_list != None and len(dep_list) > 0:
        slurm_cmd.append("--dependency=afterok:" + ':'.join([str(dep) for dep in dep_list]))
    slurm_cmd.append(slurm_file)
    proc = subprocess.Popen(slurm_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = proc.communicate()
    while proc.returncode != 0:
        print_warning("Submit failed, retrying in 30 seconds...")
        time.sleep(30)
        print_warning("Retrying...")
        proc = subprocess.Popen(slurm_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = proc.communicate()

    # Get job ID and return for dependencies
    match = re.match(r"b'Submitted batch job (\d+)\\n'", str(out))
    if match:
        print_info("Submitted batch job %s" % str(match.group(1)))
        return str(match.group(1))
    else:
        print_error("Error submitting batch job")
        return None

def run_vivado(log, script, design_dir, board, slurm, tpn, mem_mb, time_str, jname, dep_list):
    # Variables passed to TCL scripts
    os.environ['PROTOSYN_RUNTIME_DESIGN_PATH'] = design_dir
    os.environ['PROTOSYN_RUNTIME_BOARD'] = board


    # use custom vivado version if provided
    if(os.environ.get('VIVADO_BIN')) is not None:
        cmd = os.environ['VIVADO_BIN'].split(" ") + ["-mode", "batch", "-source", script]
    else:
        cmd = ["vivado", "-mode", "batch", "-source", script]

    if slurm:
        return slurm_launch(cmd, log, tpn, mem_mb, time_str, jname, dep_list)
    else:
        flog = open(log, "w")
        subprocess.call(cmd, stdout=flog)
        flog.close()
        return None

def run_f1_script(log, design_dir, board, slurm, tpn, mem_mb, time_str, jname, dep_list):
    # Variables passed to TCL scripts
    os.environ['PROTOSYN_RUNTIME_DESIGN_PATH'] = design_dir
    os.environ['PROTOSYN_RUNTIME_BOARD'] = board

    cmd = [os.environ['CL_DIR']+"/build/scripts/aws_build_dcp_from_cl.sh", "-notify", "-clock_recipe_a", "A0", "-clock_recipe_b", "B1", "-clock_recipe_c", "C2"]
    if slurm:
        return slurm_launch(cmd, log, tpn, mem_mb, time_str, jname, dep_list)
    else:
        flog = open(log, "w")
        subprocess.call(cmd, stdout=flog)
        flog.close()
        return None

def run_ise(log, script, design_dir, board, slurm, tpn, mem_mb, time_str, jname, dep_list):
    # Variables passed to TCL scripts
    os.environ['PROTOSYN_RUNTIME_DESIGN_PATH'] = design_dir
    os.environ['PROTOSYN_RUNTIME_BOARD'] = board

    cmd = ["xtclsh", script]
    if slurm:
        return slurm_launch(cmd, log, tpn, mem_mb, time_str, jname, dep_list)
    else:
        flog = open(log, "w")
        subprocess.call(cmd, stdout=flog, stderr=flog)
        flog.close()
        return None

def runImplF1(board, design_data, src_dir, work_dir, log_dir, def_list, slurm, dep_list):
    prev_dir = os.getcwd()

    # Copy all sources in ppp/build/... , and set new CL_DIR
    os.system("rsync -raz --copy-links " + os.path.join(src_dir, "build") + " " + work_dir)
    if not os.path.exists(os.path.join(work_dir, "design", "xilinx")):
        os.makedirs(os.path.join(work_dir, "design", "xilinx"))
    os.system("rsync -raz --copy-links " + os.path.join(src_dir, "design", "cl_id_defines.vh") + " " + os.path.join(work_dir, "design"))
    os.system("rsync -raz --copy-links " + os.path.join(DV_ROOT, "design", "xilinx", "f1") + " " + os.path.join(work_dir, "design", "xilinx"))
    os.system("rsync -raz --copy-links " + os.path.join(DV_ROOT, "design", "xilinx", "design.tcl") + " " + os.path.join(work_dir, "design", "xilinx", "design.tcl"))
    os.environ["ORIGINAL_CL_DIR"] = os.environ["CL_DIR"]
    os.environ["CL_DIR"] = work_dir

    #hack to fight with aws scripts assuming we have SH_DDR in top module
    #aws_constraints_inpath = os.path.join(os.environ["HDK_SHELL_DIR"], "build", "constraints", "cl_synth_aws.xdc")
    #aws_constraints_outpath = os.path.join(os.environ["CL_DIR"], "build", "constraints", "cl_synth_aws.xdc")
    #os.system("sed 's/SH_DDR/sh_ddr/g' " + aws_constraints_inpath + " > " + aws_constraints_outpath)
    
    # Ok, lets go build staff finally
    os.chdir(os.path.join(work_dir, "build", "scripts"))

    # Generate additional defines file that will be sourced in tcl script
    f = open("additional_defines.tcl", "w")
    print("set PROTOSYN_RUNTIME_DEFINES \"%s\"" % ' '.join(def_list), file=f)
    f.close()

    tool = find_board_tool(board)

    #dname = board + "_piton"
    #os.chdir(dname)
    print_info("Generating DCP for AWS F1 in nohup")
    design_board_dir = os.path.join(design_data["PATH"], board)
    impl_log = os.path.join(log_dir, PROJECT_IMPL_LOG)
    jname = "protosyn_impl_%s_%s" % (board, design_data["ID"])
    jid = run_f1_script(impl_log, design_data["PATH"], board, \
                     slurm, 8, 64000, "6:00:00", jname, dep_list)
    print_info("Log available at %s" % os.path.join(os.getcwd(), "last_log"))

    os.chdir(prev_dir)

    return jid


def makeProject(board, design_data, work_dir, log_dir, slurm, dep_list):
    prev_dir = os.getcwd()

    os.chdir(work_dir)

    tool = find_board_tool(board)

    #os.system('cp -r $DV_ROOT/tools/src/proto/%s/* .' % board)
    #os.system('cp -r -n $DV_ROOT/tools/src/proto/common/* .')
    print_info("Building a project for design '%s' on board '%s'" % (design_data["ID"],board))
    proj_script = os.path.join(DV_ROOT, "tools/src/proto/" + tool + "/gen_project.tcl")
    proj_log = os.path.join(log_dir, PROJECT_BUILD_LOG)
    jname = "protosyn_mkproj_%s_%s" % (board, design_data["ID"])
    jid = None
    if (tool == "vivado"):
        jid = run_vivado(proj_log, proj_script, design_data["PATH"], board, \
                         slurm, 1, 4096, "1:00:00", jname, dep_list)
    elif (tool == "ise") :
        jid = run_ise(proj_log, proj_script, design_data["PATH"], board, \
                      slurm, 1, 4096, "1:00:00", jname, dep_list)

    os.chdir(prev_dir)

    return jid


def runImplFlow(board, design_data, work_dir, log_dir, def_list, slurm, dep_list):
    prev_dir = os.getcwd()

    os.chdir(work_dir)
    #f = open("flow", "w")
    #print >> f, "open_project %s_piton.xpr" % board
    #print >> sys.stderr, "Using next defines:"
    #all_def = ' '.join(DEFAULT_DEFINES) + ' ' + ' '.join(def_list)
    #print >> sys.stderr, all_def
    #print >> f, "set_property verilog_define \"%s\" [get_fileset sources_1]" % all_def
    ## dealing with Vivado case, when it locks IPs as old ones
    #print >> f, "upgrade_ip [get_ips -all]"
    #print >> f, "close_project"
    ## extra open/close to make Vivado use defines for a project,
    ## not only for synthesis
    #print >> f, "open_project %s_piton.xpr" % board
    #print >> f, "launch_run impl_1 -to_step write_bitstream"
    #f.close()

    # Generate additional defines file that will be sourced in tcl script
    f = open("additional_defines.tcl", "w")
    print("set PROTOSYN_RUNTIME_DEFINES \"%s\"" % ' '.join(def_list), file=f)
    f.close()

    tool = find_board_tool(board)

    #dname = board + "_piton"
    #os.chdir(dname)
    print_info("Running FPGA implementation down to bitstream generation")
    design_board_dir = os.path.join(design_data["PATH"], board)
    impl_log = os.path.join(log_dir, PROJECT_IMPL_LOG)
    impl_flow = os.path.join(DV_ROOT, "tools/src/proto/" + tool + "/impl_flow.tcl")
    jname = "protosyn_impl_%s_%s" % (board, design_data["ID"])
    jid = None
    if (tool == "vivado"):
        jid = run_vivado(impl_log, impl_flow, design_data["PATH"], board, \
                         slurm, 8, 64000, "6:00:00", jname, dep_list)
    elif (tool == "ise"):
        jid = run_ise(impl_log, impl_flow, design_data["PATH"], board, \
                      slurm, 8, 64000, "6:00:00", jname, dep_list)

    os.chdir(prev_dir)

    return jid


def find_board_tool(board):
    fp = open(BOARD_TOOL_LIST, 'r')
    for line in fp:
        # Check for comments
        if not re.match('\s*#.*', line) :
            # Process board line
            line_split = line.split()
            if line_split[0] == board:
                fp.close()
                return line_split[1]
    fp.close()

    return None

def checkCmdOptions(options):
    if (options.help):
        usage()
        sys.exit(0)

    # Check if design is specified
    # (It has a default value so always should be)
    if (options.design == None):
        print_error("Invalid parameters")
        usage()
        sys.exit(2)

    # Check if design module is found
    if options.board == "f1":
        design_data = find_design_block("piton_aws")
    else:
        design_data = find_design_block(options.design)
    if (design_data == None):
        print_error("Could not find design module '" + options.design + "'")
        usage()
        sys.exit(2)

    # Check if board name is provided
    if (options.board == None):
        print_error("Invalid parameters")
        usage()
        sys.exit(2)

    # Check if board is supported
    if (options.board not in design_data["BOARDS"]):
        print_error("Unsupported board")
        usage()
        sys.exit(2)

    # Check board exists in board list
    if (find_board_tool(options.board) == None):
        print_error("Board not specified in board.list")
        usage()
        sys.exit(2)

    # Check if FPGA steps are valid (if provided)
    if (options.from_step != None):
        if (options.from_step not in FLOW_STEP_OPTIONS):
            print_error("%s is not a valid FPGA flow step" % options.from_step)
            usage()
            sys.exit(2)

    if (options.to_step != None):
        if (options.to_step not in FLOW_STEP_OPTIONS):
            print_error("%s is not a valid FPGA flow step" % options.to_step);
            usage()
            sys.exit(2)

    if (options.inc_passthru and (not options.chip_bridge)):
        print_error("Conflicting options")
        usage()
        sys.exit(2)

    if (options.passthru_dec and ((not options.inc_passthru) and options.design != "passthru" and options.design != "passthru_loopback")):
        print_error("Conflicting options")
        usage()
        sys.exit(2)

    if (options.passthru_dec_uart_pkttrace and not options.passthru_dec):
        print_error("Conflicting options")
        usage()
        sys.exit(2)

    if (options.make_mem_map and (options.test_name == None)):
        print_error("Test name is required to make a mapping to a BRAM")
        usage()
        sys.exit(2)

    if options.uart_dmw not in ["bram", "ddr", None]:
        print_error("Unexpected storage type")
        usage()
        sys.exit(2)

    return design_data

def setParserOptions(parser):
    parser.add_option("-b", "--board", dest="board", action="store")
    parser.add_option("-d", "--design", dest="design", action="store", default="system")
    parser.add_option("-c", "--core", dest="core", action="store", default="sparc")
    parser.add_option("--network_config", dest="network_config", action="store", default="2dmesh_config")
    parser.add_option("--x_tiles", dest="x_tiles", action="store", default=1)
    parser.add_option("--y_tiles", dest="y_tiles", action="store", default=1)
    parser.add_option("--num_tiles", dest="num_tiles", action="store", default=1)
    parser.add_option("--config_l1i_size", dest="config_l1i_size", action="store", default=16384)
    parser.add_option("--config_l1d_size", dest="config_l1d_size", action="store", default=8192)
    parser.add_option("--config_l15_size", dest="config_l15_size", action="store", default=8192)
    parser.add_option("--config_l2_size", dest="config_l2_size",   action="store", default=65536)
    parser.add_option("--config_l1i_associativity", dest="config_l1i_associativity",   action="store", default=4)
    parser.add_option("--config_l1d_associativity", dest="config_l1d_associativity",   action="store", default=4)
    parser.add_option("--config_l15_associativity", dest="config_l15_associativity",   action="store", default=4)
    parser.add_option("--config_l2_associativity", dest="config_l2_associativity",   action="store", default=4)
    parser.add_option("--bram-test", dest="test_name", action="store")
    parser.add_option("--from", dest="from_step", action="store", default=None)
    parser.add_option("--to", dest="to_step", action="store", default=None)
    parser.add_option("--no-ddr", dest="no_ddr", action="store_true", default=False)
    parser.add_option("--eth", dest="eth", action="store_true", default=False)
    parser.add_option("--uart-dmw", dest="uart_dmw", action="store", default=None)
    parser.add_option("--uart-reset", dest="uart_reset", action="store_true", default=False)
    parser.add_option("--asic-rtl", dest="asic_rtl", action="store_true", default=False)
    parser.add_option("--chip-bridge", dest="chip_bridge", action="store_true", default=False)
    parser.add_option("--inc-passthru", dest="inc_passthru", action="store_true", default=False)
    parser.add_option("--passthru-dec", dest="passthru_dec", action="store_true", default=False)
    parser.add_option("--passthru-dec-uart-pkttrace", dest="passthru_dec_uart_pkttrace", action="store_true", default=False)
    parser.add_option("--define", dest="define", action="store", default=None)
    parser.add_option("--linux_bootrom", dest="linux_bootrom", action="store", default="zsbl")
    parser.add_option("--oled", dest="oled", action="store")
    parser.add_option("-j", "--jobs", dest="jobs", action="store", default=1)
    parser.add_option("-h", "--help", dest="help", action="store_true", default=False)
    parser.add_option("--gen-test-bram", dest="gen_test_bram", action="store_true", default=False)  # depricated ?
    parser.add_option("--make-mem-map", dest="make_mem_map", action="store_true", default=False)
    parser.add_option("--slurm", dest="slurm", action="store_true", default=False)
    parser.add_option("--swait", dest="swait", action="store_true", default=False)
    parser.add_option("--axi4_mem", dest="axi4_mem", action="store_true", default=False)
    parser.add_option("--zeroer_off", dest="zeroer_off", action="store_true", default=False)
    parser.add_option("--postroutephysopt", dest="postroutephysopt", action="store_true", default=False)

    return parser

def makeDefList(options):
    defines = list()

    #df = options.board.upper() + "_BOARD"
    #defines.append(df)

    # disable CSM in this case
    if options.core == 'ariane':
        defines.append("NO_RTL_CSM")

    if (options.board == "f1"):
        print_info("design option is ignored for f1")

    # --no-ddr option
    if (options.no_ddr == True) or (options.board == "piton_board"):
        defines.append("PITONSYS_NO_MC")
    else:   # default option
        defines.append("PITON_FPGA_MC_DDR3")

    # --axi4_mem option
    if (options.axi4_mem == True):
        if (options.board not in {"vc707", "xupp3r"}):
            print_warning("axi4_mem option is ignored without board != vc707 or board != xupp3r" )
        else:
            defines.append("PITONSYS_AXI4_MEM")      
        
    # --zeroer_off option
    if (options.zeroer_off == False):
        defines.append("PITONSYS_MEM_ZEROER")    

    # do not use SD controller if BRAM is used for boot or a test or if board doesn't have sd
    if (options.test_name != None) or (options.board in {"piton_board", "xupp3r", "f1", "alveou200", "alveou250"}):
        pass
    else:   # default option
        defines.append("PITON_FPGA_SD_BOOT")

    # --bram-test option
    if options.test_name != None:
        defines.append("PITON_FPGA_BRAM_TEST")
        defines.append("PITONSYS_NO_MC")

    # --uart-dmw option
    if options.uart_dmw == "ddr":
        defines.append("PITONSYS_UART_BOOT")
    elif options.uart_dmw == "bram":
        defines.append("PITONSYS_UART_BOOT")
        defines.append("PITON_FPGA_BRAM_TEST")

    if options.uart_reset == True:
        defines.append("PITONSYS_UART_RESET")

    # --asic-rtl option
    if options.asic_rtl == True:
        defines.append("PITON_ASIC_RTL")

    # --chip-bridge option
    if (options.board == "piton_board") and (options.design == "chipset"):
        pass
    # chip-bridge is used for chipset by default
    elif options.chip_bridge == False and options.design != "chipset":
        defines.append("PITON_NO_CHIP_BRIDGE")

    # --inc-passthru option
    if options.inc_passthru == True:
        defines.append("PITONSYS_INC_PASSTHRU")

    # --passthru-dec option
    if options.passthru_dec == True:
        defines.append("PITON_PASSTHRU_DEC")

    # --passthru-dec-uart-pkttrace option
    if options.passthru_dec_uart_pkttrace == True:
        defines.append("PITON_PASSTHRU_DEC_UART_PKTTRACE")

    if options.design == "passthru" or options.design == "passthru_loopback" or \
        options.design == "chip_bridge_test_chip":
        defines.append("PITONSYS_PASSTHRU_TOP")

    if options.design == "chipset":
        defines.append("PITONSYS_CHIPSET_TOP")

    # Custom defines
    if options.define != None:
        defines.extend(options.define.split(","))

    # Specific options for chipset implementations on piton_board:
    if options.design == "chipset":
        if options.board == "piton_board":
            defines.append("PITON_BOARD_CHIPSET")
        else:
            defines.append("PITON_ASIC_CHIPSET")

    # Define for  UART16550 required (so for all except Piton Board)
    if options.board != "piton_board":
        defines.append("PITON_UART16550")

    # --eth CL options is default for chipset
    if options.eth or options.design == "chipset" or options.design == "system":
        # Ethernet controller is supported on Genesys2 and nexysVideo
        if options.board == "genesys2" or options.board == "nexysVideo":
            defines.append("PITON_FPGA_ETHERNETLITE")
        else:
            print_info("--eth option is ignored for %s" % options.board)

    # --oled option for String on a display
    if options.oled != None:
        if options.board == "genesys2" or options.board == "nexysVideo":
            if len(options.oled) > OLED_STRING_LEN:
                disp_string = options.oled[0:64]
                # strip is important. Vivado fails if there is whitespace at the end
                disp_string = disp_string.strip()
                print_warning("\"%s\" is too long string for OLED. \
                                Cutting down to \"%s\"" % (options.oled, disp_string))
            else:
                # strip is important. Vivado fails if there is whitespace at the end
                disp_string = options.oled.strip()
            defines.append("{OLED_STRING=\\\"%s\\\"}" % disp_string)
        else:
            print_warning("--oled option is ignored for %s" % options.board)
    elif options.design == "chipset" and (options.board == "genesys2" or options.board == "nexysVideo"):
        disp_string = "Heeey!          I am a chipset  for (Open)Piton Enjoy debugging!"
        defines.append("{OLED_STRING=\\\"%s\\\"}" % disp_string)

    return defines

def makeMemMapping(st_brd, work_dir, log_dir):
    prev_dir = os.getcwd()

    os.chdir(work_dir)
    print_info("Starting mapping of a test to %s" % st_brd.storage.upper())
    make_mem_map.makeMapping(st_brd)
    # These are always in MODEL_DIR
    os.chdir(MODEL_DIR)

    test_proto_dir = os.path.join(DV_ROOT, "design/chipset/io_ctrl/xilinx/common/ip_cores/bram_256x512/")
    os.system('mv test_proto.coe %s' % test_proto_dir)
    bram_map_dir = os.path.join(DV_ROOT, "design/chipset/rtl/")
    os.system('mv storage_addr_trans.v %s' % bram_map_dir)
    # These are always in work_dir
    os.chdir(work_dir)
    print_info("Creating UART stream for a test...")
    i2s.makeStreamFile("bram_map.log")
    os.system('mv make_mem_map.log %s' % log_dir)
    os.system('mv bram_map.log %s' % log_dir)

    os.chdir(prev_dir)

def genUARTInit(board, design_data):
    print_info("Using core clock frequency: %s MHz" % design_data["BOARDS"][board]["FREQ"])
    div = calcUARTLatch(design_data, board)
    path = os.path.join(DV_ROOT, "design/chipset/io_ctrl/xilinx/")
    path = os.path.join(path, board, "ip_cores/atg_uart_init/uart_data.coe")
    f = open(path, 'w')
    print("memory_initialization_radix=16;", file=f)
    print("""memory_initialization_vector=00000080 %08x 00000000 00000003 00000003 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000;""" % div, file=f)
    f.close()

def main():
    parser = OptionParser(add_help_option=False)
    parser = setParserOptions(parser)
    (options, args) = parser.parse_args()

    exit_code = 0
    design_data = checkCmdOptions(options)

    ###################################################
    # All options are considered valid from this point
    ###################################################

    rc_dir = ProtoDir(options.board, options.design, design_data)

    # Make a list of configuration specific defines
    defines = makeDefList(options)

    run_sim                 = False
    run_map_test            = False
    run_make_project        = True
    run_fpga_impl           = True
    run_gen_test_bram       = False
    run_f1_impl             = False

    if options.test_name != None:
        run_sim             = True
        run_map_test        = True

    if options.from_step == 'impl':
        run_make_project    = False

    if options.to_step == 'project':
        run_fpga_impl       = False

    if options.gen_test_bram == True:
        run_make_project    = False
        run_fpga_impl       = False
        run_gen_test_bram   = True

    if options.make_mem_map == True:
        run_map_test        = True
        run_make_project    = False
        run_fpga_impl       = False

    if options.board == "f1":
        run_f1_impl             = True
        run_make_project        = False
        run_fpga_impl           = False
        run_sim                 = False # maybe change later
        run_map_test            = False # maybe change later

    ##################################
    # Setting directory structure
    ##################################
    prev_dir = os.getcwd()
    os.chdir(MODEL_DIR)
    os.system('mkdir -p %s' % rc_dir.log)

    ##################################
    # Set environment vars for pyhp
    ##################################
    print_info("----- System Configuration -----")

    # tile config
    if (int(options.x_tiles)*int(options.y_tiles)) > 1:
        options.num_tiles = int(options.x_tiles)*int(options.y_tiles);
    elif int(options.num_tiles) > 1:
        print_info("overriding x_tiles and y_tiles, assuming x dimension is <= 8")
        # this is aligned with the sims behavior
        options.x_tiles = ((int(options.num_tiles)-1) % 8) + 1;
        options.y_tiles = int((int(options.num_tiles)-1) / 8 + 1);

    if int(options.x_tiles)>256:
        print_error("x_tiles can be at most 256")
        sys.exit(1)
    if int(options.y_tiles)>256:
        print_error("y_tiles can be at most 256")
        sys.exit(1)

    print_info("x_tiles   = " + str(options.x_tiles))
    print_info("y_tiles   = " + str(options.y_tiles))
    print_info("num_tiles = " + str(options.num_tiles))

    os.environ['PITON_X_TILES']   = str(options.x_tiles)
    os.environ['PITON_Y_TILES']   = str(options.y_tiles)
    os.environ['PITON_NUM_TILES'] = str(options.num_tiles)

    # core variant
    print_info("core      = " + str(options.core))
    for i in range(int(options.num_tiles)):
        os.environ['RTL_TILE' + str(i)] = "1"
        print_info('defining RTL_TILE' + str(i))

    if options.core == 'pico':

        os.environ['PITON_PICO']     = "1"

        for i in range(int(options.num_tiles)):
            os.environ['RTL_PICO' + str(i)] = "1"
            print_info('defining RTL_PICO' + str(i))

    elif options.core == 'pico_het':

        os.environ['PITON_PICO']     = "1"
        os.environ['PITON_PICO_HET'] = "1"

        for i in range(int(options.num_tiles)):
            if i %2:
                os.environ['RTL_PICO' + str(i)] = "1"
                print_info('setenv RTL_PICO' + str(i))

            else:
                os.environ['RTL_SPARC' + str(i)] = "1"
                print_info('setenv RTL_SPARC' + str(i))

    elif options.core == 'ariane':
        os.environ['PITON_ARIANE'] = "1"
        os.environ['PITON_RV64_PLATFORM'] = "1"
        os.environ['WT_DCACHE']    = "1"

        for i in range(int(options.num_tiles)):
            os.environ['RTL_ARIANE' + str(i)] = "1"
            print_info('setenv RTL_ARIANE' + str(i))

    elif options.core == 'sparc':
        # this is the default
        os.environ['PITON_OST1'] = "1"
        for i in range(int(options.num_tiles)):
            os.environ['RTL_SPARC' + str(i)] = "1"
            print_info('setenv RTL_SPARC' + str(i))

    else:
        print_error("invalid core configuration " + str(options.core))
        sys.exit(1)

    # network config
    if options.network_config not in ['2dmesh_config', 'xbar_config']:
        print_error('invalid network config ' + str(options.network_config))
        sys.exit(1)

    if options.linux_bootrom == "uboot":
        os.environ['PITON_UBOOT_SPL'] = "1"

    print_info("network   = " + str(options.network_config))
    os.environ['PITON_NETWORK_CONFIG'] = options.network_config

    # cache config
    print_info("l15 size  = " + str(options.config_l15_size))
    print_info("l15 assoc = " + str(options.config_l15_associativity))
    print_info("l1d size  = " + str(options.config_l1d_size))
    print_info("l1d assoc = " + str(options.config_l1d_associativity))
    print_info("l1i size  = " + str(options.config_l1i_size))
    print_info("l1i assoc = " + str(options.config_l1i_associativity))
    print_info("l2  size  = " + str(options.config_l2_size))
    print_info("l2  assoc = " + str(options.config_l2_associativity))

    os.environ['CONFIG_L15_SIZE']          = str(options.config_l15_size)
    os.environ['CONFIG_L15_ASSOCIATIVITY'] = str(options.config_l15_associativity)
    os.environ['CONFIG_L1D_SIZE']          = str(options.config_l1d_size)
    os.environ['CONFIG_L1D_ASSOCIATIVITY'] = str(options.config_l1d_associativity)
    os.environ['CONFIG_L1I_SIZE']          = str(options.config_l1i_size)
    os.environ['CONFIG_L1I_ASSOCIATIVITY'] = str(options.config_l1i_associativity)
    os.environ['CONFIG_L2_SIZE']           = str(options.config_l2_size)
    os.environ['CONFIG_L2_ASSOCIATIVITY']  = str(options.config_l2_associativity)

    # this is needed to generate the device tree
    os.environ['CONFIG_SYS_FREQ']          = str(int(float(design_data["BOARDS"][options.board]["FREQ"]) * 1e6))

    if (options.postroutephysopt):
        os.environ["VIVADO_POSTROUTEPHYSOPT"] = "1"
    else:
        os.environ["VIVADO_POSTROUTEPHYSOPT"] = "0"

    print_info("---- Additional RTL Defines ----")

    for d in defines:
        print_info(d)

    print_info("--------------------------------")

    ##################################
    # Get a trace
    ##################################
    if run_sim:

        print_info('Support for passing config arguments to sims is preliminary and not properly tested')

        config = ' -x_tiles=' + str(options.x_tiles)                         + \
                 ' -y_tiles=' + str(options.y_tiles)                         + \
                 ' -network_config=' + str(options.network_config)           + \
                 ' -config_l1i_size=' + str(options.config_l1i_size)          + \
                 ' -config_l1d_size=' + str(options.config_l1d_size)          + \
                 ' -config_l15_size=' + str(options.config_l1i_size)          + \
                 ' -config_l2_size='  + str(options.config_l2_size)          + \
                 ' -config_l1i_associativity=' + str(options.config_l1i_associativity) + \
                 ' -config_l1d_associativity=' + str(options.config_l1d_associativity) + \
                 ' -config_l15_associativity=' + str(options.config_l15_associativity) + \
                 ' -config_l2_associativity='  + str(options.config_l2_associativity)

        if options.core == 'pico':
            config += ' -pico'

        if options.core == 'pico_het':
            config += ' -pico -pico_het'

        if options.core == 'ariane':
            config += ' -ariane'

        print_info("Synthesizing a test: %s" % options.test_name)
        print_info("Compilation started")
        ret_val = os.system('sims -sys=manycore' + config + ' -vcs_build -vcs_build_args=+libext+.v -vcs_build_args=-Mupdate > %s/compilation.log' % rc_dir.log)
        if ret_val != 0:
            print_error("Compilation didn't finish successfully!")
            print_info("See for Errors in %s/compilation.log" % rc_dir.log)
            sys.exit(1)
        print_info("Simulation started")
        print_info("Using core clock frequency: %s MHz" % design_data["BOARDS"][options.board]["FREQ"])
        div = calcUARTLatch(design_data, options.board)
        os.system('sims -sys=manycore ' + config + ' -vcs_run -midas_args=-DUART_DIV_LATCH=0x%x %s > %s/simulation.log' % (div, options.test_name, rc_dir.log))

        f = open('%s/simulation.log' % rc_dir.log, 'r')
        cont = f.read()
        f.close()
        match = re.search(r'(HIT GOOD TRAP)', cont)
        if match == None:
            print_error("Test failed!")
            sys.exit(1)
        else:
            print_info("Test Passed!")

    ###################################
    # Make Mapping
    ###################################

    if run_map_test:
        if options.test_name != None:
            strg_type = "bram"
        else:
            strg_type = options.uart_dmw
        st_brd = StorageBoard(strg_type, options.board)
        makeMemMapping(st_brd, rc_dir.work, rc_dir.log)

    ################################################
    # Generate UART init sequence for ASM tests
    # based on system frequency
    ################################################
    if options.uart_dmw != None:
        print_info("Generating UART init sequence")
        genUARTInit(options.board, design_data)

    ##################################
    # Run FPGA flow
    ##################################
    dep_list = []

    if run_make_project:
        jid = makeProject(options.board, design_data, rc_dir.work, rc_dir.log, options.slurm, None)
        if jid != None:
            dep_list.append(jid)


    ## TODO: update this options for simulations from VCS
    if run_gen_test_bram:
        print_info("Regenerating a bram with a test")
        os.chdir(rc_dir.work)
        gen_test_bram_script = os.path.join(DV_ROOT, "tools/src/proto/gen_test_bram.tcl")
        os.system('vivado -mode batch -source %s' % gen_test_bram_script)

    # FPGA implementation
    if run_fpga_impl:
        if int(options.jobs)>1:
            print_info("Using %d jobs in Vivado" % int(options.jobs))
        os.environ['NUM_VIVADO_JOBS']   = str(int(options.jobs))
        jid = runImplFlow(options.board, design_data, rc_dir.work, rc_dir.log, defines, options.slurm, dep_list)
        if jid != None:
            dep_list.append(jid)

    # f1
    if run_f1_impl:
        src = os.path.join(os.environ["HDK_DIR"], "cl", "developer_designs", "piton_aws")
        jid = runImplF1(options.board, design_data, src, rc_dir.work, rc_dir.log, defines, options.slurm, dep_list)
        if jid != None:
            dep_list.append(jid)


    ####################################################################################
    # Waiting for all previous jobs to finish before checking results
    # dep_list has jobids only for slurm jobs, otherwise all steps
    # are run sequentially

    if options.slurm:
        if options.swait:
            print_info("Waiting for jobs to finish...")
            waitSlurmJobs(dep_list)
        else:
            print_info("Run 'protocheck -b %s -d %s' after jobs are finished to check results" % (options.board, options.design))

    # Check  implementation results
    if (options.slurm and options.swait) or (not options.slurm):
        if run_make_project:
            print_info("Checking Project Build results")
            if not buildProjectSuccess(rc_dir.log):
                exit_code = 1

        if run_fpga_impl:
            # check implementation only if project build was successfull
            if exit_code == 0:
                print_info("Checking Project Implementation results")
                if not implFlowSuccess(rc_dir.log, rc_dir.run, options.postroutephysopt):
                    exit_code = 1

    os.chdir(prev_dir)

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
