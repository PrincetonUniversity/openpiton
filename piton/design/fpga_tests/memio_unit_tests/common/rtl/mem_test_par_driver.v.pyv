// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

`include "define.tmp.h"

// Filename: mem_test_par_driver.v.pyv
// Author: mmckeown
// Description: This module implements a driver for
//              parallel memory tests,
//              i.e. concurrent read and write operations.  
//              The actual address and data that is 
//              being tested is generated by submodules 
//              and can vary.  Note, currently there
//              can be no sequential dependencies between
//              test address/data, i.e. every test should
//              be to separate a address.  There are no
//              ordering guarantees in this test driver
//              as of now.  Would be good to figure out
//              a way to fix that

module mem_test_par_driver(
    input                               clk,
    input                               rst_n,
    input                               en,

    input      [1:0]                    test_mode_en,

    input      [2:0]                    addr_mode,
    input      [`PHY_ADDR_WIDTH-1:0]    addr_incr_val,
    input      [7:0]                    data_payload_flits,
    input      [`PHY_ADDR_WIDTH-1:0]    mem_top_addr,

    output reg                          test_mem_val,
    output reg [`NOC_DATA_WIDTH-1:0]    test_mem_data,
    input                               test_mem_rdy,

    input                               mem_test_val,
    input      [`NOC_DATA_WIDTH-1:0]    mem_test_data,
    output reg                          mem_test_rdy,

    output reg                          test_running,
    output reg                          test_done,
    output reg                          test_timeout,
    output reg                          test_passed
);

///////////////////////
// Type declarations //
///////////////////////

// Memory load header flit
// CHIPID: 14'd0
// XPOS: 8'd0
// YPOS: 8'd0
// FBITS: 4'd0
// PAYLOAD LENGTH: 8'd2
// MESSAGE TYPE: MSG_TYPE_LOAD_MEM
// MSHR/TAG: dynamic
// RESERVED: 6'd0
localparam                              MEM_LOAD_HEADER_FLIT = {14'd0, 8'd0, 8'd0, 4'd0, 8'd2,
                                                                `MSG_TYPE_LOAD_MEM, 8'd0, 6'd0};

// Memory store header flit
// CHIPID: 14'd0
// XPOS: 8'd0
// YPOS: 8'd0
// FBITS: 4'd0
// PAYLOAD LENGTH: dynamic
// MESSAGE TYPE: MSG_TYPE_STORE_MEM
// MSHR/TAG: dynamic
// RESERVED: 6'd0
localparam                              MEM_STORE_HEADER_FLIT = {14'd0, 8'd0, 8'd0, 4'd0, 8'd0,
                                                                 `MSG_TYPE_STORE_MEM, 8'd0, 6'd0};

// Memory load ack header flit
// CHIPID: 14'h2aaa
// XPOS: 8'haa
// YPOS: 8'haa
// FBITS: 4'ha
// PAYLOAD LENGTH: dynamic
// MESSAGE TYPE: MSG_TYPE_LOAD_MEM_ACK
// MSHR/TAG: dynamic
// RESERVED: 6'd0
localparam                              MEM_LOAD_ACK_HEADER = {14'h2aaa, 8'haa, 8'haa, 4'ha, 8'd0,
                                                               `MSG_TYPE_LOAD_MEM_ACK, 8'dx, 6'd0};

// Memory store ack header flit
// CHIPID: 14'h2aaa
// XPOS: 8'haa
// YPOS: 8'haa
// FBITS: 4'ha
// PAYLOAD LENGTH: 8'd0
// MESSAGE TYPE: MSG_TYPE_STORE_MEM_ACK
// MSHR/TAG: dynamic
// RESERVED: 6'd0
localparam                              MEM_STORE_ACK_HEADER = {14'h2aaa, 8'haa, 8'haa, 4'ha, 8'd0,
                                                                `MSG_TYPE_STORE_MEM_ACK, 8'dx, 6'd0};

// Flit3 for memory requests
// SRC CHIPID: 14'h2aaa
// SRC X: 8'haa
// SRC Y: 8'haa
// SRC FBITS: 4'ha
// RESERVED: 30'd0
localparam                              MEM_REQ_FLIT3 = {14'h2aaa, 8'haa, 8'haa, 4'ha, 30'd0};

<%
    # PyHP needs these values as well
    import math
    PARALLEL_TRANSACTIONS = 256
    PARALLEL_TRANSACTIONS_LOG2 = int(math.ceil(math.log(PARALLEL_TRANSACTIONS, 2)))

    MAX_PACKET_LENGTH = 11
    MAX_PACKET_LENGTH_LOG2 = int(math.ceil(math.log(MAX_PACKET_LENGTH, 2)))
%>

// Maximum outstanding transactions
localparam                              PARALLEL_TRANSACTIONS = <% sys.stdout.write(str(PARALLEL_TRANSACTIONS)) %>;
localparam                              PARALLEL_TRANSACTIONS_LOG2 = <% sys.stdout.write(str(PARALLEL_TRANSACTIONS_LOG2)) %>;

localparam                              MAX_PACKET_LENGTH = <% sys.stdout.write(str(MAX_PACKET_LENGTH)) %>;
localparam                              MAX_PACKET_LENGTH_LOG2 = <% sys.stdout.write(str(MAX_PACKET_LENGTH_LOG2)) %>;

// High level test states
localparam                              TEST_STATE_RESET = 2'd0;
localparam                              TEST_STATE_RUN = 2'd1;
localparam                              TEST_STATE_PASS = 2'd2;
localparam                              TEST_STATE_FAIL = 2'd3;

// Timeout counter
localparam                              TIMEOUT_COUNTER_WIDTH = 31;
localparam                              TIMEOUT_COUNTER_THRESHOLD = 31'd1073741823;

// Test modes from one hot test_mode_en
localparam                              TEST_MODE_ADDRESS_OWN = 2'd1;
localparam                              TEST_MODE_RANDOM_DATA = 2'd2;

// Store/Load round robin IDs
localparam                              RR_STORE = 1'b0;
localparam                              RR_LOAD = 1'b1;

// Test state
reg  [1:0]                              test_state_f;
reg  [1:0]                              test_state_next;

// Timeout signals
reg                                     timeout_rst_n;
wire                                    timeout_trigger;

// Round robin store/load bit, 0 is stores turn, 1 is loads turn
reg                                     store_load_rr_f;
reg                                     store_load_rr_next;

// Outstanding memory transactions, basically MSHRs
reg  [`PHY_ADDR_WIDTH-1:0]              test_address_f[PARALLEL_TRANSACTIONS-1:0];
reg  [511:0]                            test_data_f[PARALLEL_TRANSACTIONS-1:0];
reg  [PARALLEL_TRANSACTIONS-1:0]        test_valid_f;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_store_f;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_store_ack_f;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_load_f;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_load_ack_f;

// Next data for above MSHRs
reg  [`PHY_ADDR_WIDTH-1:0]              test_address_next;
reg  [511:0]                            test_data_next;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_valid_next;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_store_next;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_store_ack_next;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_load_next;
reg  [PARALLEL_TRANSACTIONS-1:0]        test_load_ack_next;

// Priority encoded MSHR IDs
reg  [PARALLEL_TRANSACTIONS_LOG2-1:0]   first_invalid_id;
reg  [PARALLEL_TRANSACTIONS_LOG2-1:0]   first_valid_no_store_id;
reg  [PARALLEL_TRANSACTIONS_LOG2-1:0]   first_valid_store_no_load_id;
reg  [PARALLEL_TRANSACTIONS_LOG2-1:0]   first_complete_id;

// Other signals derived from MSHRs
reg                                     any_invalid;
reg                                     any_valid_no_store;
reg                                     any_valid_store_no_load;
reg                                     any_complete;

// Sending buffer
reg  [MAX_PACKET_LENGTH_LOG2-1:0]       flits_to_send_f;
reg  [MAX_PACKET_LENGTH_LOG2-1:0]       flits_to_send_next;
reg  [`NOC_DATA_WIDTH-1:0]              flit_send_buffer_f[MAX_PACKET_LENGTH-1:0];
reg  [`NOC_DATA_WIDTH-1:0]              flit_send_buffer_next[MAX_PACKET_LENGTH-1:0];
reg                                     can_load_send_buffer;

// Shifted response data for sdctrl_test, it expects the L2
// to pick correct data from 8B response, so we need to do the
// same
reg  [`NOC_DATA_WIDTH-1:0]              mem_test_data_shifted;

// Response flit counter, mshr ID, and read out expected data
reg  [MAX_PACKET_LENGTH_LOG2-1:0]       resp_flit_counter_f;
reg  [MAX_PACKET_LENGTH_LOG2-1:0]       resp_flit_counter_next;
reg  [PARALLEL_TRANSACTIONS_LOG2-1:0]   resp_id_f;
reg  [PARALLEL_TRANSACTIONS_LOG2-1:0]   resp_id_next;
reg  [`NOC_DATA_WIDTH-1:0]              load_ack_hdr_plus_length;
reg  [`NOC_DATA_WIDTH-1:0]              resp_expected_data_2d[7:0];
reg                                     resp_data_matches;
reg                                     resp_data_err;

// Keep track of last inserted address and data
reg  [`PHY_ADDR_WIDTH-1:0]              last_inserted_address_f;
reg  [`PHY_ADDR_WIDTH-1:0]              last_inserted_address_next;
reg  [511:0]                            last_inserted_data_f;
reg  [511:0]                            last_inserted_data_next;

// Test address/data generator signals
reg                                     test_state_reset;

wire [`PHY_ADDR_WIDTH-1:0]              address_own_address_next;
wire [511:0]                            address_own_data_next;
wire                                    address_own_done;

wire                                    random_data_next_val; 
wire [`PHY_ADDR_WIDTH-1:0]              random_data_address_next;
wire [511:0]                            random_data_data_next;
wire                                    random_data_done;

// Multiplexed next address and data from generators
reg                                     gen_addrdata_next_rdy;
reg                                     gen_addrdata_next_val;
reg  [`PHY_ADDR_WIDTH-1:0]              gen_address_next;
reg  [511:0]                            gen_data_next;
reg                                     gen_done;

//////////////////////
// Sequential Logic //
//////////////////////

always @ (posedge clk)
begin
    if (~rst_n)
    begin
        test_state_f <= TEST_STATE_RESET;
        store_load_rr_f <= RR_STORE;

        test_valid_f <= {PARALLEL_TRANSACTIONS{1'b0}};
        test_store_f <= {PARALLEL_TRANSACTIONS{1'b0}};
        test_store_ack_f <= {PARALLEL_TRANSACTIONS{1'b0}};
        test_load_f <= {PARALLEL_TRANSACTIONS{1'b0}};
        test_load_ack_f <= {PARALLEL_TRANSACTIONS{1'b0}};

        flits_to_send_f <= {MAX_PACKET_LENGTH_LOG2{1'b0}};

        resp_flit_counter_f <= {MAX_PACKET_LENGTH_LOG2{1'b0}};
    end
    else
    begin
        test_state_f <= test_state_next;
        store_load_rr_f <= store_load_rr_next;

        test_valid_f <= test_valid_next;
        test_store_f <= test_store_next;
        test_store_ack_f <= test_store_ack_next;
        test_load_f <= test_load_next;
        test_load_ack_f <= test_load_ack_next;

        flits_to_send_f <= flits_to_send_next;

        resp_flit_counter_f <= resp_flit_counter_next;
    end

    test_address_f[first_invalid_id] <= test_address_next;
    test_data_f[first_invalid_id] <= test_data_next;

<%
    for i in range(0, MAX_PACKET_LENGTH):
        print "    flit_send_buffer_f["+str(i)+"] <= flit_send_buffer_next["+str(i)+"];"
%>

    resp_id_f <= resp_id_next;

    last_inserted_address_f <= last_inserted_address_next;
    last_inserted_data_f <= last_inserted_data_next;
end

/////////////////////////
// Combinational Logic //
/////////////////////////

always @ *
begin
    test_running = (test_state_f == TEST_STATE_RUN);
    test_passed = (test_state_f == TEST_STATE_PASS);
    test_timeout = timeout_trigger;
    test_done = test_state_f[1];
end

// We are always ready to receive when running (no buffering or stalling required)
always @ *
    mem_test_rdy = test_running;

always @ *
    test_state_reset = (test_state_f == TEST_STATE_RESET);

// Reset timeout when something is sent across link
always @ *
    timeout_rst_n = ~((test_mem_val & test_mem_rdy) | (mem_test_val & mem_test_rdy)) & rst_n;

always @ *
    gen_addrdata_next_rdy = (test_running && any_invalid);

// Multiplex test mode outputs
always @ *
begin
    case (test_mode_en)
        TEST_MODE_ADDRESS_OWN:
        begin
            gen_addrdata_next_val = 1'b1;
            gen_address_next = address_own_address_next;
            gen_data_next = address_own_data_next;
            gen_done = address_own_done;
        end
        TEST_MODE_RANDOM_DATA:
        begin
            gen_addrdata_next_val = random_data_next_val;
            gen_address_next = random_data_address_next;
            gen_data_next = random_data_data_next;
            gen_done = random_data_done;
        end
        default:
        begin
            gen_addrdata_next_val = 1'bx;
            gen_address_next = {`PHY_ADDR_WIDTH{1'bx}};
            gen_data_next = 512'bx;
            gen_done = 1'bx;
        end
    endcase
end

// High-level state machine
always @ *
begin
    test_state_next = test_state_f;

    case (test_state_f)
        TEST_STATE_RESET:
        begin
            if (en)
                test_state_next = TEST_STATE_RUN;
        end
        TEST_STATE_RUN:
        begin
            // Success condition
            if (gen_done && ~(|test_valid_f))
                test_state_next = TEST_STATE_PASS;     

            // Timeout case
            if (timeout_trigger)
                test_state_next = TEST_STATE_FAIL;

            // Data error case
            if (resp_data_err)
                test_state_next = TEST_STATE_FAIL;
        end
        TEST_STATE_PASS: ;
        TEST_STATE_FAIL: ;
        default:
            test_state_next = TEST_STATE_RESET;
    endcase
end

// MSHR priority encoders, figures out what needs to be
// done based on MSHRs control bits
always @ *
begin
    // Default values
    first_invalid_id = 0;
    first_valid_no_store_id = 0;
    first_valid_store_no_load_id = 0;
    first_complete_id = 0;

    // Find first invalid entry
    any_invalid = ~(&test_valid_f);
    if (~test_valid_f[0])
        first_invalid_id = 0;
<%
    for i in range(1, PARALLEL_TRANSACTIONS):
        print "    else if (~test_valid_f["+str(i)+"])"
        print "        first_invalid_id = "+str(i)+";"
%>

    // Find first valid entry without a store already sent
    any_valid_no_store = |(test_valid_f & ~test_store_f);
    if (test_valid_f[0] & ~test_store_f[0])
        first_valid_no_store_id = 0;
<%
    for i in range(1, PARALLEL_TRANSACTIONS):
        print "    else if (test_valid_f["+str(i)+"] & ~test_store_f["+str(i)+"])"
        print "        first_valid_no_store_id = "+str(i)+";"
%>

    // Find first valid entry with a complete store and no load already sent
    any_valid_store_no_load = |(test_valid_f & test_store_f & test_store_ack_f & ~test_load_f);
    if (test_valid_f[0] & test_store_f[0] & test_store_ack_f[0] & ~test_load_f[0])
        first_valid_store_no_load_id = 0;
<%
    for i in range(1, PARALLEL_TRANSACTIONS):
        print "    else if (test_valid_f["+str(i)+"] & test_store_f["+str(i)+"] & test_store_ack_f["+str(i)+"] & ~test_load_f["+str(i)+"])"
        print "        first_valid_store_no_load_id = "+str(i)+";"
%>

    // Find first entry that is complete
    any_complete = |(test_valid_f & test_store_f & test_store_ack_f & test_load_f & test_load_ack_f);
    if (test_valid_f[0] & test_store_f[0] & test_store_ack_f[0] & test_load_f[0] & test_load_ack_f[0])
        first_complete_id = 0;
<%
    for i in range(1, PARALLEL_TRANSACTIONS):
        print "    else if (test_valid_f["+str(i)+"] & test_store_f["+str(i)+"] & test_store_ack_f["+str(i)+"] & test_load_f["+str(i)+"] & test_load_ack_f["+str(i)+"])"
        print "        first_complete_id = "+str(i)+";"
%>
end

// Address/data generation and MSHR satisfied logic
always @ *
begin
    // Default values
    test_valid_next = test_valid_f;
    test_address_next = test_address_f[first_invalid_id];
    test_data_next = test_data_f[first_invalid_id];
    last_inserted_address_next = last_inserted_address_f;
    last_inserted_data_next = last_inserted_data_f;

    // Insert valid entry
    // We can insert in reset state, as some addr/data generators
    // actually need us to latch the initial value to know what
    // the next value is (purely cominbational addr/data generators)
    if ((test_running || (test_state_reset && en)) && ~gen_done && any_invalid && gen_addrdata_next_val)
    begin
        test_valid_next[first_invalid_id] = 1'b1;
        test_address_next = gen_address_next;
        test_data_next = gen_data_next;
        last_inserted_address_next = gen_address_next;
        last_inserted_data_next = gen_data_next;
    end

    // Clear complete entry
    if (test_running && any_complete)
        test_valid_next[first_complete_id] = 1'b0;
end

// Sending logic, loads and stores
always @ *
begin
    // Default values
    test_mem_val = 1'b0;
    test_mem_data = {`NOC_DATA_WIDTH{1'bx}};
    flits_to_send_next = flits_to_send_f;
<%
    for i in range(0, MAX_PACKET_LENGTH):
        print "    flit_send_buffer_next["+str(i)+"] = flit_send_buffer_f["+str(i)+"];"
%>
    can_load_send_buffer = (flits_to_send_f == 0) || (flits_to_send_f == 1 && test_mem_rdy);
    store_load_rr_next = store_load_rr_f;
    test_store_next = test_store_f;
    test_load_next = test_load_f;
    
    // Send outgoing data
    if (test_running && flits_to_send_f > 0)
    begin
        test_mem_val = 1'b1;
        test_mem_data = flit_send_buffer_f[flits_to_send_f-1];
        if (test_mem_rdy)
            flits_to_send_next = flits_to_send_f - 1;
    end

    // Check for new store to send
    if (test_running && can_load_send_buffer && any_valid_no_store && 
        (store_load_rr_f == RR_STORE || ~any_valid_store_no_load))
    begin
        flits_to_send_next = 3 + data_payload_flits;

        // Data flits
        flit_send_buffer_next[data_payload_flits-1] = test_data_f[first_valid_no_store_id][`NOC_DATA_WIDTH-1:0];
        flit_send_buffer_next[data_payload_flits-2] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*2)-1:`NOC_DATA_WIDTH];
        flit_send_buffer_next[data_payload_flits-3] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*3)-1:`NOC_DATA_WIDTH*2];
        flit_send_buffer_next[data_payload_flits-4] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*4)-1:`NOC_DATA_WIDTH*3];
        flit_send_buffer_next[data_payload_flits-5] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*5)-1:`NOC_DATA_WIDTH*4];
        flit_send_buffer_next[data_payload_flits-6] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*6)-1:`NOC_DATA_WIDTH*5];
        flit_send_buffer_next[data_payload_flits-7] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*7)-1:`NOC_DATA_WIDTH*6];
        flit_send_buffer_next[data_payload_flits-8] = test_data_f[first_valid_no_store_id][(`NOC_DATA_WIDTH*8)-1:`NOC_DATA_WIDTH*7];
    
        // Header flit
        flit_send_buffer_next[2 + data_payload_flits] = MEM_STORE_HEADER_FLIT;
        flit_send_buffer_next[2 + data_payload_flits][`MSG_LENGTH] = 8'd2 + data_payload_flits;
        flit_send_buffer_next[2 + data_payload_flits][`MSG_MSHRID] = first_valid_no_store_id;

        // Address flit
        flit_send_buffer_next[1 + data_payload_flits] = {`NOC_DATA_WIDTH{1'b0}};
        flit_send_buffer_next[1 + data_payload_flits][`MSG_ADDR_] = test_address_f[first_valid_no_store_id];
        flit_send_buffer_next[1 + data_payload_flits][`MSG_DATA_SIZE_] = addr_mode;

        // Source flit
        flit_send_buffer_next[data_payload_flits] = MEM_REQ_FLIT3;

        store_load_rr_next = RR_LOAD;
        test_store_next[first_valid_no_store_id] = 1'b1;
    end
    // Check for new load to send
    else if (test_running && can_load_send_buffer && any_valid_store_no_load &&
             (store_load_rr_f == RR_LOAD || ~any_valid_no_store))
    begin
        flits_to_send_next = 3;
        
        // Header flit
        flit_send_buffer_next[2] = MEM_LOAD_HEADER_FLIT;
        flit_send_buffer_next[2][`MSG_MSHRID] = first_valid_store_no_load_id;

        // Address flit
        flit_send_buffer_next[1] = {`NOC_DATA_WIDTH{1'b0}};
        flit_send_buffer_next[1][`MSG_ADDR_] = test_address_f[first_valid_store_no_load_id];
        flit_send_buffer_next[1][`MSG_DATA_SIZE_] = addr_mode;

        // Source flit
        flit_send_buffer_next[0] = MEM_REQ_FLIT3;

        store_load_rr_next = RR_STORE;
        test_load_next[first_valid_store_no_load_id] = 1'b1;
    end

    // Clear complete entry
    if (test_running && any_complete)
    begin
        test_store_next[first_complete_id] = 1'b0;
        test_load_next[first_complete_id] = 1'b0;
    end
end

// Check store acks logic
always @ *
begin
    // Default values
    test_store_ack_next = test_store_ack_f;

    // Check for store ack
    if (test_running && mem_test_val && 
        mem_test_data[`MSG_DST_CHIPID_HI:`MSG_TYPE_LO] == MEM_STORE_ACK_HEADER[`MSG_DST_CHIPID_HI:`MSG_TYPE_LO])
        test_store_ack_next[mem_test_data[`MSG_MSHRID]] = 1'b1;

    // Clear complete entry
    if (test_running && any_complete)
        test_store_ack_next[first_complete_id] = 1'b0;
end

// Grab expected response data and transform to 2d
always @ *
begin
    resp_expected_data_2d[0] = test_data_f[resp_id_f][`NOC_DATA_WIDTH-1:0];
    resp_expected_data_2d[1] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*2)-1:`NOC_DATA_WIDTH];
    resp_expected_data_2d[2] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*3)-1:`NOC_DATA_WIDTH*2];
    resp_expected_data_2d[3] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*4)-1:`NOC_DATA_WIDTH*3];
    resp_expected_data_2d[4] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*5)-1:`NOC_DATA_WIDTH*4];
    resp_expected_data_2d[5] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*6)-1:`NOC_DATA_WIDTH*5];
    resp_expected_data_2d[6] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*7)-1:`NOC_DATA_WIDTH*6];
    resp_expected_data_2d[7] = test_data_f[resp_id_f][(`NOC_DATA_WIDTH*8)-1:`NOC_DATA_WIDTH*7];
end

// Need to shift the response data for sdctrl_test
// as SD expects the L2 will pick out the correct
// data out of the 8B, it ignores the bottom 3
// bits of the address
always @ *
begin
    mem_test_data_shifted = mem_test_data >> {test_address_f[resp_id_f][2:0], 3'b000};
end

// Logic to check if incoming data matches expected
always @ *
begin
    resp_data_matches = 1'b0;
    
    case (addr_mode)
        3'd0:
        begin
            // No data never matches I guess?
            resp_data_matches = 1'b0;
        end
        3'd1:
        begin
`ifdef SDCTRL_TEST
            if (mem_test_data_shifted[7:0] == resp_expected_data_2d[0][7:0])
`else // ifndef SDCTRL_TEST
            if (mem_test_data[7:0] == resp_expected_data_2d[0][7:0])
`endif // endif SDCTRL_TEST
                resp_data_matches = 1'b1;
        end
        3'd2:
        begin
`ifdef SDCTRL_TEST
            if (mem_test_data_shifted[15:0] == resp_expected_data_2d[0][15:0])
`else // ifndef SDCTRL_TEST
            if (mem_test_data[15:0] == resp_expected_data_2d[0][15:0])
`endif // endif SDCTRL_TEST
                resp_data_matches = 1'b1;
        end
        3'd3:
        begin
`ifdef SDCTRL_TEST
            if (mem_test_data_shifted[31:0] == resp_expected_data_2d[0][31:0])
`else // ifndef SDCTRL_TEST
            if (mem_test_data[31:0] == resp_expected_data_2d[0][31:0])
`endif // endif SDCTRL_TEST
                resp_data_matches = 1'b1;
        end
`ifdef SDCTRL_TEST
        3'd4:
        begin
            // SD only supports up to 8 bytes and always returns 8 flits.
            // It replicates the data to fill the remaining splace in the 8
            // flits.  So we should check all flits against the first 8bytes
            // of the test data.  If we check other flits according to test
            // data, as in the default case, it would fail.
            if (mem_test_data == resp_expected_data_2d[0])
                resp_data_matches = 1'b1;
        end
`endif // endif SDCTRL_TEST
        default:
        begin
            if (mem_test_data == resp_expected_data_2d[resp_flit_counter_f-1])
                resp_data_matches = 1'b1;
        end 
    endcase
end

// Check load response logic
always @ *
begin
    // Default values
    resp_flit_counter_next = resp_flit_counter_f;
    resp_id_next = resp_id_f;
    test_load_ack_next = test_load_ack_f;
    resp_data_err = 1'b0;

    // Helper variable to fill in expected payload length
    load_ack_hdr_plus_length = MEM_LOAD_ACK_HEADER | 
`ifdef SDCTRL_TEST
                               // SD always returns 8 flits, just replicates data
                               ({{`NOC_DATA_WIDTH-`MSG_LENGTH_WIDTH{1'b0}},`MSG_LENGTH_WIDTH'd8}<<`MSG_LENGTH_LO);
`else // ifndef SDCTRL_TEST
                               ({{`NOC_DATA_WIDTH-`MSG_LENGTH_WIDTH{1'b0}},data_payload_flits}<<`MSG_LENGTH_LO);
`endif // endif SDCTRL_TEST

    // Check for load ack header
    if (test_running && resp_flit_counter_f == 0 && mem_test_val &&
        mem_test_data[`MSG_DST_CHIPID_HI:`MSG_TYPE_LO] == load_ack_hdr_plus_length[`MSG_DST_CHIPID_HI:`MSG_TYPE_LO])
    begin
        resp_flit_counter_next = resp_flit_counter_f + 1;
        resp_id_next = mem_test_data[`MSG_MSHRID];
    end
    // Load ack data
    else if (test_running && resp_flit_counter_f > 0 && mem_test_val && resp_data_matches)
    begin
`ifdef SDCTRL_TEST
        if (resp_flit_counter_f == 8)
`else // ifndef SDCTRL_TEST
        if (resp_flit_counter_f == data_payload_flits)
`endif // endif SDCTRL_TEST
        begin
            resp_flit_counter_next = 0;
            test_load_ack_next[resp_id_f] = 1'b1;
        end
        else
        begin
            resp_flit_counter_next = resp_flit_counter_f + 1;
        end
    end
    // Error condition
    else if (test_running && resp_flit_counter_f > 0 && mem_test_val)
    begin
        // Wrong data!
        resp_data_err = 1'b1;
    end

    // Clear complete entry
    if (test_running && any_complete)
        test_load_ack_next[first_complete_id] = 1'b0;
end

//////////////////////////
// Sub-module Instances //
//////////////////////////

// Timeout counter
alarm_counter #(
    .COUNTER_WIDTH(TIMEOUT_COUNTER_WIDTH),
    .ALARM_THRESHOLD(TIMEOUT_COUNTER_THRESHOLD)
)timeout_counter(
    .clk(clk),
    .rst_n(timeout_rst_n),
    .en(test_running),
    .trigger(timeout_trigger)
);

address_own_addrdata address_own_addrdata(
    .en(test_mode_en[0]),

    .addr_incr_val(addr_incr_val),
    .mem_top_addr(mem_top_addr),

    .test_state_reset(test_state_reset),

    .curr_addr(last_inserted_address_f),
    .curr_data(last_inserted_data_f),

    .next_addr(address_own_address_next),
    .next_data(address_own_data_next),

    .done(address_own_done)
);

random_data_addrdata random_data_addrdata(
    .clk(clk),
    .rst_n(rst_n),
    .en(test_mode_en[1]),

    .addr_incr_val(addr_incr_val),
    .mem_top_addr(mem_top_addr),

    .test_state_reset(test_state_reset),

    .next_rdy(gen_addrdata_next_rdy),
    .next_val(random_data_next_val),
    .next_addr(random_data_address_next),
    .next_data(random_data_data_next),

    .done(random_data_done)
);

endmodule
